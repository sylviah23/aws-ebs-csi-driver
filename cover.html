
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>hooks: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kubernetes-sigs/aws-ebs-csi-driver/cmd/hooks/prestop.go (76.4%)</option>
				
				<option value="file1">github.com/kubernetes-sigs/aws-ebs-csi-driver/cmd/main.go (0.0%)</option>
				
				<option value="file2">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/batcher/batcher.go (95.0%)</option>
				
				<option value="file3">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/cloud.go (86.3%)</option>
				
				<option value="file4">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/devicemanager/allocator.go (100.0%)</option>
				
				<option value="file5">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/devicemanager/manager.go (89.4%)</option>
				
				<option value="file6">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/handlers.go (5.3%)</option>
				
				<option value="file7">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata/imds.go (94.1%)</option>
				
				<option value="file8">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata/k8s.go (50.0%)</option>
				
				<option value="file9">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata/labels.go (63.2%)</option>
				
				<option value="file10">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata/metadata.go (72.2%)</option>
				
				<option value="file11">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata/mock_metadata.go (19.7%)</option>
				
				<option value="file12">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/mock_cloud.go (0.0%)</option>
				
				<option value="file13">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/mock_ec2.go (90.6%)</option>
				
				<option value="file14">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/retry_manager.go (100.0%)</option>
				
				<option value="file15">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/volume_limits.go (38.7%)</option>
				
				<option value="file16">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/coalescer/coalescer.go (100.0%)</option>
				
				<option value="file17">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/constants.go (100.0%)</option>
				
				<option value="file18">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/controller.go (83.1%)</option>
				
				<option value="file19">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/controller_modify_volume.go (77.8%)</option>
				
				<option value="file20">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/driver.go (26.3%)</option>
				
				<option value="file21">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/identity.go (0.0%)</option>
				
				<option value="file22">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/internal/inflight.go (100.0%)</option>
				
				<option value="file23">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/mock_k8s_client.go (4.7%)</option>
				
				<option value="file24">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/mock_k8s_corev1.go (12.2%)</option>
				
				<option value="file25">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/mock_k8s_storagev1.go (8.1%)</option>
				
				<option value="file26">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/mock_k8s_storagev1_csinode.go (15.9%)</option>
				
				<option value="file27">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/node.go (91.0%)</option>
				
				<option value="file28">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/options.go (100.0%)</option>
				
				<option value="file29">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/trace.go (0.0%)</option>
				
				<option value="file30">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/validation.go (97.3%)</option>
				
				<option value="file31">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/version.go (83.3%)</option>
				
				<option value="file32">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/expiringcache/expiring_cache.go (100.0%)</option>
				
				<option value="file33">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/metrics/async.go (90.7%)</option>
				
				<option value="file34">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/metrics/metrics.go (59.3%)</option>
				
				<option value="file35">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/metrics/nvme.go (21.7%)</option>
				
				<option value="file36">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/mounter/mock_mount.go (0.0%)</option>
				
				<option value="file37">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/mounter/mount.go (75.0%)</option>
				
				<option value="file38">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/mounter/mount_linux.go (30.3%)</option>
				
				<option value="file39">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util/template/funcs.go (76.5%)</option>
				
				<option value="file40">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util/template/template.go (100.0%)</option>
				
				<option value="file41">github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util/util.go (64.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hooks

import (
        "context"
        "errors"
        "fmt"
        "os"

        v1 "k8s.io/api/core/v1"
        storagev1 "k8s.io/api/storage/v1"
        k8serrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/klog/v2"
)

/*
When a node is terminated, persistent workflows using EBS volumes can take 6+ minutes to start up again.
This happens when a volume is not cleanly unmounted, which causes the Attach/Detach controller (in kube-controller-manager)
to wait for 6 minutes before issuing a force detach and allowing the volume to be attached to another node.

This PreStop lifecycle hook aims to ensure that before the node (and the CSI driver node pod running on it) is shut down,
all VolumeAttachment objects associated with that node are removed, thereby indicating that all volumes have been successfully unmounted and detached.

No unnecessary delay is added to the termination workflow, as the PreStop hook logic is only executed when the node is being drained
(thus preventing delays in termination where the node pod is killed due to a rolling restart, or during driver upgrades, but the workload pods are expected to be running).
If the PreStop hook hangs during its execution, the driver node pod will be forcefully terminated after terminationGracePeriodSeconds, defined in the pod spec.
*/

const clusterAutoscalerTaint = "ToBeDeletedByClusterAutoscaler"
const v1KarpenterTaint = "karpenter.sh/disrupted"
const v1beta1KarpenterTaint = "karpenter.sh/disruption"

// drainTaints includes taints used by K8s or autoscalers that signify node draining or pod eviction.
var drainTaints = map[string]struct{}{
        v1.TaintNodeUnschedulable: {}, // Kubernetes common eviction taint (kubectl drain)
        clusterAutoscalerTaint:    {},
        v1KarpenterTaint:          {},
        v1beta1KarpenterTaint:     {},
}

func PreStop(clientset kubernetes.Interface) error <span class="cov8" title="1">{
        klog.InfoS("PreStop: executing PreStop lifecycle hook")

        nodeName := os.Getenv("CSI_NODE_NAME")
        if nodeName == "" </span><span class="cov8" title="1">{
                return errors.New("PreStop: CSI_NODE_NAME missing")
        }</span>

        <span class="cov8" title="1">node, err := fetchNode(clientset, nodeName)
        switch </span>{
        case k8serrors.IsNotFound(err):<span class="cov0" title="0">
                klog.InfoS("PreStop: node does not exist - assuming this is a termination event, checking for remaining VolumeAttachments", "node", nodeName)</span>
        case err != nil:<span class="cov8" title="1">
                return err</span>
        case !isNodeBeingDrained(node):<span class="cov8" title="1">
                klog.InfoS("PreStop: node is not being drained, skipping VolumeAttachments check", "node", nodeName)
                return nil</span>
        default:<span class="cov8" title="1">
                klog.InfoS("PreStop: node is being drained, checking for remaining VolumeAttachments", "node", nodeName)</span>
        }

        <span class="cov8" title="1">return waitForVolumeAttachments(clientset, nodeName)</span>
}

func fetchNode(clientset kubernetes.Interface, nodeName string) (*v1.Node, error) <span class="cov8" title="1">{
        node, err := clientset.CoreV1().Nodes().Get(context.Background(), nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("fetchNode: failed to retrieve node information: %w", err)
        }</span>
        <span class="cov8" title="1">return node, nil</span>
}

// isNodeBeingDrained returns true if node resource has a known drain/eviction taint.
func isNodeBeingDrained(node *v1.Node) bool <span class="cov8" title="1">{
        for _, taint := range node.Spec.Taints </span><span class="cov8" title="1">{
                if _, isDrainTaint := drainTaints[taint.Key]; isDrainTaint </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func waitForVolumeAttachments(clientset kubernetes.Interface, nodeName string) error <span class="cov8" title="1">{
        allAttachmentsDeleted := make(chan struct{})

        factory := informers.NewSharedInformerFactory(clientset, 0)
        informer := factory.Storage().V1().VolumeAttachments().Informer()

        _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                DeleteFunc: func(obj interface{}) </span><span class="cov8" title="1">{
                        klog.V(5).InfoS("DeleteFunc: VolumeAttachment deleted", "node", nodeName)
                        va, ok := obj.(*storagev1.VolumeAttachment)
                        if !ok </span><span class="cov0" title="0">{
                                klog.Error("DeleteFunc: error asserting object as type VolumeAttachment", "obj", va)
                        }</span>
                        <span class="cov8" title="1">if va.Spec.NodeName == nodeName </span><span class="cov8" title="1">{
                                if err := checkVolumeAttachments(clientset, nodeName, allAttachmentsDeleted); err != nil </span><span class="cov0" title="0">{
                                        klog.ErrorS(err, "DeleteFunc: error checking VolumeAttachments")
                                }</span>
                        }
                },
                UpdateFunc: func(oldObj, newObj interface{}) <span class="cov0" title="0">{
                        klog.V(5).InfoS("UpdateFunc: VolumeAttachment updated", "node", nodeName)
                        va, ok := newObj.(*storagev1.VolumeAttachment)
                        if !ok </span><span class="cov0" title="0">{
                                klog.Error("UpdateFunc: error asserting object as type VolumeAttachment", "obj", va)
                        }</span>
                        <span class="cov0" title="0">if va.Spec.NodeName == nodeName </span><span class="cov0" title="0">{
                                if err := checkVolumeAttachments(clientset, nodeName, allAttachmentsDeleted); err != nil </span><span class="cov0" title="0">{
                                        klog.ErrorS(err, "UpdateFunc: error checking VolumeAttachments")
                                }</span>
                        }
                },
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add event handler to VolumeAttachment informer: %w", err)
        }</span>

        <span class="cov8" title="1">go informer.Run(allAttachmentsDeleted)

        if err := checkVolumeAttachments(clientset, nodeName, allAttachmentsDeleted); err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "waitForVolumeAttachments: error checking VolumeAttachments")
        }</span>

        <span class="cov8" title="1">&lt;-allAttachmentsDeleted
        klog.InfoS("waitForVolumeAttachments: finished waiting for VolumeAttachments to be deleted. preStopHook completed")
        return nil</span>
}

func checkVolumeAttachments(clientset kubernetes.Interface, nodeName string, allAttachmentsDeleted chan struct{}) error <span class="cov8" title="1">{
        allAttachments, err := clientset.StorageV1().VolumeAttachments().List(context.Background(), metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("checkVolumeAttachments: failed to list VolumeAttachments: %w", err)
        }</span>

        <span class="cov8" title="1">for _, attachment := range allAttachments.Items </span><span class="cov8" title="1">{
                if attachment.Spec.NodeName == nodeName </span><span class="cov8" title="1">{
                        klog.InfoS("isVolumeAttachmentEmpty: not ready to exit, found VolumeAttachment", "attachment", attachment, "node", nodeName)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">close(allAttachmentsDeleted)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "context"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/kubernetes-sigs/aws-ebs-csi-driver/cmd/hooks"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/metrics"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/mounter"
        flag "github.com/spf13/pflag"
        "k8s.io/component-base/featuregate"
        logsapi "k8s.io/component-base/logs/api/v1"
        json "k8s.io/component-base/logs/json"
        "k8s.io/klog/v2"
)

var (
        featureGate = featuregate.NewFeatureGate()
)

func main() <span class="cov0" title="0">{
        fs := flag.NewFlagSet("aws-ebs-csi-driver", flag.ExitOnError)
        if err := logsapi.RegisterLogFormat(logsapi.JSONLogFormat, json.Factory{}, logsapi.LoggingBetaOptions); err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to register JSON log format")
        }</span>

        <span class="cov0" title="0">var (
                version  = fs.Bool("version", false, "Print the version and exit.")
                toStderr = fs.Bool("logtostderr", false, "log to standard error instead of files. DEPRECATED: will be removed in a future release.")
                args     = os.Args[1:]
                cmd      = string(driver.AllMode)
                options  = driver.Options{}
        )

        c := logsapi.NewLoggingConfiguration()
        err := logsapi.AddFeatureGates(featureGate)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to add feature gates")
        }</span>
        <span class="cov0" title="0">logsapi.AddFlags(c, fs)

        if len(os.Args) &gt; 1 &amp;&amp; !strings.HasPrefix(os.Args[1], "-") </span><span class="cov0" title="0">{
                cmd = os.Args[1]
                args = os.Args[2:]
        }</span>

        <span class="cov0" title="0">switch cmd </span>{
        case "pre-stop-hook":<span class="cov0" title="0">
                clientset, clientErr := metadata.DefaultKubernetesAPIClient(options.Kubeconfig)()
                if clientErr != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "unable to communicate with k8s API")
                }</span> else<span class="cov0" title="0"> {
                        err = hooks.PreStop(clientset)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.ErrorS(err, "failed to execute PreStop lifecycle hook")
                                klog.FlushAndExit(klog.ExitFlushTimeout, 1)
                        }</span>
                }
                <span class="cov0" title="0">klog.FlushAndExit(klog.ExitFlushTimeout, 0)</span>
        case string(driver.ControllerMode), string(driver.NodeMode), string(driver.AllMode):<span class="cov0" title="0">
                options.Mode = driver.Mode(cmd)</span>
        default:<span class="cov0" title="0">
                klog.Errorf("Unknown driver mode %s: Expected %s, %s, %s, or pre-stop-hook", cmd, driver.ControllerMode, driver.NodeMode, driver.AllMode)
                klog.FlushAndExit(klog.ExitFlushTimeout, 0)</span>
        }

        <span class="cov0" title="0">options.AddFlags(fs)

        if err = fs.Parse(args); err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "Failed to parse options")
                klog.FlushAndExit(klog.ExitFlushTimeout, 0)
        }</span>
        <span class="cov0" title="0">if err = options.Validate(); err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "Invalid options")
                klog.FlushAndExit(klog.ExitFlushTimeout, 0)
        }</span>

        <span class="cov0" title="0">err = logsapi.ValidateAndApply(c, featureGate)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to validate and apply logging configuration")
        }</span>

        <span class="cov0" title="0">if *version </span><span class="cov0" title="0">{
                versionInfo, versionErr := driver.GetVersionJSON()
                if versionErr != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to get version")
                        klog.FlushAndExit(klog.ExitFlushTimeout, 1)
                }</span>
                //nolint:forbidigo // Print version info without klog/timestamp
                <span class="cov0" title="0">fmt.Println(versionInfo)
                os.Exit(0)</span>
        }

        <span class="cov0" title="0">if *toStderr </span><span class="cov0" title="0">{
                klog.SetOutput(os.Stderr)
        }</span>

        // Start tracing as soon as possible
        <span class="cov0" title="0">if options.EnableOtelTracing </span><span class="cov0" title="0">{
                exporter, exporterErr := driver.InitOtelTracing()
                if exporterErr != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to initialize otel tracing")
                        klog.FlushAndExit(klog.ExitFlushTimeout, 1)
                }</span>
                // Exporter will flush traces on shutdown
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
                        defer cancel()
                        if shutdownErr := exporter.Shutdown(ctx); shutdownErr != nil </span><span class="cov0" title="0">{
                                klog.ErrorS(exporterErr, "could not shutdown otel exporter")
                        }</span>
                }()
        }

        <span class="cov0" title="0">cfg := metadata.MetadataServiceConfig{
                MetadataSources: options.MetadataSources,
                IMDSClient:      metadata.DefaultIMDSClient,
                K8sAPIClient:    metadata.DefaultKubernetesAPIClient(options.Kubeconfig),
        }

        region := os.Getenv("AWS_REGION")
        var md metadata.MetadataService
        var metadataErr error

        if options.Mode == driver.NodeMode </span><span class="cov0" title="0">{
                time.Sleep(5e9) // TODO: for proof of concept remove later
        }</span>

        <span class="cov0" title="0">if region != "" </span><span class="cov0" title="0">{
                klog.InfoS("Region provided via AWS_REGION environment variable", "region", region)
                if options.Mode != driver.ControllerMode </span><span class="cov0" title="0">{
                        klog.InfoS("Node service requires metadata even if AWS_REGION provided, initializing metadata")
                        md, metadataErr = metadata.NewMetadataService(cfg, region)
                }</span>
        } else<span class="cov0" title="0"> {
                klog.InfoS("Initializing metadata")
                md, metadataErr = metadata.NewMetadataService(cfg, region)
        }</span>

        <span class="cov0" title="0">if options.HTTPEndpoint != "" </span><span class="cov0" title="0">{
                r := metrics.InitializeRecorder(options.DeprecatedMetrics)
                r.InitializeMetricsHandler(options.HTTPEndpoint, "/metrics", options.MetricsCertFile, options.MetricsKeyFile)

                if options.Mode == driver.ControllerMode || options.Mode == driver.AllMode </span><span class="cov0" title="0">{
                        // TODO inject metrics in cloud for clean unit tests
                        r.InitializeAPIMetrics(options.DeprecatedMetrics)
                        r.InitializeAsyncEC2Metrics(60 * time.Second /* Don't emit metrics for detaches that take &lt; 60s */)
                }</span>
                <span class="cov0" title="0">if options.Mode == driver.NodeMode || options.Mode == driver.AllMode </span><span class="cov0" title="0">{
                        r.InitializeNVME(options.CsiMountPointPath, md.GetInstanceID())
                }</span>
        }

        <span class="cov0" title="0">if metadataErr != nil </span><span class="cov0" title="0">{
                klog.ErrorS(metadataErr, "Failed to initialize metadata when it is required")
                if options.Mode == driver.ControllerMode </span><span class="cov0" title="0">{
                        klog.InfoS("The region can be manually supplied via the AWS_REGION environment variable")
                }</span>
                <span class="cov0" title="0">klog.FlushAndExit(klog.ExitFlushTimeout, 1)</span>
        } else<span class="cov0" title="0"> if region == "" </span><span class="cov0" title="0">{
                region = md.GetRegion()
        }</span>

        <span class="cov0" title="0">cloud, err := cloud.NewCloud(region, options.AwsSdkDebugLog, options.UserAgentExtra, options.Batching, options.DeprecatedMetrics)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to create cloud service")
                klog.FlushAndExit(klog.ExitFlushTimeout, 1)
        }</span>

        <span class="cov0" title="0">m, err := mounter.NewNodeMounter(options.WindowsHostProcess)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to create node mounter")
                klog.FlushAndExit(klog.ExitFlushTimeout, 1)
        }</span>

        <span class="cov0" title="0">k8sClient, err := cfg.K8sAPIClient()
        if err != nil </span><span class="cov0" title="0">{
                klog.V(2).InfoS("Failed to setup k8s client", "err", err)
        }</span>

        // if options.Mode == driver.ControllerMode {
        //         metadata.ContinuousUpdateLabels(k8sClient, cloud, 10)
        // }

        <span class="cov0" title="0">if args[0] == "patcher" </span><span class="cov0" title="0">{
                metadata.ContinuousUpdateLabels(k8sClient, cloud, 10)
        }</span>

        <span class="cov0" title="0">drv, err := driver.NewDriver(cloud, &amp;options, m, md, k8sClient)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to create driver")
                klog.FlushAndExit(klog.ExitFlushTimeout, 1)
        }</span>
        <span class="cov0" title="0">if err := drv.Run(); err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to run driver")
                klog.FlushAndExit(klog.ExitFlushTimeout, 1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package batcher facilitates task aggregation and execution.
//
// Basic Usage:
// Instantiate a Batcher, set up its constraints, and then start adding tasks. As tasks accumulate,
// they are batched together for execution, either when a maximum task count is reached or a specified
// duration elapses. Results of the executed tasks are communicated asynchronously via channels.
//
// Example:
// Create a Batcher with a maximum of 10 tasks or a 5-second wait:
//
//        `b := batcher.New(10, 5*time.Second, execFunc)`
//
// Add a task and receive its result:
//
//        resultChan := make(chan batcher.BatchResult)
//        b.AddTask(myTask, resultChan)
//        result := &lt;-resultChan
//
// Key Components:
//   - `Batcher`: The main component that manages task queueing, aggregation, and execution.
//   - `BatchResult`: A structure encapsulating the response for a task.
//   - `taskEntry`: Internal representation of a task and its associated result channel.
//
// Task Duplication:
// Batcher identifies tasks by content. For multiple identical tasks, each has a unique result channel.
// This distinction ensures that identical tasks return their results to the appropriate callers.
package batcher

import (
        "time"

        "k8s.io/klog/v2"
)

// Batcher manages the batching and execution of tasks. It collects tasks up to a specified limit (maxEntries) or
// waits for a defined duration (maxDelay) before triggering a batch execution. The actual task execution
// logic is provided by the execFunc, which processes tasks and returns their corresponding results. Tasks are
// queued via the taskChan and stored in pendingTasks until batch execution.
type Batcher[InputType comparable, ResultType interface{}] struct {
        // execFunc is the function responsible for executing a batch of tasks.
        // It returns a map associating each task with its result.
        execFunc func(inputs []InputType) (map[InputType]ResultType, error)

        // pendingTasks holds the tasks that are waiting to be executed in a batch.
        // Each task is associated with one or more result channels to account for duplicates.
        pendingTasks map[InputType][]chan BatchResult[ResultType]

        // taskChan is the channel through which new tasks are added to the Batcher.
        taskChan chan taskEntry[InputType, ResultType]

        // maxEntries is the maximum number of tasks that can be batched together for execution.
        maxEntries int

        // maxDelay is the maximum duration the Batcher waits before executing a batch operation,
        // regardless of how many tasks are in the batch.
        maxDelay time.Duration
}

// BatchResult encapsulates the response of a batched task.
// A task will either have a result or an error, but not both.
type BatchResult[ResultType interface{}] struct {
        Result ResultType
        Err    error
}

// taskEntry represents a single task waiting to be batched and its associated result channel.
// The result channel is used to communicate the task's result back to the caller.
type taskEntry[InputType comparable, ResultType interface{}] struct {
        task       InputType
        resultChan chan BatchResult[ResultType]
}

// New creates and returns a Batcher configured with the specified maxEntries and maxDelay parameters.
// Upon instantiation, it immediately launches the internal task manager as a goroutine to oversee batch operations.
// The provided execFunc is used to execute batch requests.
func New[InputType comparable, ResultType interface{}](entries int, delay time.Duration, fn func(inputs []InputType) (map[InputType]ResultType, error)) *Batcher[InputType, ResultType] <span class="cov8" title="1">{
        klog.V(7).InfoS("New: initializing Batcher", "maxEntries", entries, "maxDelay", delay)

        b := &amp;Batcher[InputType, ResultType]{
                execFunc:     fn,
                pendingTasks: make(map[InputType][]chan BatchResult[ResultType]),
                taskChan:     make(chan taskEntry[InputType, ResultType], entries),
                maxEntries:   entries,
                maxDelay:     delay,
        }

        go b.taskManager()
        return b
}</span>

// AddTask adds a new task to the Batcher's queue.
func (b *Batcher[InputType, ResultType]) AddTask(t InputType, resultChan chan BatchResult[ResultType]) <span class="cov8" title="1">{
        klog.V(7).InfoS("AddTask: queueing task", "task", t)
        b.taskChan &lt;- taskEntry[InputType, ResultType]{task: t, resultChan: resultChan}
}</span>

// taskManager runs as a goroutine, continuously managing the Batcher's internal state.
// It batches tasks and triggers their execution based on set constraints (maxEntries and maxDelay).
func (b *Batcher[InputType, ResultType]) taskManager() <span class="cov8" title="1">{
        klog.V(7).InfoS("taskManager: started taskManager")
        var timerCh &lt;-chan time.Time

        exec := func() </span><span class="cov8" title="1">{
                timerCh = nil
                go b.execute(b.pendingTasks)
                b.pendingTasks = make(map[InputType][]chan BatchResult[ResultType])
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timerCh:<span class="cov8" title="1">
                        klog.V(7).InfoS("taskManager: maxDelay execution")
                        exec()</span>

                case t := &lt;-b.taskChan:<span class="cov8" title="1">
                        if _, exists := b.pendingTasks[t.task]; exists </span><span class="cov0" title="0">{
                                klog.InfoS("taskManager: duplicate task detected", "task", t.task)
                        }</span> else<span class="cov8" title="1"> {
                                b.pendingTasks[t.task] = make([]chan BatchResult[ResultType], 0)
                        }</span>
                        <span class="cov8" title="1">b.pendingTasks[t.task] = append(b.pendingTasks[t.task], t.resultChan)

                        if len(b.pendingTasks) == 1 </span><span class="cov8" title="1">{
                                klog.V(7).InfoS("taskManager: starting maxDelay timer")
                                timerCh = time.After(b.maxDelay)
                        }</span>

                        <span class="cov8" title="1">if len(b.pendingTasks) == b.maxEntries </span><span class="cov8" title="1">{
                                klog.V(7).InfoS("taskManager: maxEntries reached")
                                exec()
                        }</span>
                }
        }
}

// execute is called by taskManager to execute a batch of tasks.
// It calls the Batcher's internal execFunc and then sends the results of each task to its corresponding result channels.
func (b *Batcher[InputType, ResultType]) execute(pendingTasks map[InputType][]chan BatchResult[ResultType]) <span class="cov8" title="1">{
        batch := make([]InputType, 0, len(pendingTasks))
        for task := range pendingTasks </span><span class="cov8" title="1">{
                batch = append(batch, task)
        }</span>

        <span class="cov8" title="1">klog.V(7).InfoS("execute: calling execFunc", "batchSize", len(batch))
        resultsMap, err := b.execFunc(batch)
        if err != nil </span><span class="cov8" title="1">{
                klog.ErrorS(err, "execute: error executing batch")
        }</span>

        <span class="cov8" title="1">klog.V(7).InfoS("execute: sending batch results", "batch", batch)
        for _, task := range batch </span><span class="cov8" title="1">{
                r := resultsMap[task]
                for _, ch := range pendingTasks[task] </span><span class="cov8" title="1">{
                        select </span>{
                        case ch &lt;- BatchResult[ResultType]{Result: r, Err: err}:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0">
                                klog.V(7).InfoS("execute: ignoring channel with no receiver")</span>
                        }
                }
        }
        <span class="cov8" title="1">klog.V(7).InfoS("execute: finished execution", "batchSize", len(batch))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloud

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "fmt"
        "os"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/ec2"
        "github.com/aws/aws-sdk-go-v2/service/ec2/types"
        "github.com/aws/smithy-go"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/batcher"
        dm "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/devicemanager"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/expiringcache"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/metrics"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/klog/v2"
)

// AWS volume types.
const (
        // VolumeTypeIO1 represents a provisioned IOPS SSD type of volume.
        VolumeTypeIO1 = "io1"
        // VolumeTypeIO2 represents a provisioned IOPS SSD type of volume.
        VolumeTypeIO2 = "io2"
        // VolumeTypeGP2 represents a general purpose SSD type of volume.
        VolumeTypeGP2 = "gp2"
        // VolumeTypeGP3 represents a general purpose SSD type of volume.
        VolumeTypeGP3 = "gp3"
        // VolumeTypeSC1 represents a cold HDD (sc1) type of volume.
        VolumeTypeSC1 = "sc1"
        // VolumeTypeST1 represents a throughput-optimized HDD type of volume.
        VolumeTypeST1 = "st1"
        // VolumeTypeStandard represents a previous type of  volume.
        VolumeTypeStandard = "standard"
)

// AWS provisioning limits.
// Source: http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html
const (
        io1MinTotalIOPS             = 100
        io1MaxTotalIOPS             = 64000
        io1MaxIOPSPerGB             = 50
        io2MinTotalIOPS             = 100
        io2MaxTotalIOPS             = 64000
        io2BlockExpressMaxTotalIOPS = 256000
        io2MaxIOPSPerGB             = 1000
        gp3MaxTotalIOPS             = 16000
        gp3MinTotalIOPS             = 3000
        gp3MaxIOPSPerGB             = 500
)

var (
        ValidVolumeTypes = []string{
                VolumeTypeIO1,
                VolumeTypeIO2,
                VolumeTypeGP2,
                VolumeTypeGP3,
                VolumeTypeSC1,
                VolumeTypeST1,
                VolumeTypeStandard,
        }
)

const (
        cacheForgetDelay = 1 * time.Hour
)

// AWS provisioning limits.
// Source:
//
//        https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-restrictions
const (
        // MaxNumTagsPerResource represents the maximum number of tags per AWS resource.
        MaxNumTagsPerResource = 50
        // MinTagKeyLength represents the minimum key length for a tag.
        MinTagKeyLength = 1
        // MaxTagKeyLength represents the maximum key length for a tag.
        MaxTagKeyLength = 128
        // MaxTagValueLength represents the maximum value length for a tag.
        MaxTagValueLength = 256
)

// Defaults.
const (
        // DefaultVolumeSize represents the default volume size.
        DefaultVolumeSize int64 = 100 * util.GiB
)

// Tags.
const (
        // VolumeNameTagKey is the key value that refers to the volume's name.
        VolumeNameTagKey = "CSIVolumeName"
        // SnapshotNameTagKey is the key value that refers to the snapshot's name.
        SnapshotNameTagKey = "CSIVolumeSnapshotName"
        // KubernetesTagKeyPrefix is the prefix of the key value that is reserved for Kubernetes.
        KubernetesTagKeyPrefix = "kubernetes.io"
        // AWSTagKeyPrefix is the prefix of the key value that is reserved for AWS.
        AWSTagKeyPrefix = "aws:"
        // AwsEbsDriverTagKey is the tag to identify if a volume/snapshot is managed by ebs csi driver.
        AwsEbsDriverTagKey = "ebs.csi.aws.com/cluster"
)

// Batcher.
const (
        volumeIDBatcher volumeBatcherType = iota
        volumeTagBatcher

        snapshotIDBatcher snapshotBatcherType = iota
        snapshotTagBatcher

        batchDescribeTimeout = 30 * time.Second
        batchMaxDelay        = 500 * time.Millisecond // Minimizes RPC latency and EC2 API calls. Tuned via scalability tests.
)

var (
        // ErrMultiDisks is an error that is returned when multiple
        // disks are found with the same volume name.
        ErrMultiDisks = errors.New("multiple disks with same name")

        // ErrDiskExistsDiffSize is an error that is returned if a disk with a given
        // name, but different size, is found.
        ErrDiskExistsDiffSize = errors.New("there is already a disk with same name and different size")

        // ErrNotFound is returned when a resource is not found.
        ErrNotFound = errors.New("resource was not found")

        // ErrIdempotentParameterMismatch is returned when another request with same idempotent token is in-flight.
        ErrIdempotentParameterMismatch = errors.New("parameters on this idempotent request are inconsistent with parameters used in previous request(s)")

        // ErrAlreadyExists is returned when a resource is already existent.
        ErrAlreadyExists = errors.New("resource already exists")

        // ErrMultiSnapshots is returned when multiple snapshots are found
        // with the same ID.
        ErrMultiSnapshots = errors.New("multiple snapshots with the same name found")

        // ErrInvalidMaxResults is returned when a MaxResults pagination parameter is between 1 and 4.
        ErrInvalidMaxResults = errors.New("maxResults parameter must be 0 or greater than or equal to 5")

        // ErrVolumeNotBeingModified is returned if volume being described is not being modified.
        ErrVolumeNotBeingModified = errors.New("volume is not being modified")

        // ErrInvalidArgument is returned if parameters were rejected by cloud provider.
        ErrInvalidArgument = errors.New("invalid argument")

        // ErrInvalidRequest is returned if parameters were rejected by driver.
        ErrInvalidRequest = errors.New("invalid request")

        // ErrLimitExceeded is returned if a user exceeds a quota.
        ErrLimitExceeded = errors.New("limit exceeded")
)

// Set during build time via -ldflags.
var driverVersion string

var invalidParameterErrorCodes = map[string]struct{}{
        "InvalidParameter":            {},
        "InvalidParameterCombination": {},
        "InvalidParameterDependency":  {},
        "InvalidParameterValue":       {},
        "UnknownParameter":            {},
        "UnknownVolumeType":           {},
        "UnsupportedOperation":        {},
        "ValidationError":             {},
}

// Disk represents a EBS volume.
type Disk struct {
        VolumeID         string
        CapacityGiB      int32
        AvailabilityZone string
        SnapshotID       string
        OutpostArn       string
        Attachments      []string
}

// DiskOptions represents parameters to create an EBS volume.
type DiskOptions struct {
        CapacityBytes          int64
        Tags                   map[string]string
        VolumeType             string
        IOPSPerGB              int32
        AllowIOPSPerGBIncrease bool
        IOPS                   int32
        Throughput             int32
        AvailabilityZone       string
        OutpostArn             string
        Encrypted              bool
        BlockExpress           bool
        MultiAttachEnabled     bool
        // KmsKeyID represents a fully qualified resource name to the key to use for encryption.
        // example: arn:aws:kms:us-east-1:012345678910:key/abcd1234-a123-456a-a12b-a123b4cd56ef
        KmsKeyID                 string
        SnapshotID               string
        VolumeInitializationRate int32
}

// ModifyDiskOptions represents parameters to modify an EBS volume.
type ModifyDiskOptions struct {
        VolumeType string
        IOPS       int32
        Throughput int32
}

// ModifyTagsOptions represents parameter to modify the tags of an existing EBS volume.
type ModifyTagsOptions struct {
        TagsToAdd    map[string]string
        TagsToDelete []string
}

// Snapshot represents an EBS volume snapshot.
type Snapshot struct {
        SnapshotID     string
        SourceVolumeID string
        Size           int32
        CreationTime   time.Time
        ReadyToUse     bool
}

// ListSnapshotsResponse is the container for our snapshots along with a pagination token to pass back to the caller.
type ListSnapshotsResponse struct {
        Snapshots []*Snapshot
        NextToken string
}

// SnapshotOptions represents parameters to create an EBS volume.
type SnapshotOptions struct {
        Tags       map[string]string
        OutpostArn string
}

// ec2ListSnapshotsResponse is a helper struct returned from the AWS API calling function to the main ListSnapshots function.
type ec2ListSnapshotsResponse struct {
        Snapshots []types.Snapshot
        NextToken *string
}

// volumeWaitParameters dictates how to poll for volume events.
// E.g. how often to check if volume is created after an EC2 CreateVolume call.
type volumeWaitParameters struct {
        creationInitialDelay time.Duration
        creationBackoff      wait.Backoff
        modificationBackoff  wait.Backoff
        attachmentBackoff    wait.Backoff
}

var (
        vwp = volumeWaitParameters{
                // Based on our testing in us-west-2 and ap-south-1, the median/p99 time until volume creation is ~1.5/~4 seconds.
                // We have found that the following parameters are optimal for minimizing provisioning time and DescribeVolumes calls
                // we queue DescribeVolume calls after [1.25, 0.5, 0.75, 1.125, 1.7, 2.5, 3] seconds.
                // In total, we wait for ~60 seconds.
                creationInitialDelay: 1250 * time.Millisecond,
                creationBackoff: wait.Backoff{
                        Duration: 500 * time.Millisecond,
                        Factor:   1.5,
                        Steps:    11,
                },

                // Most attach/detach operations on AWS finish within 1-4 seconds.
                // By using 1 second starting interval with a backoff of 1.8,
                // we get [1, 1.8, 3.24, 5.832000000000001, 10.4976].
                // In total, we wait for 2601 seconds.
                attachmentBackoff: wait.Backoff{
                        Duration: 1 * time.Second,
                        Factor:   1.8,
                        Steps:    13,
                },

                modificationBackoff: wait.Backoff{
                        Duration: 1 * time.Second,
                        Factor:   1.7,
                        Steps:    10,
                },
        }
)

// volumeBatcherType is an enum representing the types of volume batchers available.
type volumeBatcherType int

// snapshotBatcherType is an enum representing the types of snapshot batchers available.
type snapshotBatcherType int

// batcherManager maintains a collection of batchers for different types of tasks.
type batcherManager struct {
        volumeIDBatcher             *batcher.Batcher[string, *types.Volume]
        volumeTagBatcher            *batcher.Batcher[string, *types.Volume]
        instanceIDBatcher           *batcher.Batcher[string, *types.Instance]
        snapshotIDBatcher           *batcher.Batcher[string, *types.Snapshot]
        snapshotTagBatcher          *batcher.Batcher[string, *types.Snapshot]
        volumeModificationIDBatcher *batcher.Batcher[string, *types.VolumeModification]
}

type cloud struct {
        region               string
        ec2                  EC2API
        dm                   dm.DeviceManager
        bm                   *batcherManager
        rm                   *retryManager
        vwp                  volumeWaitParameters
        likelyBadDeviceNames expiringcache.ExpiringCache[string, sync.Map]
        latestClientTokens   expiringcache.ExpiringCache[string, int]
}

var _ Cloud = &amp;cloud{}

// NewCloud returns a new instance of AWS cloud
// It panics if session is invalid.
func NewCloud(region string, awsSdkDebugLog bool, userAgentExtra string, batching bool, deprecatedMetrics bool) (Cloud, error) <span class="cov8" title="1">{
        c := newEC2Cloud(region, awsSdkDebugLog, userAgentExtra, batching, deprecatedMetrics)
        return c, nil
}</span>

func newEC2Cloud(region string, awsSdkDebugLog bool, userAgentExtra string, batchingEnabled bool, deprecatedMetrics bool) Cloud <span class="cov8" title="1">{
        cfg, err := config.LoadDefaultConfig(context.Background(), config.WithRegion(region))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">if awsSdkDebugLog </span><span class="cov8" title="1">{
                cfg.ClientLogMode = aws.LogRequestWithBody | aws.LogResponseWithBody
        }</span>

        // Set the env var so that the session appends custom user agent string
        <span class="cov8" title="1">if userAgentExtra != "" </span><span class="cov8" title="1">{
                os.Setenv("AWS_EXECUTION_ENV", "aws-ebs-csi-driver-"+driverVersion+"-"+userAgentExtra)
        }</span> else<span class="cov8" title="1"> {
                os.Setenv("AWS_EXECUTION_ENV", "aws-ebs-csi-driver-"+driverVersion)
        }</span>

        <span class="cov8" title="1">svc := ec2.NewFromConfig(cfg, func(o *ec2.Options) </span><span class="cov8" title="1">{
                o.APIOptions = append(o.APIOptions,
                        RecordRequestsMiddleware(deprecatedMetrics),
                        LogServerErrorsMiddleware(), // This middlware should always be last so it sees an unmangled error
                )

                endpoint := os.Getenv("AWS_EC2_ENDPOINT")
                if endpoint != "" </span><span class="cov0" title="0">{
                        o.BaseEndpoint = &amp;endpoint
                }</span>

                <span class="cov8" title="1">o.RetryMaxAttempts = retryMaxAttempt</span>
        })

        <span class="cov8" title="1">var bm *batcherManager
        if batchingEnabled </span><span class="cov8" title="1">{
                klog.V(4).InfoS("newEC2Cloud: batching enabled")
                bm = newBatcherManager(svc)
        }</span>

        <span class="cov8" title="1">return &amp;cloud{
                region:               region,
                dm:                   dm.NewDeviceManager(),
                ec2:                  svc,
                bm:                   bm,
                rm:                   newRetryManager(),
                vwp:                  vwp,
                likelyBadDeviceNames: expiringcache.New[string, sync.Map](cacheForgetDelay),
                latestClientTokens:   expiringcache.New[string, int](cacheForgetDelay),
        }</span>
}

// newBatcherManager initializes a new instance of batcherManager.
// Each batcher's `entries` set to maximum results returned by relevant EC2 API call without pagination.
// Each batcher's `delay` minimizes RPC latency and EC2 API calls. Tuned via scalability tests.
func newBatcherManager(svc EC2API) *batcherManager <span class="cov8" title="1">{
        return &amp;batcherManager{
                volumeIDBatcher: batcher.New(500, batchMaxDelay, func(ids []string) (map[string]*types.Volume, error) </span><span class="cov8" title="1">{
                        return execBatchDescribeVolumes(svc, ids, volumeIDBatcher)
                }</span>),
                volumeTagBatcher: batcher.New(500, batchMaxDelay, func(names []string) (map[string]*types.Volume, error) <span class="cov8" title="1">{
                        return execBatchDescribeVolumes(svc, names, volumeTagBatcher)
                }</span>),
                instanceIDBatcher: batcher.New(50, batchMaxDelay, func(ids []string) (map[string]*types.Instance, error) <span class="cov8" title="1">{
                        return execBatchDescribeInstances(svc, ids)
                }</span>),
                snapshotIDBatcher: batcher.New(1000, batchMaxDelay, func(ids []string) (map[string]*types.Snapshot, error) <span class="cov8" title="1">{
                        return execBatchDescribeSnapshots(svc, ids, snapshotIDBatcher)
                }</span>),
                snapshotTagBatcher: batcher.New(1000, batchMaxDelay, func(names []string) (map[string]*types.Snapshot, error) <span class="cov8" title="1">{
                        return execBatchDescribeSnapshots(svc, names, snapshotTagBatcher)
                }</span>),
                volumeModificationIDBatcher: batcher.New(500, batchMaxDelay, func(names []string) (map[string]*types.VolumeModification, error) <span class="cov8" title="1">{
                        return execBatchDescribeVolumesModifications(svc, names)
                }</span>),
        }
}

// execBatchDescribeVolumes executes a batched DescribeVolumes API call depending on the type of batcher.
func execBatchDescribeVolumes(svc EC2API, input []string, batcher volumeBatcherType) (map[string]*types.Volume, error) <span class="cov8" title="1">{
        var request *ec2.DescribeVolumesInput

        switch batcher </span>{
        case volumeIDBatcher:<span class="cov8" title="1">
                klog.V(7).InfoS("execBatchDescribeVolumes", "volumeIds", input)
                request = &amp;ec2.DescribeVolumesInput{
                        VolumeIds: input,
                }</span>

        case volumeTagBatcher:<span class="cov8" title="1">
                klog.V(7).InfoS("execBatchDescribeVolumes", "names", input)
                filters := []types.Filter{
                        {
                                Name:   aws.String("tag:" + VolumeNameTagKey),
                                Values: input,
                        },
                }
                request = &amp;ec2.DescribeVolumesInput{
                        Filters: filters,
                }</span>

        default:<span class="cov0" title="0">
                return nil, errors.New("execBatchDescribeVolumes: unsupported request type")</span>
        }

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), batchDescribeTimeout)
        defer cancel()

        resp, err := describeVolumes(ctx, svc, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make(map[string]*types.Volume)

        for _, v := range resp </span><span class="cov8" title="1">{
                volume := v
                key, err := extractVolumeKey(&amp;volume, batcher)
                if err != nil </span><span class="cov8" title="1">{
                        klog.Warningf("execBatchDescribeVolumes: skipping volume: %v, reason: %v", volume, err)
                        continue</span>
                }
                <span class="cov8" title="1">result[key] = &amp;volume</span>
        }

        <span class="cov8" title="1">klog.V(7).InfoS("execBatchDescribeVolumes: success", "result", result)
        return result, nil</span>
}

// batchDescribeVolumes processes a DescribeVolumes request. Depending on the request,
// it determines the appropriate batcher to use, queues the task, and waits for the result.
func (c *cloud) batchDescribeVolumes(request *ec2.DescribeVolumesInput) (*types.Volume, error) <span class="cov8" title="1">{
        var b *batcher.Batcher[string, *types.Volume]
        var task string

        switch </span>{
        case len(request.VolumeIds) == 1 &amp;&amp; request.VolumeIds[0] != "":<span class="cov8" title="1">
                b = c.bm.volumeIDBatcher
                task = request.VolumeIds[0]</span>

        case len(request.Filters) == 1 &amp;&amp; *request.Filters[0].Name == "tag:"+VolumeNameTagKey &amp;&amp; len(request.Filters[0].Values) == 1:<span class="cov8" title="1">
                b = c.bm.volumeTagBatcher
                task = request.Filters[0].Values[0]</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("%w: batchDescribeVolumes: request: %v", ErrInvalidRequest, request)</span>
        }

        <span class="cov8" title="1">ch := make(chan batcher.BatchResult[*types.Volume])

        b.AddTask(task, ch)

        r := &lt;-ch

        if r.Err != nil </span><span class="cov8" title="1">{
                return nil, r.Err
        }</span>
        <span class="cov8" title="1">if r.Result == nil </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="1">return r.Result, nil</span>
}

// extractVolumeKey retrieves the key associated with a given volume based on the batcher type.
// For the volumeIDBatcher type, it returns the volume's ID.
// For other types, it searches for the VolumeNameTagKey within the volume's tags.
func extractVolumeKey(v *types.Volume, batcher volumeBatcherType) (string, error) <span class="cov8" title="1">{
        if batcher == volumeIDBatcher </span><span class="cov8" title="1">{
                if v.VolumeId == nil </span><span class="cov8" title="1">{
                        return "", errors.New("extractVolumeKey: missing volume ID")
                }</span>
                <span class="cov8" title="1">return *v.VolumeId, nil</span>
        }
        <span class="cov8" title="1">for _, tag := range v.Tags </span><span class="cov8" title="1">{
                klog.V(7).InfoS("extractVolumeKey: processing tag", "volume", v, "*tag.Key", *tag.Key, "VolumeNameTagKey", VolumeNameTagKey)
                if tag.Key == nil || tag.Value == nil </span><span class="cov0" title="0">{
                        klog.V(7).InfoS("extractVolumeKey: skipping volume due to missing tag", "volume", v, "tag", tag)
                        continue</span>
                }
                <span class="cov8" title="1">if *tag.Key == VolumeNameTagKey </span><span class="cov8" title="1">{
                        klog.V(7).InfoS("extractVolumeKey: found volume name tag", "volume", v, "tag", tag)
                        return *tag.Value, nil
                }</span>
        }
        <span class="cov8" title="1">return "", errors.New("extractVolumeKey: missing VolumeNameTagKey in volume tags")</span>
}

func (c *cloud) CreateDisk(ctx context.Context, volumeName string, diskOptions *DiskOptions) (*Disk, error) <span class="cov8" title="1">{
        var (
                createType    string
                iops          int32
                throughput    int32
                err           error
                maxIops       int32
                minIops       int32
                maxIopsPerGb  int32
                requestedIops int32
        )

        capacityGiB := util.BytesToGiB(diskOptions.CapacityBytes)

        if diskOptions.IOPS &gt; 0 &amp;&amp; diskOptions.IOPSPerGB &gt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid StorageClass parameters; specify either IOPS or IOPSPerGb, not both")
        }</span>

        <span class="cov8" title="1">createType = diskOptions.VolumeType
        // If no volume type is specified, GP3 is used as default for newly created volumes.
        if createType == "" </span><span class="cov8" title="1">{
                createType = VolumeTypeGP3
        }</span>

        <span class="cov8" title="1">switch createType </span>{
        case VolumeTypeGP2, VolumeTypeSC1, VolumeTypeST1, VolumeTypeStandard:<span class="cov8" title="1"></span>
        case VolumeTypeIO1:<span class="cov8" title="1">
                maxIops = io1MaxTotalIOPS
                minIops = io1MinTotalIOPS
                maxIopsPerGb = io1MaxIOPSPerGB</span>
        case VolumeTypeIO2:<span class="cov8" title="1">
                if diskOptions.BlockExpress </span><span class="cov8" title="1">{
                        maxIops = io2BlockExpressMaxTotalIOPS
                }</span> else<span class="cov8" title="1"> {
                        maxIops = io2MaxTotalIOPS
                }</span>
                <span class="cov8" title="1">minIops = io2MinTotalIOPS
                maxIopsPerGb = io2MaxIOPSPerGB</span>
        case VolumeTypeGP3:<span class="cov8" title="1">
                maxIops = gp3MaxTotalIOPS
                minIops = gp3MinTotalIOPS
                maxIopsPerGb = gp3MaxIOPSPerGB
                throughput = diskOptions.Throughput</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid AWS VolumeType %q", diskOptions.VolumeType)</span>
        }

        <span class="cov8" title="1">if diskOptions.MultiAttachEnabled &amp;&amp; createType != VolumeTypeIO2 </span><span class="cov8" title="1">{
                return nil, errors.New("CreateDisk: multi-attach is only supported for io2 volumes")
        }</span>

        <span class="cov8" title="1">if maxIops &gt; 0 </span><span class="cov8" title="1">{
                if diskOptions.IOPS &gt; 0 </span><span class="cov8" title="1">{
                        requestedIops = diskOptions.IOPS
                }</span> else<span class="cov8" title="1"> if diskOptions.IOPSPerGB &gt; 0 </span><span class="cov8" title="1">{
                        requestedIops = diskOptions.IOPSPerGB * capacityGiB
                }</span>
                <span class="cov8" title="1">iops = capIOPS(createType, capacityGiB, requestedIops, minIops, maxIops, maxIopsPerGb, diskOptions.AllowIOPSPerGBIncrease)</span>
        }

        <span class="cov8" title="1">tags := make([]types.Tag, 0, len(diskOptions.Tags))
        for key, value := range diskOptions.Tags </span><span class="cov8" title="1">{
                tags = append(tags, types.Tag{Key: aws.String(key), Value: aws.String(value)})
        }</span>
        <span class="cov8" title="1">tagSpec := types.TagSpecification{
                ResourceType: types.ResourceTypeVolume,
                Tags:         tags,
        }

        zone := diskOptions.AvailabilityZone
        if zone == "" </span><span class="cov8" title="1">{
                zone, err = c.randomAvailabilityZone(ctx)
                klog.V(5).InfoS("[Debug] AZ is not provided. Using node AZ", "zone", zone)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get availability zone %w", err)
                }</span>
        }

        // The first client token used for any volume is the volume name as provided via CSI
        // However, if a volume fails to create asyncronously (that is, the CreateVolume call
        // succeeds but the volume ultimately fails to create), the client token is burned until
        // EC2 forgets about its use (measured as 12 hours under normal conditions)
        //
        // To prevent becoming stuck for 12 hours when this occurs, we sequentially append "-2",
        // "-3", "-4", etc to the volume name before hashing on the subsequent attempt after a
        // volume fails to create because of an IdempotentParameterMismatch AWS error
        // The most recent appended value is stored in an expiring cache to prevent memory leaks
        <span class="cov8" title="1">tokenBase := volumeName
        if tokenNumber, ok := c.latestClientTokens.Get(volumeName); ok </span><span class="cov8" title="1">{
                tokenBase += "-" + strconv.Itoa(*tokenNumber)
        }</span>

        // We use a sha256 hash to guarantee the token that is less than or equal to 64 characters
        <span class="cov8" title="1">clientToken := sha256.Sum256([]byte(tokenBase))

        requestInput := &amp;ec2.CreateVolumeInput{
                AvailabilityZone:   aws.String(zone),
                ClientToken:        aws.String(hex.EncodeToString(clientToken[:])),
                Size:               aws.Int32(capacityGiB),
                VolumeType:         types.VolumeType(createType),
                Encrypted:          aws.Bool(diskOptions.Encrypted),
                MultiAttachEnabled: aws.Bool(diskOptions.MultiAttachEnabled),
                TagSpecifications:  []types.TagSpecification{tagSpec},
        }

        // EBS doesn't handle empty outpost arn, so we have to include it only when it's non-empty
        if len(diskOptions.OutpostArn) &gt; 0 </span><span class="cov8" title="1">{
                requestInput.OutpostArn = aws.String(diskOptions.OutpostArn)
        }</span>

        <span class="cov8" title="1">if len(diskOptions.KmsKeyID) &gt; 0 </span><span class="cov8" title="1">{
                requestInput.KmsKeyId = aws.String(diskOptions.KmsKeyID)
                requestInput.Encrypted = aws.Bool(true)
        }</span>
        <span class="cov8" title="1">if iops &gt; 0 </span><span class="cov8" title="1">{
                requestInput.Iops = aws.Int32(iops)
        }</span>
        <span class="cov8" title="1">if throughput &gt; 0 </span><span class="cov8" title="1">{
                requestInput.Throughput = aws.Int32(throughput)
        }</span>
        <span class="cov8" title="1">snapshotID := diskOptions.SnapshotID
        if len(snapshotID) &gt; 0 </span><span class="cov8" title="1">{
                requestInput.SnapshotId = aws.String(snapshotID)
        }</span>
        <span class="cov8" title="1">if diskOptions.VolumeInitializationRate &gt; 0 </span><span class="cov8" title="1">{
                requestInput.VolumeInitializationRate = aws.Int32(diskOptions.VolumeInitializationRate)
        }</span>

        <span class="cov8" title="1">response, err := c.ec2.CreateVolume(ctx, requestInput, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.createVolumeRetryer
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if isAWSErrorSnapshotNotFound(err) </span><span class="cov8" title="1">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov8" title="1">if isAWSErrorIdempotentParameterMismatch(err) </span><span class="cov8" title="1">{
                        nextTokenNumber := 2
                        if tokenNumber, ok := c.latestClientTokens.Get(volumeName); ok </span><span class="cov8" title="1">{
                                nextTokenNumber = *tokenNumber + 1
                        }</span>
                        <span class="cov8" title="1">c.latestClientTokens.Set(volumeName, &amp;nextTokenNumber)
                        return nil, ErrIdempotentParameterMismatch</span>
                }
                <span class="cov8" title="1">if isAWSErrorVolumeLimitExceeded(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %w", ErrLimitExceeded, err)
                }</span>
                <span class="cov8" title="1">if isAwsErrorMaxIOPSLimitExceeded(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %w", ErrLimitExceeded, err)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("could not create volume in EC2: %w", err)</span>
        }

        <span class="cov8" title="1">volumeID := aws.ToString(response.VolumeId)
        if len(volumeID) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("volume ID was not returned by CreateVolume")
        }</span>

        <span class="cov8" title="1">size := *response.Size
        if size == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("disk size was not returned by CreateVolume")
        }</span>

        <span class="cov8" title="1">if err := c.waitForVolume(ctx, volumeID); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("timed out waiting for volume to create: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Disk{CapacityGiB: size, VolumeID: volumeID, AvailabilityZone: zone, SnapshotID: snapshotID, OutpostArn: aws.ToString(response.OutpostArn)}, nil</span>
}

// execBatchDescribeVolumesModifications executes a batched DescribeVolumesModifications API call.
func execBatchDescribeVolumesModifications(svc EC2API, input []string) (map[string]*types.VolumeModification, error) <span class="cov8" title="1">{
        klog.V(7).InfoS("execBatchDescribeVolumeModifications", "volumeIds", input)
        request := &amp;ec2.DescribeVolumesModificationsInput{
                VolumeIds: input,
        }

        ctx, cancel := context.WithTimeout(context.Background(), batchDescribeTimeout)
        defer cancel()

        resp, err := describeVolumesModifications(ctx, svc, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make(map[string]*types.VolumeModification)

        for _, m := range resp </span><span class="cov8" title="1">{
                volumeModification := m
                result[*volumeModification.VolumeId] = &amp;volumeModification
        }</span>

        <span class="cov8" title="1">klog.V(7).InfoS("execBatchDescribeVolumeModifications: success", "result", result)
        return result, nil</span>
}

// batchDescribeVolumesModifications processes a DescribeVolumesModifications request by queuing the task and waiting for the result.
func (c *cloud) batchDescribeVolumesModifications(request *ec2.DescribeVolumesModificationsInput) (*types.VolumeModification, error) <span class="cov8" title="1">{
        var task string

        if len(request.VolumeIds) == 1 &amp;&amp; request.VolumeIds[0] != "" </span><span class="cov8" title="1">{
                task = request.VolumeIds[0]
        }</span> else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("%w: batchDescribeVolumesModifications: invalid request, request: %v", ErrInvalidRequest, request)
        }</span>

        <span class="cov8" title="1">ch := make(chan batcher.BatchResult[*types.VolumeModification])

        b := c.bm.volumeModificationIDBatcher
        b.AddTask(task, ch)

        r := &lt;-ch

        if r.Err != nil </span><span class="cov8" title="1">{
                return nil, r.Err
        }</span>
        <span class="cov8" title="1">return r.Result, nil</span>
}

// ModifyTags adds, updates, and deletes tags for the specified EBS volume.
func (c *cloud) ModifyTags(ctx context.Context, volumeID string, tagOptions ModifyTagsOptions) error <span class="cov8" title="1">{
        if len(tagOptions.TagsToDelete) &gt; 0 </span><span class="cov8" title="1">{
                deleteTagsInput := &amp;ec2.DeleteTagsInput{
                        Resources: []string{volumeID},
                        Tags:      make([]types.Tag, 0, len(tagOptions.TagsToDelete)),
                }
                for _, tagKey := range tagOptions.TagsToDelete </span><span class="cov8" title="1">{
                        deleteTagsInput.Tags = append(deleteTagsInput.Tags, types.Tag{Key: aws.String(tagKey)})
                }</span>
                <span class="cov8" title="1">_, deleteErr := c.ec2.DeleteTags(ctx, deleteTagsInput)
                if deleteErr != nil </span><span class="cov8" title="1">{
                        klog.ErrorS(deleteErr, "failed to delete tags", "volumeID", volumeID)
                        return deleteErr
                }</span>
        }
        <span class="cov8" title="1">if len(tagOptions.TagsToAdd) &gt; 0 </span><span class="cov8" title="1">{
                createTagsInput := &amp;ec2.CreateTagsInput{
                        Resources: []string{volumeID},
                        Tags:      make([]types.Tag, 0, len(tagOptions.TagsToAdd)),
                }
                for k, v := range tagOptions.TagsToAdd </span><span class="cov8" title="1">{
                        createTagsInput.Tags = append(createTagsInput.Tags, types.Tag{
                                Key:   aws.String(k),
                                Value: aws.String(v),
                        })
                }</span>
                <span class="cov8" title="1">_, addErr := c.ec2.CreateTags(ctx, createTagsInput)
                if addErr != nil </span><span class="cov8" title="1">{
                        klog.ErrorS(addErr, "failed to create tags", "volumeID", volumeID)
                        return addErr
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ResizeOrModifyDisk resizes an EBS volume in GiB increments, rounding up to the next possible allocatable unit, and/or modifies an EBS
// volume with the parameters in ModifyDiskOptions.
// The resizing operation is performed only when newSizeBytes != 0.
// It returns the volume size after this call or an error if the size couldn't be determined or the volume couldn't be modified.
func (c *cloud) ResizeOrModifyDisk(ctx context.Context, volumeID string, newSizeBytes int64, options *ModifyDiskOptions) (int32, error) <span class="cov8" title="1">{
        if newSizeBytes != 0 </span><span class="cov8" title="1">{
                klog.V(4).InfoS("Received Resize and/or Modify Disk request", "volumeID", volumeID, "newSizeBytes", newSizeBytes, "options", options)
        }</span> else<span class="cov8" title="1"> {
                klog.V(4).InfoS("Received Modify Disk request", "volumeID", volumeID, "options", options)
        }</span>

        <span class="cov8" title="1">newSizeGiB, err := util.RoundUpGiB(newSizeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">needsModification, volumeSize, err := c.validateModifyVolume(ctx, volumeID, newSizeGiB, options)

        if err != nil || !needsModification </span><span class="cov8" title="1">{
                return volumeSize, err
        }</span>

        <span class="cov8" title="1">req := &amp;ec2.ModifyVolumeInput{
                VolumeId: aws.String(volumeID),
        }
        if newSizeBytes != 0 </span><span class="cov8" title="1">{
                req.Size = aws.Int32(newSizeGiB)
        }</span>
        <span class="cov8" title="1">if options.IOPS != 0 </span><span class="cov8" title="1">{
                req.Iops = aws.Int32(options.IOPS)
        }</span>
        <span class="cov8" title="1">if options.VolumeType != "" </span><span class="cov8" title="1">{
                req.VolumeType = types.VolumeType(options.VolumeType)
        }</span>
        <span class="cov8" title="1">if options.Throughput != 0 </span><span class="cov8" title="1">{
                req.Throughput = aws.Int32(options.Throughput)
        }</span>
        <span class="cov8" title="1">response, err := c.ec2.ModifyVolume(ctx, req, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.modifyVolumeRetryer
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if isAWSErrorInvalidParameter(err) </span><span class="cov0" title="0">{
                        // Wrap error to preserve original message from AWS as to why this was an invalid argument
                        return 0, fmt.Errorf("%w: %w", ErrInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">if isAWSErrorVolumeModificationSizeLimitExceeded(err) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("%w: %w", ErrLimitExceeded, err)
                }</span>
                <span class="cov8" title="1">if isAwsErrorMaxIOPSLimitExceeded(err) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("%w: %w", ErrLimitExceeded, err)
                }</span>
                <span class="cov8" title="1">return 0, err</span>
        }
        // If the volume modification isn't immediately completed, wait for it to finish
        <span class="cov8" title="1">state := string(response.VolumeModification.ModificationState)
        if !volumeModificationDone(state) </span><span class="cov8" title="1">{
                err = c.waitForVolumeModification(ctx, volumeID)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }
        // Perform one final check on the volume
        <span class="cov8" title="1">return c.checkDesiredState(ctx, volumeID, newSizeGiB, options)</span>
}

func (c *cloud) DeleteDisk(ctx context.Context, volumeID string) (bool, error) <span class="cov8" title="1">{
        request := &amp;ec2.DeleteVolumeInput{VolumeId: &amp;volumeID}
        if _, err := c.ec2.DeleteVolume(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.deleteVolumeRetryer
        }</span>); err != nil <span class="cov8" title="1">{
                if isAWSErrorVolumeNotFound(err) </span><span class="cov0" title="0">{
                        return false, ErrNotFound
                }</span>
                <span class="cov8" title="1">return false, fmt.Errorf("DeleteDisk could not delete volume: %w", err)</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// execBatchDescribeInstances executes a batched DescribeInstances API call.
func execBatchDescribeInstances(svc EC2API, input []string) (map[string]*types.Instance, error) <span class="cov8" title="1">{
        klog.V(7).InfoS("execBatchDescribeInstances", "instanceIds", input)
        request := &amp;ec2.DescribeInstancesInput{
                InstanceIds: input,
        }

        ctx, cancel := context.WithTimeout(context.Background(), batchDescribeTimeout)
        defer cancel()

        resp, err := describeInstances(ctx, svc, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make(map[string]*types.Instance)

        for _, i := range resp </span><span class="cov8" title="1">{
                instance := i
                if instance.InstanceId == nil </span><span class="cov0" title="0">{
                        klog.Warningf("execBatchDescribeInstances: skipping instance: %v, reason: missing instance ID", instance)
                        continue</span>
                }
                <span class="cov8" title="1">result[*instance.InstanceId] = &amp;instance</span>
        }

        <span class="cov8" title="1">klog.V(7).InfoS("execBatchDescribeInstances: success", "result", result)
        return result, nil</span>
}

// batchDescribeInstances processes a DescribeInstances request by queuing the task and waiting for the result.
func (c *cloud) batchDescribeInstances(request *ec2.DescribeInstancesInput) (*types.Instance, error) <span class="cov8" title="1">{
        var task string

        if len(request.InstanceIds) == 1 &amp;&amp; request.InstanceIds[0] != "" </span><span class="cov8" title="1">{
                task = request.InstanceIds[0]
        }</span> else<span class="cov8" title="1"> {
                return nil, fmt.Errorf("%w: batchDescribeInstances: request: %v", ErrInvalidRequest, request)
        }</span>

        <span class="cov8" title="1">ch := make(chan batcher.BatchResult[*types.Instance])

        b := c.bm.instanceIDBatcher
        b.AddTask(task, ch)

        r := &lt;-ch

        if r.Err != nil </span><span class="cov8" title="1">{
                return nil, r.Err
        }</span>
        <span class="cov8" title="1">if r.Result == nil </span><span class="cov0" title="0">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="1">return r.Result, nil</span>
}

func (c *cloud) AttachDisk(ctx context.Context, volumeID, nodeID string) (string, error) <span class="cov8" title="1">{
        instance, err := c.GetInstance(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">likelyBadDeviceNames, ok := c.likelyBadDeviceNames.Get(nodeID)
        if !ok </span><span class="cov8" title="1">{
                likelyBadDeviceNames = new(sync.Map)
                c.likelyBadDeviceNames.Set(nodeID, likelyBadDeviceNames)
        }</span>

        <span class="cov8" title="1">device, err := c.dm.NewDevice(instance, volumeID, likelyBadDeviceNames)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer device.Release(false)

        if !device.IsAlreadyAssigned </span><span class="cov8" title="1">{
                request := &amp;ec2.AttachVolumeInput{
                        Device:     aws.String(device.Path),
                        InstanceId: aws.String(nodeID),
                        VolumeId:   aws.String(volumeID),
                }

                resp, attachErr := c.ec2.AttachVolume(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                        o.Retryer = c.rm.attachVolumeRetryer
                }</span>)
                <span class="cov8" title="1">if attachErr != nil </span><span class="cov8" title="1">{
                        if isAWSErrorBlockDeviceInUse(attachErr) </span><span class="cov8" title="1">{
                                // If block device is "in use", that likely indicates a bad name that is in use by a block
                                // device that we do not know about (example: block devices attached in the AMI, which are
                                // not reported in DescribeInstance's block device map)
                                //
                                // Store such bad names in the "likely bad" map to be considered last in future attempts
                                likelyBadDeviceNames.Store(device.Path, struct{}{})
                        }</span>
                        <span class="cov8" title="1">if isAWSErrorAttachmentLimitExceeded(attachErr) </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("%w: %w", ErrLimitExceeded, attachErr)
                        }</span>
                        <span class="cov8" title="1">return "", fmt.Errorf("could not attach volume %q to node %q: %w", volumeID, nodeID, attachErr)</span>
                }
                <span class="cov8" title="1">likelyBadDeviceNames.Delete(device.Path)
                klog.V(5).InfoS("[Debug] AttachVolume", "volumeID", volumeID, "nodeID", nodeID, "resp", resp)</span>
        }

        <span class="cov8" title="1">_, err = c.WaitForAttachmentState(ctx, types.VolumeAttachmentStateAttached, volumeID, *instance.InstanceId, device.Path, device.IsAlreadyAssigned)

        // This is the only situation where we taint the device
        if err != nil </span><span class="cov0" title="0">{
                device.Taint()
                return "", err
        }</span>

        // TODO: Check volume capability matches for ALREADY_EXISTS
        // This could happen when request volume already attached to request node,
        // but is incompatible with the specified volume_capability or readonly flag
        <span class="cov8" title="1">return device.Path, nil</span>
}

func (c *cloud) DetachDisk(ctx context.Context, volumeID, nodeID string) error <span class="cov8" title="1">{
        instance, err := c.GetInstance(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">device, err := c.dm.GetDevice(instance, volumeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer device.Release(true)

        if !device.IsAlreadyAssigned </span><span class="cov8" title="1">{
                klog.InfoS("DetachDisk: called on non-attached volume", "volumeID", volumeID)
        }</span>

        <span class="cov8" title="1">request := &amp;ec2.DetachVolumeInput{
                InstanceId: aws.String(nodeID),
                VolumeId:   aws.String(volumeID),
        }

        _, err = c.ec2.DetachVolume(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.detachVolumeRetryer
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if isAWSErrorIncorrectState(err) ||
                        isAWSErrorInvalidAttachmentNotFound(err) ||
                        isAWSErrorVolumeNotFound(err) </span><span class="cov0" title="0">{
                        metrics.AsyncEC2Metrics().ClearDetachMetric(volumeID, nodeID)
                        return ErrNotFound
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("could not detach volume %q from node %q: %w", volumeID, nodeID, err)</span>
        }

        <span class="cov8" title="1">attachment, err := c.WaitForAttachmentState(ctx, types.VolumeAttachmentStateDetached, volumeID, *instance.InstanceId, "", false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if attachment != nil </span><span class="cov0" title="0">{
                // We expect it to be nil, it is (maybe) interesting if it is not
                klog.V(2).InfoS("waitForAttachmentState returned non-nil attachment with state=detached", "attachment", attachment)
        }</span>
        <span class="cov8" title="1">metrics.AsyncEC2Metrics().ClearDetachMetric(volumeID, nodeID)

        return nil</span>
}

// WaitForAttachmentState polls until the attachment status is the expected value.
func (c *cloud) WaitForAttachmentState(ctx context.Context, expectedState types.VolumeAttachmentState, volumeID string, expectedInstance string, expectedDevice string, alreadyAssigned bool) (*types.VolumeAttachment, error) <span class="cov8" title="1">{
        var attachment *types.VolumeAttachment

        verifyVolumeFunc := func(ctx context.Context) (bool, error) </span><span class="cov8" title="1">{
                request := &amp;ec2.DescribeVolumesInput{
                        VolumeIds: []string{volumeID},
                }

                volume, err := c.getVolume(ctx, request)
                if err != nil </span><span class="cov8" title="1">{
                        // The VolumeNotFound error is special -- we don't need to wait for it to repeat
                        if isAWSErrorVolumeNotFound(err) </span><span class="cov8" title="1">{
                                if expectedState == types.VolumeAttachmentStateDetached </span><span class="cov8" title="1">{
                                        // The disk doesn't exist, assume it's detached, log warning and stop waiting
                                        klog.InfoS("Waiting for volume to be detached but the volume does not exist", "volumeID", volumeID)
                                        return true, nil
                                }</span>
                                <span class="cov8" title="1">if expectedState == types.VolumeAttachmentStateAttached </span><span class="cov8" title="1">{
                                        // The disk doesn't exist, complain, give up waiting and report error
                                        klog.InfoS("Waiting for volume to be attached but the volume does not exist", "volumeID", volumeID)
                                        return false, err
                                }</span>
                        }

                        <span class="cov0" title="0">klog.InfoS("Ignoring error from describe volume, will retry", "volumeID", volumeID, "err", err)
                        return false, nil</span>
                }

                <span class="cov8" title="1">if volume.MultiAttachEnabled != nil &amp;&amp; !*volume.MultiAttachEnabled &amp;&amp; len(volume.Attachments) &gt; 1 </span><span class="cov8" title="1">{
                        klog.InfoS("Found multiple attachments for volume", "volumeID", volumeID, "volume", volume)
                        return false, fmt.Errorf("volume %q has multiple attachments", volumeID)
                }</span>

                <span class="cov8" title="1">var attachmentState types.VolumeAttachmentState

                for _, a := range volume.Attachments </span><span class="cov8" title="1">{
                        if a.InstanceId != nil </span><span class="cov8" title="1">{
                                if aws.ToString(a.InstanceId) == expectedInstance </span><span class="cov8" title="1">{
                                        attachmentState = a.State
                                        attachment = &amp;a
                                }</span>
                        }
                }

                <span class="cov8" title="1">if attachmentState == "" </span><span class="cov8" title="1">{
                        attachmentState = types.VolumeAttachmentStateDetached
                }</span>

                <span class="cov8" title="1">if attachment != nil &amp;&amp; attachment.Device != nil &amp;&amp; expectedState == types.VolumeAttachmentStateAttached </span><span class="cov8" title="1">{
                        device := aws.ToString(attachment.Device)
                        if device != expectedDevice </span><span class="cov8" title="1">{
                                klog.InfoS("WaitForAttachmentState: device mismatch", "device", device, "expectedDevice", expectedDevice, "attachment", attachment)
                                return false, nil
                        }</span>
                }

                // if we expected volume to be attached and it was reported as already attached via DescribeInstance call
                // but DescribeVolume told us volume is detached, we will short-circuit this long wait loop and return error
                // so as AttachDisk can be retried without waiting for 20 minutes.
                <span class="cov8" title="1">if (expectedState == types.VolumeAttachmentStateAttached) &amp;&amp; alreadyAssigned &amp;&amp; (attachmentState == types.VolumeAttachmentStateDetached) </span><span class="cov8" title="1">{
                        request := &amp;ec2.AttachVolumeInput{
                                Device:     aws.String(expectedDevice),
                                InstanceId: aws.String(expectedInstance),
                                VolumeId:   aws.String(volumeID),
                        }
                        _, err := c.ec2.AttachVolume(ctx, request)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, fmt.Errorf("WaitForAttachmentState AttachVolume error, expected device to be attached but was %s, volumeID=%q, instanceID=%q, Device=%q, err=%w", attachmentState, volumeID, expectedInstance, expectedDevice, err)
                        }</span>
                        <span class="cov8" title="1">return false, fmt.Errorf("attachment of disk %q failed, expected device to be attached but was %s", volumeID, attachmentState)</span>
                }

                // Attachment is in requested state, finish waiting
                <span class="cov8" title="1">if attachmentState == expectedState </span><span class="cov8" title="1">{
                        // But first, reset attachment to nil if expectedState equals volumeDetachedState.
                        // Caller will not expect an attachment to be returned for a detached volume if we're not also returning an error.
                        if expectedState == types.VolumeAttachmentStateDetached </span><span class="cov8" title="1">{
                                attachment = nil
                        }</span>
                        <span class="cov8" title="1">return true, nil</span>
                }
                // continue waiting
                <span class="cov8" title="1">klog.InfoS("Waiting for volume state", "volumeID", volumeID, "actual", attachmentState, "desired", expectedState)

                if expectedState == types.VolumeAttachmentStateDetached </span><span class="cov0" title="0">{
                        metrics.AsyncEC2Metrics().TrackDetachment(volumeID, expectedInstance, attachmentState)
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        }

        <span class="cov8" title="1">return attachment, wait.ExponentialBackoffWithContext(ctx, c.vwp.attachmentBackoff, verifyVolumeFunc)</span>
}

func (c *cloud) GetDiskByName(ctx context.Context, name string, capacityBytes int64) (*Disk, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeVolumesInput{
                Filters: []types.Filter{
                        {
                                Name:   aws.String("tag:" + VolumeNameTagKey),
                                Values: []string{name},
                        },
                },
        }

        volume, err := c.getVolume(ctx, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">volSizeBytes := util.GiBToBytes(*volume.Size)
        if volSizeBytes != capacityBytes </span><span class="cov0" title="0">{
                return nil, ErrDiskExistsDiffSize
        }</span>

        <span class="cov8" title="1">return &amp;Disk{
                VolumeID:         aws.ToString(volume.VolumeId),
                CapacityGiB:      *volume.Size,
                AvailabilityZone: aws.ToString(volume.AvailabilityZone),
                SnapshotID:       aws.ToString(volume.SnapshotId),
                OutpostArn:       aws.ToString(volume.OutpostArn),
        }, nil</span>
}

func (c *cloud) GetDiskByID(ctx context.Context, volumeID string) (*Disk, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeVolumesInput{
                VolumeIds: []string{volumeID},
        }

        volume, err := c.getVolume(ctx, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">disk := &amp;Disk{
                VolumeID:         aws.ToString(volume.VolumeId),
                AvailabilityZone: aws.ToString(volume.AvailabilityZone),
                OutpostArn:       aws.ToString(volume.OutpostArn),
                Attachments:      getVolumeAttachmentsList(*volume),
        }

        if volume.Size != nil </span><span class="cov0" title="0">{
                disk.CapacityGiB = *volume.Size
        }</span>

        <span class="cov8" title="1">return disk, nil</span>
}

// execBatchDescribeSnapshots executes a batched DescribeSnapshots API call depending on the type of batcher.
func execBatchDescribeSnapshots(svc EC2API, input []string, batcher snapshotBatcherType) (map[string]*types.Snapshot, error) <span class="cov8" title="1">{
        var request *ec2.DescribeSnapshotsInput

        switch batcher </span>{
        case snapshotIDBatcher:<span class="cov8" title="1">
                klog.V(7).InfoS("execBatchDescribeSnapshots", "snapshotIds", input)
                request = &amp;ec2.DescribeSnapshotsInput{
                        SnapshotIds: input,
                }</span>

        case snapshotTagBatcher:<span class="cov8" title="1">
                klog.V(7).InfoS("execBatchDescribeSnapshots", "names", input)
                filters := []types.Filter{
                        {
                                Name:   aws.String("tag:" + SnapshotNameTagKey),
                                Values: input,
                        },
                }
                request = &amp;ec2.DescribeSnapshotsInput{
                        Filters: filters,
                }</span>

        default:<span class="cov0" title="0">
                return nil, errors.New("execBatchDescribeSnapshots: unsupported request type")</span>
        }

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), batchDescribeTimeout)
        defer cancel()

        resp, err := describeSnapshots(ctx, svc, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make(map[string]*types.Snapshot)

        for _, snapshot := range resp </span><span class="cov8" title="1">{
                key, err := extractSnapshotKey(&amp;snapshot, batcher)
                if err != nil </span><span class="cov8" title="1">{
                        klog.Warningf("execBatchDescribeSnapshots: skipping snapshot: %v, reason: %v", snapshot, err)
                        continue</span>
                }
                <span class="cov8" title="1">result[key] = &amp;snapshot</span>
        }

        <span class="cov8" title="1">klog.V(7).InfoS("execBatchDescribeSnapshots: success", "result", result)
        return result, nil</span>
}

// batchDescribeSnapshots processes a DescribeSnapshots request. Depending on the request,
// it determines the appropriate batcher to use, queues the task, and waits for the result.
func (c *cloud) batchDescribeSnapshots(request *ec2.DescribeSnapshotsInput) (*types.Snapshot, error) <span class="cov8" title="1">{
        var b *batcher.Batcher[string, *types.Snapshot]
        var task string

        switch </span>{
        case len(request.SnapshotIds) == 1 &amp;&amp; request.SnapshotIds[0] != "":<span class="cov8" title="1">
                b = c.bm.snapshotIDBatcher
                task = request.SnapshotIds[0]</span>

        case len(request.Filters) == 1 &amp;&amp; *request.Filters[0].Name == "tag:"+SnapshotNameTagKey &amp;&amp; len(request.Filters[0].Values) == 1:<span class="cov8" title="1">
                b = c.bm.snapshotTagBatcher
                task = request.Filters[0].Values[0]</span>

        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("%w: batchDescribeSnapshots: request: %v", ErrInvalidRequest, request)</span>
        }

        <span class="cov8" title="1">ch := make(chan batcher.BatchResult[*types.Snapshot])

        b.AddTask(task, ch)

        r := &lt;-ch

        if r.Err != nil </span><span class="cov8" title="1">{
                return nil, r.Err
        }</span>
        <span class="cov8" title="1">if r.Result == nil </span><span class="cov8" title="1">{
                return nil, ErrNotFound
        }</span>
        <span class="cov8" title="1">return r.Result, nil</span>
}

// extractSnapshotKey retrieves the key associated with a given snapshot based on the batcher type.
// For the snapshotIDBatcher type, it returns the snapshot's ID.
// For other types, it searches for the SnapshotNameTagKey within the snapshot's tags.
func extractSnapshotKey(s *types.Snapshot, batcher snapshotBatcherType) (string, error) <span class="cov8" title="1">{
        if batcher == snapshotIDBatcher </span><span class="cov8" title="1">{
                if s.SnapshotId == nil </span><span class="cov8" title="1">{
                        return "", errors.New("extractSnapshotKey: missing snapshot ID")
                }</span>
                <span class="cov8" title="1">return *s.SnapshotId, nil</span>
        }
        <span class="cov8" title="1">for _, tag := range s.Tags </span><span class="cov8" title="1">{
                klog.V(7).InfoS("extractSnapshotKey: processing tag", "snapshot", s, "*tag.Key", *tag.Key, "SnapshotNameTagKey", SnapshotNameTagKey)
                if tag.Key == nil || tag.Value == nil </span><span class="cov0" title="0">{
                        klog.V(7).InfoS("extractSnapshotKey: skipping snapshot due to missing tag", "snapshot", s, "tag", tag)
                        continue</span>
                }
                <span class="cov8" title="1">if *tag.Key == SnapshotNameTagKey </span><span class="cov8" title="1">{
                        klog.V(7).InfoS("extractSnapshotKey: found snapshot name tag", "snapshot", s, "tag", tag)
                        return *tag.Value, nil
                }</span>
        }
        <span class="cov8" title="1">return "", errors.New("extractSnapshotKey: missing SnapshotNameTagKey in snapshot tags")</span>
}

func (c *cloud) CreateSnapshot(ctx context.Context, volumeID string, snapshotOptions *SnapshotOptions) (snapshot *Snapshot, err error) <span class="cov8" title="1">{
        descriptions := "Created by AWS EBS CSI driver for volume " + volumeID

        var request *ec2.CreateSnapshotInput

        tags := make([]types.Tag, 0, len(snapshotOptions.Tags))
        for key, value := range snapshotOptions.Tags </span><span class="cov8" title="1">{
                tags = append(tags, types.Tag{Key: aws.String(key), Value: aws.String(value)})
        }</span>
        <span class="cov8" title="1">tagSpec := types.TagSpecification{
                ResourceType: types.ResourceTypeSnapshot,
                Tags:         tags,
        }
        request = &amp;ec2.CreateSnapshotInput{
                VolumeId:          aws.String(volumeID),
                TagSpecifications: []types.TagSpecification{tagSpec},
                Description:       aws.String(descriptions),
        }
        if snapshotOptions.OutpostArn != "" </span><span class="cov8" title="1">{
                request.OutpostArn = aws.String(snapshotOptions.OutpostArn)
        }</span>
        <span class="cov8" title="1">res, err := c.ec2.CreateSnapshot(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.createSnapshotRetryer
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if isAwsErrorSnapshotLimitExceeded(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: %w", ErrLimitExceeded, err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error creating snapshot of volume %s: %w", volumeID, err)</span>
        }
        <span class="cov8" title="1">if res == nil </span><span class="cov0" title="0">{
                return nil, errors.New("nil CreateSnapshotResponse")
        }</span>

        <span class="cov8" title="1">return &amp;Snapshot{
                SnapshotID:     aws.ToString(res.SnapshotId),
                SourceVolumeID: aws.ToString(res.VolumeId),
                Size:           *res.VolumeSize,
                CreationTime:   aws.ToTime(res.StartTime),
                ReadyToUse:     res.State == types.SnapshotStateCompleted,
        }, nil</span>
}

func (c *cloud) DeleteSnapshot(ctx context.Context, snapshotID string) (success bool, err error) <span class="cov8" title="1">{
        request := &amp;ec2.DeleteSnapshotInput{}
        request.SnapshotId = aws.String(snapshotID)
        request.DryRun = aws.Bool(false)
        if _, err := c.ec2.DeleteSnapshot(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.deleteSnapshotRetryer
        }</span>); err != nil <span class="cov8" title="1">{
                if isAWSErrorSnapshotNotFound(err) </span><span class="cov8" title="1">{
                        return false, ErrNotFound
                }</span>
                <span class="cov8" title="1">return false, fmt.Errorf("DeleteSnapshot could not delete snapshot: %w", err)</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

func (c *cloud) GetSnapshotByName(ctx context.Context, name string) (snapshot *Snapshot, err error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeSnapshotsInput{
                Filters: []types.Filter{
                        {
                                Name:   aws.String("tag:" + SnapshotNameTagKey),
                                Values: []string{name},
                        },
                },
        }

        ec2snapshot, err := c.getSnapshot(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c.ec2SnapshotResponseToStruct(*ec2snapshot), nil</span>
}

func (c *cloud) GetSnapshotByID(ctx context.Context, snapshotID string) (snapshot *Snapshot, err error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeSnapshotsInput{
                SnapshotIds: []string{snapshotID},
        }

        ec2snapshot, err := c.getSnapshot(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c.ec2SnapshotResponseToStruct(*ec2snapshot), nil</span>
}

// ListSnapshots retrieves AWS EBS snapshots for an optionally specified volume ID.  If maxResults is set, it will return up to maxResults snapshots.  If there are more snapshots than maxResults,
// a next token value will be returned to the client as well.  They can use this token with subsequent calls to retrieve the next page of results.  If maxResults is not set (0),
// there will be no restriction up to 1000 results (https://docs.aws.amazon.com/sdk-for-go/api/service/ec2/#DescribeSnapshotsInput).
func (c *cloud) ListSnapshots(ctx context.Context, volumeID string, maxResults int32, nextToken string) (listSnapshotsResponse *ListSnapshotsResponse, err error) <span class="cov8" title="1">{
        if maxResults &gt; 0 &amp;&amp; maxResults &lt; 5 </span><span class="cov0" title="0">{
                return nil, ErrInvalidMaxResults
        }</span>

        <span class="cov8" title="1">describeSnapshotsInput := &amp;ec2.DescribeSnapshotsInput{
                MaxResults: aws.Int32(maxResults),
        }

        if len(nextToken) != 0 </span><span class="cov8" title="1">{
                describeSnapshotsInput.NextToken = aws.String(nextToken)
        }</span>
        <span class="cov8" title="1">if len(volumeID) != 0 </span><span class="cov8" title="1">{
                describeSnapshotsInput.Filters = []types.Filter{
                        {
                                Name:   aws.String("volume-id"),
                                Values: []string{volumeID},
                        },
                }
        }</span>

        <span class="cov8" title="1">ec2SnapshotsResponse, err := c.listSnapshots(ctx, describeSnapshotsInput)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">snapshots := make([]*Snapshot, 0, len(ec2SnapshotsResponse.Snapshots))
        for _, ec2Snapshot := range ec2SnapshotsResponse.Snapshots </span><span class="cov8" title="1">{
                snapshots = append(snapshots, c.ec2SnapshotResponseToStruct(ec2Snapshot))
        }</span>

        <span class="cov8" title="1">if len(snapshots) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNotFound
        }</span>

        <span class="cov8" title="1">return &amp;ListSnapshotsResponse{
                Snapshots: snapshots,
                NextToken: aws.ToString(ec2SnapshotsResponse.NextToken),
        }, nil</span>
}

// Helper method converting EC2 snapshot type to the internal struct.
func (c *cloud) ec2SnapshotResponseToStruct(ec2Snapshot types.Snapshot) *Snapshot <span class="cov8" title="1">{
        snapshotSize := *ec2Snapshot.VolumeSize
        snapshot := &amp;Snapshot{
                SnapshotID:     aws.ToString(ec2Snapshot.SnapshotId),
                SourceVolumeID: aws.ToString(ec2Snapshot.VolumeId),
                Size:           snapshotSize,
                CreationTime:   *ec2Snapshot.StartTime,
        }
        if ec2Snapshot.State == types.SnapshotStateCompleted </span><span class="cov8" title="1">{
                snapshot.ReadyToUse = true
        }</span> else<span class="cov0" title="0"> {
                snapshot.ReadyToUse = false
        }</span>

        <span class="cov8" title="1">return snapshot</span>
}

func (c *cloud) EnableFastSnapshotRestores(ctx context.Context, availabilityZones []string, snapshotID string) (*ec2.EnableFastSnapshotRestoresOutput, error) <span class="cov8" title="1">{
        request := &amp;ec2.EnableFastSnapshotRestoresInput{
                AvailabilityZones: availabilityZones,
                SourceSnapshotIds: []string{snapshotID},
        }
        klog.V(4).InfoS("Creating Fast Snapshot Restores", "snapshotID", snapshotID, "availabilityZones", availabilityZones)
        response, err := c.ec2.EnableFastSnapshotRestores(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                o.Retryer = c.rm.enableFastSnapshotRestoresRetryer
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(response.Unsuccessful) &gt; 0 </span><span class="cov0" title="0">{
                var errDetails []string
                for _, r := range response.Unsuccessful </span><span class="cov0" title="0">{
                        for _, e := range r.FastSnapshotRestoreStateErrors </span><span class="cov0" title="0">{
                                errDetails = append(errDetails, fmt.Sprintf("Error Code: %s, Error Message: %s", aws.ToString(e.Error.Code), aws.ToString(e.Error.Message)))
                        }</span>
                }
                <span class="cov0" title="0">return nil, errors.New(strings.Join(errDetails, "; "))</span>
        }
        <span class="cov8" title="1">return response, nil</span>
}

func describeVolumes(ctx context.Context, svc EC2API, request *ec2.DescribeVolumesInput) ([]types.Volume, error) <span class="cov8" title="1">{
        var volumes []types.Volume
        var nextToken *string
        for </span><span class="cov8" title="1">{
                response, err := svc.DescribeVolumes(ctx, request)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">volumes = append(volumes, response.Volumes...)
                nextToken = response.NextToken
                if aws.ToString(nextToken) == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">request.NextToken = nextToken</span>
        }
        <span class="cov8" title="1">return volumes, nil</span>
}

func (c *cloud) getVolume(ctx context.Context, request *ec2.DescribeVolumesInput) (*types.Volume, error) <span class="cov8" title="1">{
        if c.bm == nil </span><span class="cov8" title="1">{
                volumes, err := describeVolumes(ctx, c.ec2, request)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if l := len(volumes); l &gt; 1 </span><span class="cov0" title="0">{
                        return nil, ErrMultiDisks
                }</span> else<span class="cov8" title="1"> if l &lt; 1 </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov8" title="1">return &amp;volumes[0], nil</span>
        } else<span class="cov0" title="0"> {
                return c.batchDescribeVolumes(request)
        }</span>
}

func describeInstances(ctx context.Context, svc EC2API, request *ec2.DescribeInstancesInput) ([]types.Instance, error) <span class="cov8" title="1">{
        instances := []types.Instance{}
        var nextToken *string
        for </span><span class="cov8" title="1">{
                response, err := svc.DescribeInstances(ctx, request)
                if err != nil </span><span class="cov8" title="1">{
                        if isAWSErrorInstanceNotFound(err) </span><span class="cov0" title="0">{
                                return nil, ErrNotFound
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("error listing AWS instances: %w", err)</span>
                }

                <span class="cov8" title="1">for _, reservation := range response.Reservations </span><span class="cov8" title="1">{
                        instances = append(instances, reservation.Instances...)
                }</span>

                <span class="cov8" title="1">nextToken = response.NextToken
                if aws.ToString(nextToken) == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">request.NextToken = nextToken</span>
        }
        <span class="cov8" title="1">return instances, nil</span>
}

// GetInstance returns the instance info associated with a single node ID.
func (c *cloud) GetInstance(ctx context.Context, nodeID string) (*types.Instance, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeInstancesInput{
                InstanceIds: []string{nodeID},
        }

        if c.bm == nil </span><span class="cov8" title="1">{
                instances, err := describeInstances(ctx, c.ec2, request)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if l := len(instances); l &gt; 1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("found %d instances with ID %q", l, nodeID)
                }</span> else<span class="cov8" title="1"> if l &lt; 1 </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>

                <span class="cov8" title="1">return &amp;instances[0], nil</span>
        } else<span class="cov0" title="0"> {
                return c.batchDescribeInstances(request)
        }</span>
}

// GetInstances returns the instance info associated with each node ID in `nodeIDs`.
func (c *cloud) GetInstances(ctx context.Context, nodeIDs []string) ([]*types.Instance, error) <span class="cov0" title="0">{
        request := &amp;ec2.DescribeInstancesInput{
                InstanceIds: nodeIDs,
        }

        instances := []*types.Instance{}
        // A batcher isn't used here because GetInstances is only called once in awhile to update
        // metadata labels of each node.
        response, err := c.ec2.DescribeInstances(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                if isAWSErrorInstanceNotFound(err) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error listing AWS instances: %w", err)</span>
        }

        <span class="cov0" title="0">for _, reservation := range response.Reservations </span><span class="cov0" title="0">{
                for _, instance := range reservation.Instances </span><span class="cov0" title="0">{
                        instances = append(instances, &amp;instance)
                }</span>
        }
        <span class="cov0" title="0">return instances, nil</span>
}

func describeSnapshots(ctx context.Context, svc EC2API, request *ec2.DescribeSnapshotsInput) ([]types.Snapshot, error) <span class="cov8" title="1">{
        var snapshots []types.Snapshot
        var nextToken *string
        for </span><span class="cov8" title="1">{
                response, err := svc.DescribeSnapshots(ctx, request)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">snapshots = append(snapshots, response.Snapshots...)
                nextToken = response.NextToken
                if aws.ToString(nextToken) == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">request.NextToken = nextToken</span>
        }

        <span class="cov8" title="1">return snapshots, nil</span>
}

func (c *cloud) getSnapshot(ctx context.Context, request *ec2.DescribeSnapshotsInput) (*types.Snapshot, error) <span class="cov8" title="1">{
        if c.bm == nil </span><span class="cov8" title="1">{
                snapshots, err := describeSnapshots(ctx, c.ec2, request)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if l := len(snapshots); l &gt; 1 </span><span class="cov0" title="0">{
                        return nil, ErrMultiSnapshots
                }</span> else<span class="cov8" title="1"> if l &lt; 1 </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov8" title="1">return &amp;snapshots[0], nil</span>
        } else<span class="cov0" title="0"> {
                return c.batchDescribeSnapshots(request)
        }</span>
}

// listSnapshots returns all snapshots based from a request.
func (c *cloud) listSnapshots(ctx context.Context, request *ec2.DescribeSnapshotsInput) (*ec2ListSnapshotsResponse, error) <span class="cov8" title="1">{
        var snapshots []types.Snapshot
        var nextToken *string

        response, err := c.ec2.DescribeSnapshots(ctx, request)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">snapshots = append(snapshots, response.Snapshots...)

        if response.NextToken != nil </span><span class="cov8" title="1">{
                nextToken = response.NextToken
        }</span>

        <span class="cov8" title="1">return &amp;ec2ListSnapshotsResponse{
                Snapshots: snapshots,
                NextToken: nextToken,
        }, nil</span>
}

// waitForVolume waits for volume to be in the "available" state.
func (c *cloud) waitForVolume(ctx context.Context, volumeID string) error <span class="cov8" title="1">{
        time.Sleep(c.vwp.creationInitialDelay)

        request := &amp;ec2.DescribeVolumesInput{
                VolumeIds: []string{volumeID},
        }

        err := wait.ExponentialBackoffWithContext(ctx, c.vwp.creationBackoff, func(ctx context.Context) (done bool, err error) </span><span class="cov8" title="1">{
                vol, err := c.getVolume(ctx, request)
                if err != nil </span><span class="cov8" title="1">{
                        return true, err
                }</span>
                <span class="cov8" title="1">if vol.State != "" </span><span class="cov8" title="1">{
                        return vol.State == types.VolumeStateAvailable, nil
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        })

        <span class="cov8" title="1">return err</span>
}

// isAWSError returns a boolean indicating whether the error is AWS-related
// and has the given code. More information on AWS error codes at:
// https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html
func isAWSError(err error, code string) bool <span class="cov8" title="1">{
        var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="1">{
                if apiErr.ErrorCode() == code </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isAWSErrorInstanceNotFound returns a boolean indicating whether the
// given error is an AWS InvalidInstanceID.NotFound error. This error is
// reported when the specified instance doesn't exist.
func isAWSErrorInstanceNotFound(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "InvalidInstanceID.NotFound")
}</span>

// isAWSErrorVolumeNotFound returns a boolean indicating whether the
// given error is an AWS InvalidVolume.NotFound error. This error is
// reported when the specified volume doesn't exist.
func isAWSErrorVolumeNotFound(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "InvalidVolume.NotFound")
}</span>

// isAWSErrorIncorrectState returns a boolean indicating whether the
// given error is an AWS IncorrectState error. This error is
// reported when the resource is not in a correct state for the request.
func isAWSErrorIncorrectState(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "IncorrectState")
}</span>

// isAWSErrorInvalidAttachmentNotFound returns a boolean indicating whether the
// given error is an AWS InvalidAttachment.NotFound error. This error is reported
// when attempting to detach a volume from an instance to which it is not attached.
func isAWSErrorInvalidAttachmentNotFound(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "InvalidAttachment.NotFound")
}</span>

// isAWSErrorModificationNotFound returns a boolean indicating whether the given
// error is an AWS InvalidVolumeModification.NotFound error.
func isAWSErrorModificationNotFound(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "InvalidVolumeModification.NotFound")
}</span>

// isAWSErrorSnapshotNotFound returns a boolean indicating whether the
// given error is an AWS InvalidSnapshot.NotFound error. This error is
// reported when the specified snapshot doesn't exist.
func isAWSErrorSnapshotNotFound(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "InvalidSnapshot.NotFound")
}</span>

// isAWSErrorIdempotentParameterMismatch returns a boolean indicating whether the
// given error is an AWS IdempotentParameterMismatch error.
// This error is reported when the two request contains same client-token but different parameters.
func isAWSErrorIdempotentParameterMismatch(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "IdempotentParameterMismatch")
}</span>

// isAWSErrorBlockDeviceInUse returns a boolean indicating whether the
// given error appears to be a block device name already in use error.
func isAWSErrorBlockDeviceInUse(err error) bool <span class="cov8" title="1">{
        var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="1">{
                if apiErr.ErrorCode() == "InvalidParameterValue" &amp;&amp; strings.Contains(apiErr.ErrorMessage(), "already in use") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isAWSErrorAttachmentLimitExceeded checks if the error is an AttachmentLimitExceeded error.
// This error is reported when the maximum number of attachments for an instance is exceeded.
func isAWSErrorAttachmentLimitExceeded(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "AttachmentLimitExceeded")
}</span>

// isAWSErrorModificationSizeLimitExceeded checks if the error is a VolumeModificationSizeLimitExceeded error.
// This error is reported when the limit on a volume modification storage in a region is exceeded.
func isAWSErrorVolumeModificationSizeLimitExceeded(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "VolumeModificationSizeLimitExceeded")
}</span>

// isAWSErrorVolumeLimitExceeded checks if the error is a VolumeLimitExceeded error.
// This error is reported when the limit on the amount of volume storage is exceeded.
func isAWSErrorVolumeLimitExceeded(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "VolumeLimitExceeded")
}</span>

// isAwsErrorMaxIOPSLimitExceeded checks if the error is a MaxIOPSLimitExceeded error.
// This error is reported when the limit on the IOPS usage for a region is exceeded.
func isAwsErrorMaxIOPSLimitExceeded(err error) bool <span class="cov8" title="1">{
        return isAWSError(err, "MaxIOPSLimitExceeded")
}</span>

// isAwsErrorSnapshotLimitExceeded checks if the error is a SnapshotLimitExceeded error.
// This error is reported when the limit on the number of snapshots that can be created is exceeded.
func isAwsErrorSnapshotLimitExceeded(err error) bool <span class="cov0" title="0">{
        return isAWSError(err, "SnapshotLimitExceeded")
}</span>

// isAWSErrorInvalidParameter returns a boolean indicating whether the
// given error is caused by invalid parameters in a EC2 API request.
func isAWSErrorInvalidParameter(err error) bool <span class="cov8" title="1">{
        var apiError smithy.APIError
        if errors.As(err, &amp;apiError) </span><span class="cov0" title="0">{
                _, found := invalidParameterErrorCodes[apiError.ErrorCode()]
                return found
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Checks for desired size on volume by also verifying volume size by describing volume.
// This is to get around potential eventual consistency problems with describing volume modifications
// objects and ensuring that we read two different objects to verify volume state.
func (c *cloud) checkDesiredState(ctx context.Context, volumeID string, desiredSizeGiB int32, options *ModifyDiskOptions) (int32, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeVolumesInput{
                VolumeIds: []string{volumeID},
        }
        volume, err := c.getVolume(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // AWS resizes in chunks of GiB (not GB)
        <span class="cov8" title="1">realSizeGiB := *volume.Size

        // Check if there is a mismatch between the requested modification and the current volume
        // If there is, the volume is still modifying and we should not return a success
        switch </span>{
        case realSizeGiB &lt; desiredSizeGiB:<span class="cov8" title="1">
                return realSizeGiB, fmt.Errorf("volume %q is still being expanded to %d size", volumeID, desiredSizeGiB)</span>
        case options.IOPS != 0 &amp;&amp; (volume.Iops == nil || *volume.Iops != options.IOPS):<span class="cov8" title="1">
                return realSizeGiB, fmt.Errorf("volume %q is still being modified to iops %d", volumeID, options.IOPS)</span>
        case options.VolumeType != "" &amp;&amp; !strings.EqualFold(string(volume.VolumeType), options.VolumeType):<span class="cov8" title="1">
                return realSizeGiB, fmt.Errorf("volume %q is still being modified to type %q", volumeID, options.VolumeType)</span>
        case options.Throughput != 0 &amp;&amp; (volume.Throughput == nil || *volume.Throughput != options.Throughput):<span class="cov8" title="1">
                return realSizeGiB, fmt.Errorf("volume %q is still being modified to throughput %d", volumeID, options.Throughput)</span>
        }

        <span class="cov8" title="1">return realSizeGiB, nil</span>
}

// waitForVolumeModification waits for a volume modification to finish.
func (c *cloud) waitForVolumeModification(ctx context.Context, volumeID string) error <span class="cov8" title="1">{
        waitErr := wait.ExponentialBackoff(c.vwp.modificationBackoff, func() (bool, error) </span><span class="cov8" title="1">{
                m, err := c.getLatestVolumeModification(ctx, volumeID, true)
                // Consider volumes that have never been modified as done
                if err != nil &amp;&amp; errors.Is(err, ErrVolumeNotBeingModified) </span><span class="cov8" title="1">{
                        return true, nil
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">state := string(m.ModificationState)
                if volumeModificationDone(state) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>

                <span class="cov8" title="1">return false, nil</span>
        })

        <span class="cov8" title="1">if waitErr != nil </span><span class="cov8" title="1">{
                return waitErr
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func describeVolumesModifications(ctx context.Context, svc EC2API, request *ec2.DescribeVolumesModificationsInput) ([]types.VolumeModification, error) <span class="cov8" title="1">{
        volumeModifications := []types.VolumeModification{}
        var nextToken *string
        for </span><span class="cov8" title="1">{
                response, err := svc.DescribeVolumesModifications(ctx, request)
                if err != nil </span><span class="cov8" title="1">{
                        if isAWSErrorModificationNotFound(err) </span><span class="cov0" title="0">{
                                return nil, ErrVolumeNotBeingModified
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("error describing volume modifications: %w", err)</span>
                }

                <span class="cov8" title="1">volumeModifications = append(volumeModifications, response.VolumesModifications...)

                nextToken = response.NextToken
                if aws.ToString(nextToken) == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">request.NextToken = nextToken</span>
        }
        <span class="cov8" title="1">return volumeModifications, nil</span>
}

// getLatestVolumeModification returns the last modification of the volume.
func (c *cloud) getLatestVolumeModification(ctx context.Context, volumeID string, isBatchable bool) (*types.VolumeModification, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeVolumesModificationsInput{
                VolumeIds: []string{volumeID},
        }

        if c.bm == nil || !isBatchable </span><span class="cov8" title="1">{
                mod, err := c.ec2.DescribeVolumesModifications(ctx, request, func(o *ec2.Options) </span><span class="cov0" title="0">{
                        o.Retryer = c.rm.unbatchableDescribeVolumesModificationsRetryer
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        if isAWSErrorModificationNotFound(err) </span><span class="cov0" title="0">{
                                return nil, ErrVolumeNotBeingModified
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("error describing modifications in volume %q: %w", volumeID, err)</span>
                }

                <span class="cov8" title="1">volumeMods := mod.VolumesModifications
                if len(volumeMods) == 0 </span><span class="cov8" title="1">{
                        return nil, ErrVolumeNotBeingModified
                }</span>

                <span class="cov8" title="1">return &amp;volumeMods[len(volumeMods)-1], nil</span>
        } else<span class="cov0" title="0"> {
                return c.batchDescribeVolumesModifications(request)
        }</span>
}

// randomAvailabilityZone returns a random zone from the given region
// the randomness relies on the response of DescribeAvailabilityZones.
func (c *cloud) randomAvailabilityZone(ctx context.Context) (string, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeAvailabilityZonesInput{}
        response, err := c.ec2.DescribeAvailabilityZones(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">zones := []string{}
        for _, zone := range response.AvailabilityZones </span><span class="cov8" title="1">{
                zones = append(zones, *zone.ZoneName)
        }</span>

        <span class="cov8" title="1">return zones[0], nil</span>
}

// AvailabilityZones returns availability zones from the given region.
func (c *cloud) AvailabilityZones(ctx context.Context) (map[string]struct{}, error) <span class="cov8" title="1">{
        response, err := c.ec2.DescribeAvailabilityZones(ctx, &amp;ec2.DescribeAvailabilityZonesInput{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error describing availability zones: %w", err)
        }</span>
        <span class="cov8" title="1">zones := make(map[string]struct{})
        for _, zone := range response.AvailabilityZones </span><span class="cov8" title="1">{
                zones[*zone.ZoneName] = struct{}{}
        }</span>
        <span class="cov8" title="1">return zones, nil</span>
}

func needsVolumeModification(volume types.Volume, newSizeGiB int32, options *ModifyDiskOptions) bool <span class="cov8" title="1">{
        oldSizeGiB := *volume.Size
        //nolint:staticcheck // staticcheck suggests merging all of the below conditionals into one line,
        // but that would be extremely difficult to read
        needsModification := false

        if oldSizeGiB &lt; newSizeGiB </span><span class="cov8" title="1">{
                needsModification = true
        }</span>

        <span class="cov8" title="1">if options.IOPS != 0 &amp;&amp; (volume.Iops == nil || *volume.Iops != options.IOPS) </span><span class="cov8" title="1">{
                needsModification = true
        }</span>

        <span class="cov8" title="1">if options.VolumeType != "" &amp;&amp; !strings.EqualFold(string(volume.VolumeType), options.VolumeType) </span><span class="cov8" title="1">{
                needsModification = true
        }</span>

        <span class="cov8" title="1">if options.Throughput != 0 &amp;&amp; (volume.Throughput == nil || *volume.Throughput != options.Throughput) </span><span class="cov8" title="1">{
                needsModification = true
        }</span>

        <span class="cov8" title="1">return needsModification</span>
}

func (c *cloud) validateModifyVolume(ctx context.Context, volumeID string, newSizeGiB int32, options *ModifyDiskOptions) (bool, int32, error) <span class="cov8" title="1">{
        request := &amp;ec2.DescribeVolumesInput{
                VolumeIds: []string{volumeID},
        }

        volume, err := c.getVolume(ctx, request)
        if err != nil </span><span class="cov8" title="1">{
                return true, 0, err
        }</span>

        <span class="cov8" title="1">if volume.Size == nil </span><span class="cov8" title="1">{
                return true, 0, fmt.Errorf("volume %q has no size", volumeID)
        }</span>
        <span class="cov8" title="1">oldSizeGiB := *volume.Size

        // This call must NOT be batched because a missing volume modification will return client error
        latestMod, err := c.getLatestVolumeModification(ctx, volumeID, false)
        if err != nil &amp;&amp; !errors.Is(err, ErrVolumeNotBeingModified) </span><span class="cov0" title="0">{
                return true, oldSizeGiB, fmt.Errorf("error fetching volume modifications for %q: %w", volumeID, err)
        }</span>

        <span class="cov8" title="1">state := ""
        // latestMod can be nil if the volume has never been modified
        if latestMod != nil </span><span class="cov8" title="1">{
                state = string(latestMod.ModificationState)
                if state == string(types.VolumeModificationStateModifying) </span><span class="cov8" title="1">{
                        // If volume is already modifying, detour to waiting for it to modify
                        klog.V(5).InfoS("[Debug] Watching ongoing modification", "volumeID", volumeID)
                        err = c.waitForVolumeModification(ctx, volumeID)
                        if err != nil </span><span class="cov8" title="1">{
                                return true, oldSizeGiB, err
                        }</span>
                        <span class="cov0" title="0">returnGiB, returnErr := c.checkDesiredState(ctx, volumeID, newSizeGiB, options)
                        return false, returnGiB, returnErr</span>
                }
        }

        // At this point, we know we are starting a new volume modification
        // If we're asked to modify a volume to its current state, ignore the request and immediately return a success
        // This is because as of March 2024, EC2 ModifyVolume calls that don't change any parameters still modify the volume
        <span class="cov8" title="1">if !needsVolumeModification(*volume, newSizeGiB, options) </span><span class="cov8" title="1">{
                klog.V(5).InfoS("[Debug] Skipping modification for volume due to matching stats", "volumeID", volumeID)
                // Wait for any existing modifications to prevent race conditions where DescribeVolume(s) returns the new
                // state before the volume is actually finished modifying
                err = c.waitForVolumeModification(ctx, volumeID)
                if err != nil </span><span class="cov0" title="0">{
                        return true, oldSizeGiB, err
                }</span>
                <span class="cov8" title="1">returnGiB, returnErr := c.checkDesiredState(ctx, volumeID, newSizeGiB, options)
                return false, returnGiB, returnErr</span>
        }

        <span class="cov8" title="1">if state == string(types.VolumeModificationStateOptimizing) </span><span class="cov0" title="0">{
                return true, 0, fmt.Errorf("volume %q in OPTIMIZING state, cannot currently modify", volumeID)
        }</span>

        <span class="cov8" title="1">return true, 0, nil</span>
}

func volumeModificationDone(state string) bool <span class="cov8" title="1">{
        return state == string(types.VolumeModificationStateCompleted) || state == string(types.VolumeModificationStateOptimizing)
}</span>

func getVolumeAttachmentsList(volume types.Volume) []string <span class="cov8" title="1">{
        var volumeAttachmentList []string
        for _, attachment := range volume.Attachments </span><span class="cov8" title="1">{
                if attachment.State == types.VolumeAttachmentStateAttached </span><span class="cov8" title="1">{
                        volumeAttachmentList = append(volumeAttachmentList, aws.ToString(attachment.InstanceId))
                }</span>
        }

        <span class="cov8" title="1">return volumeAttachmentList</span>
}

// Calculate actual IOPS for a volume and cap it at supported AWS limits.
func capIOPS(volumeType string, requestedCapacityGiB int32, requestedIops int32, minTotalIOPS, maxTotalIOPS, maxIOPSPerGB int32, allowIncrease bool) int32 <span class="cov8" title="1">{
        // If requestedIops is zero the user did not request a specific amount, and the default will be used instead
        if requestedIops == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">iops := requestedIops

        if iops &lt; minTotalIOPS </span><span class="cov8" title="1">{
                if allowIncrease </span><span class="cov8" title="1">{
                        iops = minTotalIOPS
                        klog.V(5).InfoS("[Debug] Increased IOPS to the min supported limit", "volumeType", volumeType, "requestedCapacityGiB", requestedCapacityGiB, "limit", iops)
                }</span>
        }
        <span class="cov8" title="1">if iops &gt; maxTotalIOPS </span><span class="cov8" title="1">{
                iops = maxTotalIOPS
                klog.V(5).InfoS("[Debug] Capped IOPS, volume at the max supported limit", "volumeType", volumeType, "requestedCapacityGiB", requestedCapacityGiB, "limit", iops)
        }</span>
        <span class="cov8" title="1">maxIopsByCapacity := maxIOPSPerGB * requestedCapacityGiB
        if iops &gt; maxIopsByCapacity &amp;&amp; maxIopsByCapacity &gt;= minTotalIOPS </span><span class="cov8" title="1">{
                iops = maxIopsByCapacity
                klog.V(5).InfoS("[Debug] Capped IOPS for volume", "volumeType", volumeType, "requestedCapacityGiB", requestedCapacityGiB, "maxIOPSPerGB", maxIOPSPerGB, "limit", iops)
        }</span>
        <span class="cov8" title="1">return iops</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package devicemanager

import (
        "errors"
        "sync"
)

// ExistingNames is a map of assigned device names. Presence of a key with a device
// name in the map means that the device is allocated. Value is irrelevant and
// can be used for anything that NameAllocator user wants.
type ExistingNames map[string]string

// On AWS, we should assign new (not yet used) device names to attached volumes.
// If we reuse a previously used name, we may get the volume "attaching" forever,
// see https://aws.amazon.com/premiumsupport/knowledge-center/ebs-stuck-attaching/.
// NameAllocator finds available device name, taking into account already
// assigned device names from ExistingNames map. It tries to find the next
// device name to the previously assigned one (from previous NameAllocator
// call), so all available device names are used eventually and it minimizes
// device name reuse.
type NameAllocator interface {
        GetNext(existingNames ExistingNames, likelyBadNames *sync.Map) (name string, err error)
}

type nameAllocator struct{}

var _ NameAllocator = &amp;nameAllocator{}

// GetNext returns a free device name or error when there is no free device name
// It does this by using a list of legal EBS device names from device_names.go
//
// likelyBadNames is a map of names that have previously returned an "in use" error when attempting to mount to them
// These names are unlikely to result in a successful mount, and may be permanently unavailable, so use them last.
func (d *nameAllocator) GetNext(existingNames ExistingNames, likelyBadNames *sync.Map) (string, error) <span class="cov8" title="1">{
        for _, name := range deviceNames </span><span class="cov8" title="1">{
                _, existing := existingNames[name]
                _, likelyBad := likelyBadNames.Load(name)
                if !existing &amp;&amp; !likelyBad </span><span class="cov8" title="1">{
                        return name, nil
                }</span>
        }

        <span class="cov8" title="1">finalResortName := ""
        likelyBadNames.Range(func(name, _ interface{}) bool </span><span class="cov8" title="1">{
                if name, ok := name.(string); ok </span><span class="cov8" title="1">{
                        if _, existing := existingNames[name]; !existing </span><span class="cov8" title="1">{
                                finalResortName = name
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        })
        <span class="cov8" title="1">if finalResortName != "" </span><span class="cov8" title="1">{
                return finalResortName, nil
        }</span>

        <span class="cov8" title="1">return "", errors.New("there are no names available")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package devicemanager

import (
        "errors"
        "fmt"
        "sync"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ec2/types"
        "k8s.io/klog/v2"
)

type Device struct {
        Instance          *types.Instance
        Path              string
        VolumeID          string
        IsAlreadyAssigned bool

        isTainted   bool
        releaseFunc func() error
}

func (d *Device) Release(force bool) <span class="cov8" title="1">{
        if !d.isTainted || force </span><span class="cov8" title="1">{
                if err := d.releaseFunc(); err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "Error releasing device")
                }</span>
        }
}

// Taint marks the device as no longer reusable.
func (d *Device) Taint() <span class="cov8" title="1">{
        d.isTainted = true
}</span>

type DeviceManager interface {
        // NewDevice retrieves the device if the device is already assigned.
        // Otherwise it creates a new device with next available device name
        // and mark it as unassigned device.
        NewDevice(instance *types.Instance, volumeID string, likelyBadNames *sync.Map) (device *Device, err error)

        // GetDevice returns the device already assigned to the volume.
        GetDevice(instance *types.Instance, volumeID string) (device *Device, err error)
}

type deviceManager struct {
        // nameAllocator assigns new device name
        nameAllocator NameAllocator

        // We keep an active list of devices we have assigned but not yet
        // attached, to avoid a race condition where we assign a device mapping
        // and then get a second request before we attach the volume.
        mux      sync.Mutex
        inFlight inFlightAttaching
}

var _ DeviceManager = &amp;deviceManager{}

// inFlightAttaching represents the device names being currently attached to nodes.
// A valid pseudo-representation of it would be {"nodeID": {"deviceName: "volumeID"}}.
type inFlightAttaching map[string]map[string]string

func (i inFlightAttaching) Add(nodeID, volumeID, name string) <span class="cov8" title="1">{
        attaching := i[nodeID]
        if attaching == nil </span><span class="cov8" title="1">{
                attaching = make(map[string]string)
                i[nodeID] = attaching
        }</span>
        <span class="cov8" title="1">attaching[name] = volumeID</span>
}

func (i inFlightAttaching) Del(nodeID, name string) <span class="cov8" title="1">{
        delete(i[nodeID], name)
}</span>

func (i inFlightAttaching) GetNames(nodeID string) map[string]string <span class="cov8" title="1">{
        return i[nodeID]
}</span>

func (i inFlightAttaching) GetVolume(nodeID, name string) string <span class="cov8" title="1">{
        return i[nodeID][name]
}</span>

func NewDeviceManager() DeviceManager <span class="cov8" title="1">{
        return &amp;deviceManager{
                nameAllocator: &amp;nameAllocator{},
                inFlight:      make(inFlightAttaching),
        }
}</span>

func (d *deviceManager) NewDevice(instance *types.Instance, volumeID string, likelyBadNames *sync.Map) (*Device, error) <span class="cov8" title="1">{
        d.mux.Lock()
        defer d.mux.Unlock()

        if instance == nil </span><span class="cov8" title="1">{
                return nil, errors.New("instance is nil")
        }</span>

        // Get device names being attached and already attached to this instance
        <span class="cov8" title="1">inUse := d.getDeviceNamesInUse(instance)

        // Check if this volume is already assigned a device on this machine
        if path := d.getPath(inUse, volumeID); path != "" </span><span class="cov8" title="1">{
                return d.newBlockDevice(instance, volumeID, path, true), nil
        }</span>

        <span class="cov8" title="1">nodeID, err := getInstanceID(instance)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">name, err := d.nameAllocator.GetNext(inUse, likelyBadNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get a free device name to assign to node %s", nodeID)
        }</span>

        // Add the chosen device and volume to the "attachments in progress" map
        <span class="cov8" title="1">d.inFlight.Add(nodeID, volumeID, name)

        return d.newBlockDevice(instance, volumeID, name, false), nil</span>
}

func (d *deviceManager) GetDevice(instance *types.Instance, volumeID string) (*Device, error) <span class="cov8" title="1">{
        d.mux.Lock()
        defer d.mux.Unlock()

        inUse := d.getDeviceNamesInUse(instance)

        if path := d.getPath(inUse, volumeID); path != "" </span><span class="cov8" title="1">{
                return d.newBlockDevice(instance, volumeID, path, true), nil
        }</span>

        <span class="cov8" title="1">return d.newBlockDevice(instance, volumeID, "", false), nil</span>
}

func (d *deviceManager) newBlockDevice(instance *types.Instance, volumeID string, path string, isAlreadyAssigned bool) *Device <span class="cov8" title="1">{
        device := &amp;Device{
                Instance:          instance,
                Path:              path,
                VolumeID:          volumeID,
                IsAlreadyAssigned: isAlreadyAssigned,

                isTainted: false,
        }
        device.releaseFunc = func() error </span><span class="cov8" title="1">{
                return d.release(device)
        }</span>
        <span class="cov8" title="1">return device</span>
}

func (d *deviceManager) release(device *Device) error <span class="cov8" title="1">{
        nodeID, err := getInstanceID(device.Instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">d.mux.Lock()
        defer d.mux.Unlock()

        existingVolumeID := d.inFlight.GetVolume(nodeID, device.Path)
        if len(existingVolumeID) == 0 </span><span class="cov0" title="0">{
                // Attaching is not in progress, so there's nothing to release
                return nil
        }</span>

        <span class="cov8" title="1">if device.VolumeID != existingVolumeID </span><span class="cov0" title="0">{
                // This actually can happen, because GetNext combines the inFlightAttaching map with the volumes
                // attached to the instance (as reported by the EC2 API).  So if release comes after
                // a 10 second poll delay, we might as well have had a concurrent request to allocate a mountpoint,
                // which because we allocate sequentially is very likely to get the immediately freed volume.
                return fmt.Errorf("release on device %q assigned to different volume: %q vs %q", device.Path, device.VolumeID, existingVolumeID)
        }</span>

        <span class="cov8" title="1">klog.V(5).InfoS("[Debug] Releasing in-process", "attachment entry", device.Path, "volume", device.VolumeID)
        d.inFlight.Del(nodeID, device.Path)

        return nil</span>
}

// getDeviceNamesInUse returns the device to volume ID mapping
// the mapping includes both already attached and being attached volumes.
func (d *deviceManager) getDeviceNamesInUse(instance *types.Instance) map[string]string <span class="cov8" title="1">{
        nodeID := aws.ToString(instance.InstanceId)
        inUse := map[string]string{}
        for _, blockDevice := range instance.BlockDeviceMappings </span><span class="cov8" title="1">{
                name := aws.ToString(blockDevice.DeviceName)
                inUse[name] = aws.ToString(blockDevice.Ebs.VolumeId)
        }</span>

        <span class="cov8" title="1">for name, volumeID := range d.inFlight.GetNames(nodeID) </span><span class="cov8" title="1">{
                inUse[name] = volumeID
        }</span>

        <span class="cov8" title="1">return inUse</span>
}

func (d *deviceManager) getPath(inUse map[string]string, volumeID string) string <span class="cov8" title="1">{
        for name, volID := range inUse </span><span class="cov8" title="1">{
                if volumeID == volID </span><span class="cov8" title="1">{
                        return name
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func getInstanceID(instance *types.Instance) (string, error) <span class="cov8" title="1">{
        if instance == nil </span><span class="cov0" title="0">{
                return "", errors.New("can't get ID from a nil instance")
        }</span>
        <span class="cov8" title="1">return aws.ToString(instance.InstanceId), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloud

import (
        "context"
        "errors"
        "time"

        awsmiddleware "github.com/aws/aws-sdk-go-v2/aws/middleware"
        "github.com/aws/aws-sdk-go-v2/aws/retry"
        "github.com/aws/smithy-go"
        "github.com/aws/smithy-go/middleware"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/metrics"
        "k8s.io/klog/v2"
)

// RecordRequestsHandler is added to the Complete chain; called after any request.
func RecordRequestsMiddleware(deprecatedMetrics bool) func(*middleware.Stack) error <span class="cov8" title="1">{
        return func(stack *middleware.Stack) error </span><span class="cov0" title="0">{
                return stack.Finalize.Add(middleware.FinalizeMiddlewareFunc("RecordRequestsMiddleware", func(ctx context.Context, input middleware.FinalizeInput, next middleware.FinalizeHandler) (output middleware.FinalizeOutput, metadata middleware.Metadata, err error) </span><span class="cov0" title="0">{
                        start := time.Now()
                        output, metadata, err = next.HandleFinalize(ctx, input)
                        labels := createLabels(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                var apiErr smithy.APIError
                                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                                        if _, isThrottleError := retry.DefaultThrottleErrorCodes[apiErr.ErrorCode()]; isThrottleError </span><span class="cov0" title="0">{
                                                operationName := awsmiddleware.GetOperationName(ctx)
                                                labels = map[string]string{
                                                        "operation_name": operationName,
                                                }
                                                metrics.Recorder().IncreaseCount(metrics.APIRequestThrottles, metrics.APIRequestThrottlesHelpText, labels)
                                                if deprecatedMetrics </span><span class="cov0" title="0">{
                                                        metrics.Recorder().IncreaseCount(metrics.DeprecatedAPIRequestThrottles, metrics.DeprecatedAPIRequestThrottlesHelpText, labels)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                labels["code"] = apiErr.ErrorCode()
                                                metrics.Recorder().IncreaseCount(metrics.APIRequestErrors, metrics.APIRequestErrorsHelpText, labels)
                                                if deprecatedMetrics </span><span class="cov0" title="0">{
                                                        metrics.Recorder().IncreaseCount(metrics.DeprecatedAPIRequestErrors, metrics.DeprecatedAPIRequestErrorsHelpText, labels)
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                duration := time.Since(start).Seconds()
                                metrics.Recorder().ObserveHistogram(metrics.APIRequestDuration, metrics.APIRequestDurationHelpText, duration, labels, nil)
                                if deprecatedMetrics </span><span class="cov0" title="0">{
                                        metrics.Recorder().ObserveHistogram(metrics.DeprecatedAPIRequestDuration, metrics.DeprecatedAPIRequestDurationHelpText, duration, labels, nil)
                                }</span>
                        }
                        <span class="cov0" title="0">return output, metadata, err</span>
                }), middleware.After)
        }
}

// LogServerErrorsMiddleware is a middleware that logs server errors received when attempting to contact the AWS API
// A specialized middleware is used instead of the SDK's built-in retry logging to allow for customizing the verbosity
// of throttle errors vs server/unknown errors, to prevent flooding the logs with throttle error.
func LogServerErrorsMiddleware() func(*middleware.Stack) error <span class="cov8" title="1">{
        return func(stack *middleware.Stack) error </span><span class="cov0" title="0">{
                return stack.Finalize.Add(middleware.FinalizeMiddlewareFunc("LogServerErrorsMiddleware", func(ctx context.Context, input middleware.FinalizeInput, next middleware.FinalizeHandler) (output middleware.FinalizeOutput, metadata middleware.Metadata, err error) </span><span class="cov0" title="0">{
                        output, metadata, err = next.HandleFinalize(ctx, input)
                        if err != nil </span><span class="cov0" title="0">{
                                var apiErr smithy.APIError
                                if errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                                        if _, isThrottleError := retry.DefaultThrottleErrorCodes[apiErr.ErrorCode()]; isThrottleError </span><span class="cov0" title="0">{
                                                // Only log throttle errors under a high verbosity as we expect to see many of them
                                                // under normal bursty/high-TPS workloads
                                                klog.V(4).ErrorS(apiErr, "Throttle error from AWS API")
                                        }</span> else<span class="cov0" title="0"> {
                                                klog.ErrorS(apiErr, "Error from AWS API")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        klog.ErrorS(err, "Unknown error attempting to contact AWS API")
                                }</span>
                        }
                        <span class="cov0" title="0">return output, metadata, err</span>
                }), middleware.After)
        }
}

func createLabels(ctx context.Context) map[string]string <span class="cov0" title="0">{
        operationName := awsmiddleware.GetOperationName(ctx)
        if operationName == "" </span><span class="cov0" title="0">{
                operationName = "Unknown"
        }</span>
        <span class="cov0" title="0">return map[string]string{
                "request": operationName,
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadata

import (
        "context"
        "errors"
        "fmt"
        "io"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws/arn"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/feature/ec2/imds"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util"
        "k8s.io/klog/v2"
)

const (
        // OutpostArnEndpoint is the IMDS endpoint to query to get the outpost arn.
        OutpostArnEndpoint string = "outpost-arn"

        // EnisEndpoint is the IMDS endpoint to query the number of attached ENIs.
        EnisEndpoint string = "network/interfaces/macs"

        // BlockDevicesEndpoint is the IMDS endpoint to query the number of attached block devices.
        BlockDevicesEndpoint string = "block-device-mapping"
)

type IMDSClient func() (IMDS, error)

var DefaultIMDSClient = func() (IMDS, error) <span class="cov8" title="1">{
        cfg, err := config.LoadDefaultConfig(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">svc := imds.NewFromConfig(cfg)
        return svc, nil</span>
}

func IMDSInstanceInfo(svc IMDS) (*Metadata, error) <span class="cov8" title="1">{
        docOutput, err := svc.GetInstanceIdentityDocument(context.Background(), &amp;imds.GetInstanceIdentityDocumentInput{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not get IMDS metadata: %w", err)
        }</span>
        <span class="cov8" title="1">doc := docOutput.InstanceIdentityDocument

        if len(doc.InstanceID) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("could not get valid EC2 instance ID")
        }</span>

        <span class="cov8" title="1">if len(doc.InstanceType) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("could not get valid EC2 instance type")
        }</span>

        <span class="cov8" title="1">if len(doc.Region) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("could not get valid EC2 region")
        }</span>

        <span class="cov8" title="1">if len(doc.AvailabilityZone) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("could not get valid EC2 availability zone")
        }</span>

        <span class="cov8" title="1">attachedENIs, err := getAttachedENIs(svc)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mappingsOutput, mappingsOutputErr := svc.GetMetadata(context.Background(), &amp;imds.GetMetadataInput{Path: BlockDevicesEndpoint})
        if mappingsOutputErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not get metadata for block device mappings: %w", mappingsOutputErr)
        }</span>
        <span class="cov8" title="1">mappings, mappingsErr := io.ReadAll(mappingsOutput.Content)
        if mappingsErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not read block device mappings metadata content: %w", mappingsErr)
        }</span>
        <span class="cov8" title="1">blockDevMappings := strings.Count(string(mappings), "ebs")

        instanceInfo := Metadata{
                InstanceID:             doc.InstanceID,
                InstanceType:           doc.InstanceType,
                Region:                 doc.Region,
                AvailabilityZone:       doc.AvailabilityZone,
                NumAttachedENIs:        attachedENIs,
                NumBlockDeviceMappings: blockDevMappings,
                IMDSClient:             svc,
        }

        outpostArnOutput, err := svc.GetMetadata(context.Background(), &amp;imds.GetMetadataInput{Path: OutpostArnEndpoint})
        // "outpust-arn" returns 404 for non-outpost instances. note that the request is made to a link-local address.
        // it's guaranteed to be in the form `arn:&lt;partition&gt;:outposts:&lt;region&gt;:&lt;account&gt;:outpost/&lt;outpost-id&gt;`
        // There's a case to be made here to ignore the error so a failure here wouldn't affect non-outpost calls.
        if err != nil </span><span class="cov8" title="1">{
                if !strings.Contains(err.Error(), "404") </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("something went wrong while getting EC2 outpost arn: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                outpostArnData, err := io.ReadAll(outpostArnOutput.Content)
                if err == nil </span><span class="cov8" title="1">{
                        outpostArn := string(outpostArnData)
                        klog.InfoS("Running in an outpost environment with arn", "outpostArn", outpostArn)
                        outpostArn = strings.ReplaceAll(outpostArn, "outpost/", "")
                        parsedArn, err := arn.Parse(outpostArn)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.InfoS("Failed to parse the outpost arn", "outpostArn", outpostArn)
                        }</span> else<span class="cov8" title="1"> {
                                klog.InfoS("Using outpost arn", "parsedArn", parsedArn)
                                instanceInfo.OutpostArn = parsedArn
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;instanceInfo, nil</span>
}

func getAttachedENIs(svc IMDS) (int, error) <span class="cov8" title="1">{
        enisOutput, err := svc.GetMetadata(context.Background(), &amp;imds.GetMetadataInput{Path: EnisEndpoint})
        if err != nil </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("could not get metadata for ENIs: %w", err)
        }</span>
        <span class="cov8" title="1">enis, err := io.ReadAll(enisOutput.Content)
        if err != nil </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("could not read ENIs metadata content: %w", err)
        }</span>
        <span class="cov8" title="1">attachedENIs := util.CountMACAddresses(string(enis))
        return attachedENIs, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadata

import (
        "context"
        "errors"
        "fmt"
        "net"
        "os"
        "path/filepath"
        "regexp"
        "strconv"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/util/cert"
        "k8s.io/klog/v2"
)

type KubernetesAPIClient func() (kubernetes.Interface, error)

func DefaultKubernetesAPIClient(kubeconfig string) KubernetesAPIClient <span class="cov0" title="0">{
        return func() (clientset kubernetes.Interface, err error) </span><span class="cov0" title="0">{
                var config *rest.Config
                if kubeconfig != "" </span><span class="cov0" title="0">{
                        config, err = clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
                                &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfig},
                                &amp;clientcmd.ConfigOverrides{},
                        ).ClientConfig()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        // creates the in-cluster config
                        config, err = rest.InClusterConfig()
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                        klog.InfoS("InClusterConfig failed to read token file, retrieving file from sandbox mount point")
                                        // CONTAINER_SANDBOX_MOUNT_POINT env is set upon container creation in containerd v1.6+
                                        // it provides the absolute host path to the container volume.
                                        sandboxMountPoint := os.Getenv("CONTAINER_SANDBOX_MOUNT_POINT")
                                        if sandboxMountPoint == "" </span><span class="cov0" title="0">{
                                                return nil, errors.New("CONTAINER_SANDBOX_MOUNT_POINT environment variable is not set")
                                        }</span>

                                        <span class="cov0" title="0">tokenFile := filepath.Join(sandboxMountPoint, "var", "run", "secrets", "kubernetes.io", "serviceaccount", "token")
                                        rootCAFile := filepath.Join(sandboxMountPoint, "var", "run", "secrets", "kubernetes.io", "serviceaccount", "ca.crt")

                                        token, tokenErr := os.ReadFile(tokenFile)
                                        if tokenErr != nil </span><span class="cov0" title="0">{
                                                return nil, tokenErr
                                        }</span>

                                        <span class="cov0" title="0">tlsClientConfig := rest.TLSClientConfig{}
                                        if _, certErr := cert.NewPool(rootCAFile); certErr != nil </span><span class="cov0" title="0">{
                                                return nil, fmt.Errorf("expected to load root CA config from %s, but got err: %w", rootCAFile, certErr)
                                        }</span> else<span class="cov0" title="0"> {
                                                tlsClientConfig.CAFile = rootCAFile
                                        }</span>

                                        <span class="cov0" title="0">config = &amp;rest.Config{
                                                Host:            "https://" + net.JoinHostPort(os.Getenv("KUBERNETES_SERVICE_HOST"), os.Getenv("KUBERNETES_SERVICE_PORT")),
                                                TLSClientConfig: tlsClientConfig,
                                                BearerToken:     string(token),
                                                BearerTokenFile: tokenFile,
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, err
                                }</span>
                        }
                }
                <span class="cov0" title="0">config.AcceptContentTypes = "application/vnd.kubernetes.protobuf,application/json"
                config.ContentType = "application/vnd.kubernetes.protobuf"
                // creates the clientset
                clientset, err = kubernetes.NewForConfig(config)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return clientset, nil</span>
        }
}

func KubernetesAPIInstanceInfo(clientset kubernetes.Interface) (*Metadata, error) <span class="cov8" title="1">{
        nodeName := os.Getenv("CSI_NODE_NAME")
        if nodeName == "" </span><span class="cov8" title="1">{
                return nil, errors.New("CSI_NODE_NAME env var not set")
        }</span>

        // get node with k8s API
        <span class="cov8" title="1">node, err := clientset.CoreV1().Nodes().Get(context.TODO(), nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting Node %v: %w", nodeName, err)
        }</span>

        <span class="cov8" title="1">providerID := node.Spec.ProviderID
        if providerID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("node providerID empty, cannot parse")
        }</span>

        <span class="cov8" title="1">awsInstanceIDRegex := "s\\.i-[a-z0-9]+|i-[a-z0-9]+$"

        re := regexp.MustCompile(awsInstanceIDRegex)
        instanceID := re.FindString(providerID)
        if instanceID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("did not find aws instance ID in node providerID string")
        }</span>

        <span class="cov8" title="1">var instanceType string
        if val, ok := node.GetLabels()[corev1.LabelInstanceTypeStable]; ok </span><span class="cov8" title="1">{
                instanceType = val
        }</span> else<span class="cov8" title="1"> {
                return nil, errors.New("could not retrieve instance type from topology label")
        }</span>

        <span class="cov8" title="1">var region string
        if val, ok := node.GetLabels()[corev1.LabelTopologyRegion]; ok </span><span class="cov8" title="1">{
                region = val
        }</span> else<span class="cov8" title="1"> {
                return nil, errors.New("could not retrieve region from topology label")
        }</span>

        <span class="cov8" title="1">var availabilityZone string
        if val, ok := node.GetLabels()[corev1.LabelTopologyZone]; ok </span><span class="cov8" title="1">{
                availabilityZone = val
        }</span> else<span class="cov8" title="1"> {
                return nil, errors.New("could not retrieve AZ from topology label")
        }</span>

        <span class="cov8" title="1">enis := getENIs(node)
        volumes := getVolumes(node)

        instanceInfo := Metadata{
                InstanceID:             instanceID,
                InstanceType:           instanceType,
                Region:                 region,
                AvailabilityZone:       availabilityZone,
                NumAttachedENIs:        enis,
                NumBlockDeviceMappings: volumes,
        }

        return &amp;instanceInfo, nil</span>
}

func getVolumes(node *corev1.Node) int <span class="cov8" title="1">{
        var volumes int
        if val, ok := node.GetLabels()["ebs.csi.aws.com/non-csi-ebs-volumes-count"]; ok </span><span class="cov0" title="0">{
                var err error
                volumes, err = strconv.Atoi(val)
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to convert number of volumes label to int, defaulting to 0 volumes")
                        volumes = 0
                }</span>
        } else<span class="cov8" title="1"> {
                klog.V(2).InfoS("num-volumes label not found on node, defaulting to 0 volumes")
                volumes = 0
        }</span>
        <span class="cov8" title="1">return volumes</span>
}

func getENIs(node *corev1.Node) int <span class="cov8" title="1">{
        var enis int
        if val, ok := node.GetLabels()["ebs.csi.aws.com/num-enis"]; ok </span><span class="cov0" title="0">{
                var err error
                enis, err = strconv.Atoi(val)
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to convert number of ENIs label to int, defaulting to 1 ENI")
                        enis = 1
                }</span>
        } else<span class="cov8" title="1"> {
                klog.V(2).InfoS("num-ENIs label not found on node, defaulting to 1 ENI")
                enis = 1
        }</span>
        <span class="cov8" title="1">return enis</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2025 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadata

import (
        "context"
        json "encoding/json"
        "strconv"
        "strings"
        "time"

        ec2types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/strategicpatch"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/klog/v2"
)

type enisVolumes struct {
        ENIs    int
        Volumes int
}

// ContinuousUpdateLabels is a go routine that updates the metadata labels of each node once every
// `updateTime` minutes and uses an informer to update the labels of new nodes that join the cluster.
func ContinuousUpdateLabels(k8sClient kubernetes.Interface, cloud cloud.Cloud, updateTime int) <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Duration(updateTime) * time.Minute)

        go func() </span><span class="cov0" title="0">{
                defer ticker.Stop()
                updateLabels(k8sClient, cloud)
                for range ticker.C </span><span class="cov0" title="0">{
                        updateLabels(k8sClient, cloud)
                }</span>
        }()

        <span class="cov0" title="0">informer := metadataInformer(k8sClient, cloud)
        stopCh := make(chan struct{})
        informer.Start(stopCh)
        informer.WaitForCacheSync(stopCh)</span>

        // defer ticker.Stop()
        // updateLabels(k8sClient, cloud)
        // for range ticker.C {
        //         updateLabels(k8sClient, cloud)
        // }

}

// metadataInformer returns an informer factory that patches metadata labels for new nodes that join the cluster.
func metadataInformer(clientset kubernetes.Interface, cloud cloud.Cloud) informers.SharedInformerFactory <span class="cov8" title="1">{
        factory := informers.NewSharedInformerFactory(clientset, 0)
        nodesInformer := factory.Core().V1().Nodes().Informer()
        var handler cache.ResourceEventHandlerFuncs
        handler.AddFunc = func(obj interface{}) </span><span class="cov8" title="1">{
                if nodeObj, ok := obj.(*v1.Node); ok </span><span class="cov8" title="1">{
                        node := &amp;v1.NodeList{
                                Items: []v1.Node{*nodeObj},
                        }
                        err := updateMetadataEC2(clientset, cloud, node)
                        if err != nil </span><span class="cov0" title="0">{
                                klog.ErrorS(err, "unable to update ENI/Volume count on node labels", "node", node.Items[0].Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">_, err := nodesInformer.AddEventHandler(handler)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "unable to add event handler for node informer")
        }</span>

        <span class="cov8" title="1">return factory</span>
}

func updateLabels(k8sClient kubernetes.Interface, cloud cloud.Cloud) <span class="cov0" title="0">{
        nodes, err := getNodes(k8sClient)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "could not get nodes")
                return
        }</span>
        <span class="cov0" title="0">err = updateMetadataEC2(k8sClient, cloud, nodes)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "unable to update ENI/Volume count on node labels")
        }</span>
}

func getNodes(kubeclient kubernetes.Interface) (*v1.NodeList, error) <span class="cov0" title="0">{
        nodes, err := kubeclient.CoreV1().Nodes().List(context.TODO(), metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "could not get nodes")
                return nil, err
        }</span>
        <span class="cov0" title="0">return nodes, nil</span>
}

func updateMetadataEC2(kubeclient kubernetes.Interface, c cloud.Cloud, nodes *v1.NodeList) error <span class="cov8" title="1">{
        ENIsVolumeMap, err := getMetadata(c, nodes)
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "unable to get ENI/Volume count")
                return err
        }</span>

        <span class="cov8" title="1">err = patchNodes(nodes, ENIsVolumeMap, kubeclient)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func parseNode(providerID string) string <span class="cov8" title="1">{
        if providerID != "" </span><span class="cov8" title="1">{
                parts := strings.Split(providerID, "/")
                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                        return parts[len(parts)-1]
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func getMetadata(client cloud.Cloud, nodes *v1.NodeList) (map[string]enisVolumes, error) <span class="cov8" title="1">{
        nodeIds := make([]string, 0, len(nodes.Items))
        for _, node := range nodes.Items </span><span class="cov8" title="1">{
                nodeIds = append(nodeIds, parseNode(node.Spec.ProviderID))
        }</span>

        <span class="cov8" title="1">var resp *ec2types.Instance
        var err error
        var respList []*ec2types.Instance

        if len(nodeIds) &gt; 1 </span><span class="cov8" title="1">{
                respList, err = client.GetInstances(context.TODO(), nodeIds)
        }</span> else<span class="cov8" title="1"> if len(nodeIds) == 1 </span><span class="cov8" title="1">{
                resp, err = client.GetInstance(context.TODO(), nodeIds[0])
                respList = []*ec2types.Instance{resp}
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                klog.ErrorS(err, "failed to describe instances")
                return nil, err
        }</span>

        <span class="cov8" title="1">ENIsVolumesMap := make(map[string]enisVolumes)
        for _, instance := range respList </span><span class="cov8" title="1">{
                numAttachedENIs := 1
                if instance.NetworkInterfaces != nil </span><span class="cov8" title="1">{
                        numAttachedENIs = len(instance.NetworkInterfaces)
                }</span>
                <span class="cov8" title="1">numBlockDeviceMappings := 0
                if instance.BlockDeviceMappings != nil </span><span class="cov8" title="1">{
                        numBlockDeviceMappings = len(instance.BlockDeviceMappings)
                }</span>
                <span class="cov8" title="1">instanceID := *instance.InstanceId
                ENIsVolumesMap[instanceID] = enisVolumes{ENIs: numAttachedENIs, Volumes: numBlockDeviceMappings}</span>
        }

        <span class="cov8" title="1">return ENIsVolumesMap, nil</span>
}

func patchNodes(nodes *v1.NodeList, enisVolumeMap map[string]enisVolumes, clientset kubernetes.Interface) error <span class="cov8" title="1">{
        for _, node := range nodes.Items </span><span class="cov8" title="1">{
                newNode := node.DeepCopy()
                numAttachedENIs := enisVolumeMap[parseNode(node.Spec.ProviderID)].ENIs
                numBlockDeviceMappings := enisVolumeMap[parseNode(node.Spec.ProviderID)].Volumes
                newNode.Labels["ebs.csi.aws.com/non-csi-ebs-volumes-count"] = strconv.Itoa(numBlockDeviceMappings)
                newNode.Labels["ebs.csi.aws.com/num-enis"] = strconv.Itoa(numAttachedENIs)

                oldData, err := json.Marshal(node)
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to marshal the existing node", "node", node.Name)
                        return err
                }</span>
                <span class="cov8" title="1">newData, err := json.Marshal(newNode)
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to marshal the new node", "node", newNode.Name)
                        return err
                }</span>
                <span class="cov8" title="1">patchBytes, err := strategicpatch.CreateTwoWayMergePatch(oldData, newData, &amp;v1.Node{})
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "failed to create two way merge", "node", node.Name)
                        return err
                }</span>
                <span class="cov8" title="1">if _, err := clientset.CoreV1().Nodes().Patch(context.TODO(), node.Name, types.StrategicMergePatchType, patchBytes, metav1.PatchOptions{}); err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "Failed to patch node", "node", node.Name)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metadata

import (
        "context"
        "errors"
        "fmt"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws/arn"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/klog/v2"
)

// Metadata is info about the ec2 instance on which the driver is running.
type Metadata struct {
        InstanceID             string
        InstanceType           string
        Region                 string
        AvailabilityZone       string
        NumAttachedENIs        int
        NumBlockDeviceMappings int
        OutpostArn             arn.ARN
        IMDSClient             IMDS
}

type MetadataServiceConfig struct {
        MetadataSources []string
        IMDSClient      IMDSClient
        K8sAPIClient    KubernetesAPIClient
}

const (
        SourceIMDS = "imds"
        SourceK8s  = "kubernetes"
)

var (
        // DefaultMetadataSources lists the default fallback order of driver Metadata sources.
        DefaultMetadataSources = []string{SourceIMDS, SourceK8s}
)

var _ MetadataService = &amp;Metadata{}

// NewMetadataService retrieves instance Metadata from one of the clients in MetadataServiceConfig.
// It tries each client included in MetadataServiceConfig.MetadataSources in order until one succeeds.
func NewMetadataService(cfg MetadataServiceConfig, region string) (MetadataService, error) <span class="cov8" title="1">{
        for _, source := range cfg.MetadataSources </span><span class="cov8" title="1">{
                switch source </span>{
                case SourceIMDS:<span class="cov8" title="1">
                        if os.Getenv("AWS_EC2_METADATA_DISABLED") == "true" </span><span class="cov8" title="1">{
                                klog.V(2).InfoS("Environment variable AWS_EC2_METADATA_DISABLED set to 'true'. Will not rely on IMDS for instance metadata")
                        }</span> else<span class="cov8" title="1"> {
                                klog.V(2).InfoS("Attempting to retrieve instance metadata from IMDS")
                                metadata, err := retrieveIMDSMetadata(cfg.IMDSClient)
                                if err == nil </span><span class="cov8" title="1">{
                                        klog.V(2).InfoS("Retrieved metadata from IMDS")
                                        return metadata.overrideRegion(region), nil
                                }</span>
                                <span class="cov8" title="1">klog.ErrorS(err, "Retrieving IMDS metadata failed")</span>
                        }
                case SourceK8s:<span class="cov8" title="1">
                        klog.V(2).InfoS("Attempting to retrieve instance metadata from Kubernetes API")
                        metadata, err := retrieveK8sMetadata(cfg.K8sAPIClient)
                        if err == nil </span><span class="cov8" title="1">{
                                klog.V(2).InfoS("Retrieved metadata from Kubernetes")
                                return metadata.overrideRegion(region), nil
                        }</span>
                        <span class="cov8" title="1">klog.ErrorS(err, "Retrieving Kubernetes metadata failed")</span>
                default:<span class="cov8" title="1">
                        // Unexpected cases should have been caught during driver option validation
                        return nil, InvalidSourceErr(cfg.MetadataSources, source)</span>
                }
        }

        <span class="cov8" title="1">return nil, sourcesUnavailableErr(cfg.MetadataSources)</span>
}

// UpdateMetadata refreshes ENI information.
// We do not refresh blockDeviceMappings because IMDS only reports data from when instance starts (As of April 2025).
func (m *Metadata) UpdateMetadata(k8sClient kubernetes.Interface) error <span class="cov0" title="0">{
        if m.IMDSClient == nil </span><span class="cov0" title="0">{
                nodeName := os.Getenv("CSI_NODE_NAME")
                if nodeName == "" </span><span class="cov0" title="0">{
                        return errors.New("CSI_NODE_NAME env var not set")
                }</span>

                <span class="cov0" title="0">node, err := k8sClient.CoreV1().Nodes().Get(context.TODO(), nodeName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">m.NumAttachedENIs = getENIs(node)
                m.NumBlockDeviceMappings = getVolumes(node)
                return nil</span>
        }

        <span class="cov0" title="0">attachedENIs, err := getAttachedENIs(m.IMDSClient)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update ENI count: %w", err)
        }</span>
        <span class="cov0" title="0">m.NumAttachedENIs = attachedENIs

        return nil</span>
}

func retrieveIMDSMetadata(imdsClient IMDSClient) (*Metadata, error) <span class="cov8" title="1">{
        svc, err := imdsClient()
        if err != nil </span><span class="cov8" title="1">{
                klog.ErrorS(err, "failed to initialize IMDS client")
                return nil, err
        }</span>
        <span class="cov8" title="1">return IMDSInstanceInfo(svc)</span>
}

func retrieveK8sMetadata(k8sAPIClient KubernetesAPIClient) (*Metadata, error) <span class="cov8" title="1">{
        clientset, err := k8sAPIClient()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return KubernetesAPIInstanceInfo(clientset)</span>
}

// Override the region on a Metadata object if it is non-empty.
func (m *Metadata) overrideRegion(region string) *Metadata <span class="cov8" title="1">{
        if region != "" </span><span class="cov8" title="1">{
                m.Region = region
        }</span>
        <span class="cov8" title="1">return m</span>
}

// GetInstanceID returns the instance identification.
func (m *Metadata) GetInstanceID() string <span class="cov8" title="1">{
        return m.InstanceID
}</span>

// GetInstanceType returns the instance type.
func (m *Metadata) GetInstanceType() string <span class="cov8" title="1">{
        return m.InstanceType
}</span>

// GetRegion returns the region which the instance is in.
func (m *Metadata) GetRegion() string <span class="cov8" title="1">{
        return m.Region
}</span>

// GetAvailabilityZone returns the Availability Zone which the instance is in.
func (m *Metadata) GetAvailabilityZone() string <span class="cov8" title="1">{
        return m.AvailabilityZone
}</span>

// GetNumAttachedENIs returns the number of attached ENIs.
func (m *Metadata) GetNumAttachedENIs() int <span class="cov8" title="1">{
        return m.NumAttachedENIs
}</span>

// GetNumBlockDeviceMappings returns the number of block device mappings.
func (m *Metadata) GetNumBlockDeviceMappings() int <span class="cov8" title="1">{
        return m.NumBlockDeviceMappings
}</span>

// GetOutpostArn returns outpost arn if instance is running on an outpost. empty otherwise.
func (m *Metadata) GetOutpostArn() arn.ARN <span class="cov8" title="1">{
        return m.OutpostArn
}</span>

// InvalidSourceErr returns an error message when a metadata source is invalid.
func InvalidSourceErr(sources []string, invalidSource string) error <span class="cov8" title="1">{
        return fmt.Errorf("invalid source: argument --metadata-sources=%s included invalid option '%s', comma-separated string MUST only include tokens like '%s' or '%s'", sources, invalidSource, SourceIMDS, SourceK8s)
}</span>

func sourcesUnavailableErr(metadataSources []string) error <span class="cov8" title="1">{
        return fmt.Errorf("all specified --metadata-sources '%s' are unavailable", metadataSources)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/cloud/metadata/interface.go

// Package metadata is a generated GoMock package.
package metadata

import (
        context "context"
        reflect "reflect"

        arn "github.com/aws/aws-sdk-go-v2/aws/arn"
        imds "github.com/aws/aws-sdk-go-v2/feature/ec2/imds"
        gomock "github.com/golang/mock/gomock"
        kubernetes "k8s.io/client-go/kubernetes"
)

// MockMetadataService is a mock of MetadataService interface.
type MockMetadataService struct {
        ctrl     *gomock.Controller
        recorder *MockMetadataServiceMockRecorder
}

// MockMetadataServiceMockRecorder is the mock recorder for MockMetadataService.
type MockMetadataServiceMockRecorder struct {
        mock *MockMetadataService
}

// NewMockMetadataService creates a new mock instance.
func NewMockMetadataService(ctrl *gomock.Controller) *MockMetadataService <span class="cov0" title="0">{
        mock := &amp;MockMetadataService{ctrl: ctrl}
        mock.recorder = &amp;MockMetadataServiceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMetadataService) EXPECT() *MockMetadataServiceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// GetAvailabilityZone mocks base method.
func (m *MockMetadataService) GetAvailabilityZone() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetAvailabilityZone")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetAvailabilityZone indicates an expected call of GetAvailabilityZone.
func (mr *MockMetadataServiceMockRecorder) GetAvailabilityZone() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAvailabilityZone", reflect.TypeOf((*MockMetadataService)(nil).GetAvailabilityZone))
}</span>

// GetInstanceID mocks base method.
func (m *MockMetadataService) GetInstanceID() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstanceID")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetInstanceID indicates an expected call of GetInstanceID.
func (mr *MockMetadataServiceMockRecorder) GetInstanceID() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstanceID", reflect.TypeOf((*MockMetadataService)(nil).GetInstanceID))
}</span>

// GetInstanceType mocks base method.
func (m *MockMetadataService) GetInstanceType() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstanceType")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetInstanceType indicates an expected call of GetInstanceType.
func (mr *MockMetadataServiceMockRecorder) GetInstanceType() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstanceType", reflect.TypeOf((*MockMetadataService)(nil).GetInstanceType))
}</span>

// GetNumAttachedENIs mocks base method.
func (m *MockMetadataService) GetNumAttachedENIs() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNumAttachedENIs")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// GetNumAttachedENIs indicates an expected call of GetNumAttachedENIs.
func (mr *MockMetadataServiceMockRecorder) GetNumAttachedENIs() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNumAttachedENIs", reflect.TypeOf((*MockMetadataService)(nil).GetNumAttachedENIs))
}</span>

// GetNumBlockDeviceMappings mocks base method.
func (m *MockMetadataService) GetNumBlockDeviceMappings() int <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetNumBlockDeviceMappings")
        ret0, _ := ret[0].(int)
        return ret0
}</span>

// GetNumBlockDeviceMappings indicates an expected call of GetNumBlockDeviceMappings.
func (mr *MockMetadataServiceMockRecorder) GetNumBlockDeviceMappings() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetNumBlockDeviceMappings", reflect.TypeOf((*MockMetadataService)(nil).GetNumBlockDeviceMappings))
}</span>

// GetOutpostArn mocks base method.
func (m *MockMetadataService) GetOutpostArn() arn.ARN <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetOutpostArn")
        ret0, _ := ret[0].(arn.ARN)
        return ret0
}</span>

// GetOutpostArn indicates an expected call of GetOutpostArn.
func (mr *MockMetadataServiceMockRecorder) GetOutpostArn() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOutpostArn", reflect.TypeOf((*MockMetadataService)(nil).GetOutpostArn))
}</span>

// GetRegion mocks base method.
func (m *MockMetadataService) GetRegion() string <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetRegion")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetRegion indicates an expected call of GetRegion.
func (mr *MockMetadataServiceMockRecorder) GetRegion() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRegion", reflect.TypeOf((*MockMetadataService)(nil).GetRegion))
}</span>

// UpdateMetadata mocks base method.
func (m *MockMetadataService) UpdateMetadata(k8sClient kubernetes.Interface) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateMetadata", k8sClient)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// UpdateMetadata indicates an expected call of UpdateMetadata.
func (mr *MockMetadataServiceMockRecorder) UpdateMetadata(k8sClient interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMetadata", reflect.TypeOf((*MockMetadataService)(nil).UpdateMetadata), k8sClient)
}</span>

// MockIMDS is a mock of IMDS interface.
type MockIMDS struct {
        ctrl     *gomock.Controller
        recorder *MockIMDSMockRecorder
}

// MockIMDSMockRecorder is the mock recorder for MockIMDS.
type MockIMDSMockRecorder struct {
        mock *MockIMDS
}

// NewMockIMDS creates a new mock instance.
func NewMockIMDS(ctrl *gomock.Controller) *MockIMDS <span class="cov8" title="1">{
        mock := &amp;MockIMDS{ctrl: ctrl}
        mock.recorder = &amp;MockIMDSMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIMDS) EXPECT() *MockIMDSMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// GetDynamicData mocks base method.
func (m *MockIMDS) GetDynamicData(ctx context.Context, params *imds.GetDynamicDataInput, optFns ...func(*imds.Options)) (*imds.GetDynamicDataOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetDynamicData", varargs...)
        ret0, _ := ret[0].(*imds.GetDynamicDataOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetDynamicData indicates an expected call of GetDynamicData.
func (mr *MockIMDSMockRecorder) GetDynamicData(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDynamicData", reflect.TypeOf((*MockIMDS)(nil).GetDynamicData), varargs...)
}</span>

// GetIAMInfo mocks base method.
func (m *MockIMDS) GetIAMInfo(ctx context.Context, params *imds.GetIAMInfoInput, optFns ...func(*imds.Options)) (*imds.GetIAMInfoOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetIAMInfo", varargs...)
        ret0, _ := ret[0].(*imds.GetIAMInfoOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetIAMInfo indicates an expected call of GetIAMInfo.
func (mr *MockIMDSMockRecorder) GetIAMInfo(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetIAMInfo", reflect.TypeOf((*MockIMDS)(nil).GetIAMInfo), varargs...)
}</span>

// GetInstanceIdentityDocument mocks base method.
func (m *MockIMDS) GetInstanceIdentityDocument(ctx context.Context, params *imds.GetInstanceIdentityDocumentInput, optFns ...func(*imds.Options)) (*imds.GetInstanceIdentityDocumentOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetInstanceIdentityDocument", varargs...)
        ret0, _ := ret[0].(*imds.GetInstanceIdentityDocumentOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetInstanceIdentityDocument indicates an expected call of GetInstanceIdentityDocument.
func (mr *MockIMDSMockRecorder) GetInstanceIdentityDocument(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstanceIdentityDocument", reflect.TypeOf((*MockIMDS)(nil).GetInstanceIdentityDocument), varargs...)
}</span>

// GetMetadata mocks base method.
func (m *MockIMDS) GetMetadata(ctx context.Context, params *imds.GetMetadataInput, optFns ...func(*imds.Options)) (*imds.GetMetadataOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "GetMetadata", varargs...)
        ret0, _ := ret[0].(*imds.GetMetadataOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetMetadata indicates an expected call of GetMetadata.
func (mr *MockIMDSMockRecorder) GetMetadata(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMetadata", reflect.TypeOf((*MockIMDS)(nil).GetMetadata), varargs...)
}</span>

// GetRegion mocks base method.
func (m *MockIMDS) GetRegion(ctx context.Context, params *imds.GetRegionInput, optFns ...func(*imds.Options)) (*imds.GetRegionOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetRegion", varargs...)
        ret0, _ := ret[0].(*imds.GetRegionOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetRegion indicates an expected call of GetRegion.
func (mr *MockIMDSMockRecorder) GetRegion(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRegion", reflect.TypeOf((*MockIMDS)(nil).GetRegion), varargs...)
}</span>

// GetUserData mocks base method.
func (m *MockIMDS) GetUserData(ctx context.Context, params *imds.GetUserDataInput, optFns ...func(*imds.Options)) (*imds.GetUserDataOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "GetUserData", varargs...)
        ret0, _ := ret[0].(*imds.GetUserDataOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// GetUserData indicates an expected call of GetUserData.
func (mr *MockIMDSMockRecorder) GetUserData(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUserData", reflect.TypeOf((*MockIMDS)(nil).GetUserData), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/cloud/interface.go

// Package cloud is a generated GoMock package.
package cloud

import (
        context "context"
        reflect "reflect"

        ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"
        types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
        gomock "github.com/golang/mock/gomock"
)

// MockCloud is a mock of Cloud interface.
type MockCloud struct {
        ctrl     *gomock.Controller
        recorder *MockCloudMockRecorder
}

// MockCloudMockRecorder is the mock recorder for MockCloud.
type MockCloudMockRecorder struct {
        mock *MockCloud
}

// NewMockCloud creates a new mock instance.
func NewMockCloud(ctrl *gomock.Controller) *MockCloud <span class="cov0" title="0">{
        mock := &amp;MockCloud{ctrl: ctrl}
        mock.recorder = &amp;MockCloudMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCloud) EXPECT() *MockCloudMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// AttachDisk mocks base method.
func (m *MockCloud) AttachDisk(ctx context.Context, volumeID, nodeID string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AttachDisk", ctx, volumeID, nodeID)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AttachDisk indicates an expected call of AttachDisk.
func (mr *MockCloudMockRecorder) AttachDisk(ctx, volumeID, nodeID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachDisk", reflect.TypeOf((*MockCloud)(nil).AttachDisk), ctx, volumeID, nodeID)
}</span>

// AvailabilityZones mocks base method.
func (m *MockCloud) AvailabilityZones(ctx context.Context) (map[string]struct{}, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AvailabilityZones", ctx)
        ret0, _ := ret[0].(map[string]struct{})
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AvailabilityZones indicates an expected call of AvailabilityZones.
func (mr *MockCloudMockRecorder) AvailabilityZones(ctx interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AvailabilityZones", reflect.TypeOf((*MockCloud)(nil).AvailabilityZones), ctx)
}</span>

// CreateDisk mocks base method.
func (m *MockCloud) CreateDisk(ctx context.Context, volumeName string, diskOptions *DiskOptions) (*Disk, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateDisk", ctx, volumeName, diskOptions)
        ret0, _ := ret[0].(*Disk)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateDisk indicates an expected call of CreateDisk.
func (mr *MockCloudMockRecorder) CreateDisk(ctx, volumeName, diskOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDisk", reflect.TypeOf((*MockCloud)(nil).CreateDisk), ctx, volumeName, diskOptions)
}</span>

// CreateSnapshot mocks base method.
func (m *MockCloud) CreateSnapshot(ctx context.Context, volumeID string, snapshotOptions *SnapshotOptions) (*Snapshot, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateSnapshot", ctx, volumeID, snapshotOptions)
        ret0, _ := ret[0].(*Snapshot)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateSnapshot indicates an expected call of CreateSnapshot.
func (mr *MockCloudMockRecorder) CreateSnapshot(ctx, volumeID, snapshotOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSnapshot", reflect.TypeOf((*MockCloud)(nil).CreateSnapshot), ctx, volumeID, snapshotOptions)
}</span>

// DeleteDisk mocks base method.
func (m *MockCloud) DeleteDisk(ctx context.Context, volumeID string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteDisk", ctx, volumeID)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteDisk indicates an expected call of DeleteDisk.
func (mr *MockCloudMockRecorder) DeleteDisk(ctx, volumeID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDisk", reflect.TypeOf((*MockCloud)(nil).DeleteDisk), ctx, volumeID)
}</span>

// DeleteSnapshot mocks base method.
func (m *MockCloud) DeleteSnapshot(ctx context.Context, snapshotID string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteSnapshot", ctx, snapshotID)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// DeleteSnapshot indicates an expected call of DeleteSnapshot.
func (mr *MockCloudMockRecorder) DeleteSnapshot(ctx, snapshotID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSnapshot", reflect.TypeOf((*MockCloud)(nil).DeleteSnapshot), ctx, snapshotID)
}</span>

// DetachDisk mocks base method.
func (m *MockCloud) DetachDisk(ctx context.Context, volumeID, nodeID string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DetachDisk", ctx, volumeID, nodeID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DetachDisk indicates an expected call of DetachDisk.
func (mr *MockCloudMockRecorder) DetachDisk(ctx, volumeID, nodeID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachDisk", reflect.TypeOf((*MockCloud)(nil).DetachDisk), ctx, volumeID, nodeID)
}</span>

// EnableFastSnapshotRestores mocks base method.
func (m *MockCloud) EnableFastSnapshotRestores(ctx context.Context, availabilityZones []string, snapshotID string) (*ec2.EnableFastSnapshotRestoresOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "EnableFastSnapshotRestores", ctx, availabilityZones, snapshotID)
        ret0, _ := ret[0].(*ec2.EnableFastSnapshotRestoresOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// EnableFastSnapshotRestores indicates an expected call of EnableFastSnapshotRestores.
func (mr *MockCloudMockRecorder) EnableFastSnapshotRestores(ctx, availabilityZones, snapshotID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableFastSnapshotRestores", reflect.TypeOf((*MockCloud)(nil).EnableFastSnapshotRestores), ctx, availabilityZones, snapshotID)
}</span>

// GetDiskByID mocks base method.
func (m *MockCloud) GetDiskByID(ctx context.Context, volumeID string) (*Disk, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDiskByID", ctx, volumeID)
        ret0, _ := ret[0].(*Disk)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetDiskByID indicates an expected call of GetDiskByID.
func (mr *MockCloudMockRecorder) GetDiskByID(ctx, volumeID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDiskByID", reflect.TypeOf((*MockCloud)(nil).GetDiskByID), ctx, volumeID)
}</span>

// GetDiskByName mocks base method.
func (m *MockCloud) GetDiskByName(ctx context.Context, name string, capacityBytes int64) (*Disk, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDiskByName", ctx, name, capacityBytes)
        ret0, _ := ret[0].(*Disk)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetDiskByName indicates an expected call of GetDiskByName.
func (mr *MockCloudMockRecorder) GetDiskByName(ctx, name, capacityBytes interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDiskByName", reflect.TypeOf((*MockCloud)(nil).GetDiskByName), ctx, name, capacityBytes)
}</span>

// GetInstance mocks base method.
func (m *MockCloud) GetInstance(ctx context.Context, nodeID string) (*types.Instance, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstance", ctx, nodeID)
        ret0, _ := ret[0].(*types.Instance)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInstance indicates an expected call of GetInstance.
func (mr *MockCloudMockRecorder) GetInstance(ctx, nodeID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstance", reflect.TypeOf((*MockCloud)(nil).GetInstance), ctx, nodeID)
}</span>

// GetInstances mocks base method.
func (m *MockCloud) GetInstances(ctx context.Context, nodeIDs []string) ([]*types.Instance, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetInstances", ctx, nodeIDs)
        ret0, _ := ret[0].([]*types.Instance)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetInstances indicates an expected call of GetInstances.
func (mr *MockCloudMockRecorder) GetInstances(ctx, nodeIDs interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetInstances", reflect.TypeOf((*MockCloud)(nil).GetInstances), ctx, nodeIDs)
}</span>

// GetSnapshotByID mocks base method.
func (m *MockCloud) GetSnapshotByID(ctx context.Context, snapshotID string) (*Snapshot, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSnapshotByID", ctx, snapshotID)
        ret0, _ := ret[0].(*Snapshot)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSnapshotByID indicates an expected call of GetSnapshotByID.
func (mr *MockCloudMockRecorder) GetSnapshotByID(ctx, snapshotID interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSnapshotByID", reflect.TypeOf((*MockCloud)(nil).GetSnapshotByID), ctx, snapshotID)
}</span>

// GetSnapshotByName mocks base method.
func (m *MockCloud) GetSnapshotByName(ctx context.Context, name string) (*Snapshot, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetSnapshotByName", ctx, name)
        ret0, _ := ret[0].(*Snapshot)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetSnapshotByName indicates an expected call of GetSnapshotByName.
func (mr *MockCloudMockRecorder) GetSnapshotByName(ctx, name interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSnapshotByName", reflect.TypeOf((*MockCloud)(nil).GetSnapshotByName), ctx, name)
}</span>

// ListSnapshots mocks base method.
func (m *MockCloud) ListSnapshots(ctx context.Context, volumeID string, maxResults int32, nextToken string) (*ListSnapshotsResponse, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ListSnapshots", ctx, volumeID, maxResults, nextToken)
        ret0, _ := ret[0].(*ListSnapshotsResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ListSnapshots indicates an expected call of ListSnapshots.
func (mr *MockCloudMockRecorder) ListSnapshots(ctx, volumeID, maxResults, nextToken interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSnapshots", reflect.TypeOf((*MockCloud)(nil).ListSnapshots), ctx, volumeID, maxResults, nextToken)
}</span>

// ModifyTags mocks base method.
func (m *MockCloud) ModifyTags(ctx context.Context, volumeID string, tagOptions ModifyTagsOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ModifyTags", ctx, volumeID, tagOptions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// ModifyTags indicates an expected call of ModifyTags.
func (mr *MockCloudMockRecorder) ModifyTags(ctx, volumeID, tagOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModifyTags", reflect.TypeOf((*MockCloud)(nil).ModifyTags), ctx, volumeID, tagOptions)
}</span>

// ResizeOrModifyDisk mocks base method.
func (m *MockCloud) ResizeOrModifyDisk(ctx context.Context, volumeID string, newSizeBytes int64, options *ModifyDiskOptions) (int32, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResizeOrModifyDisk", ctx, volumeID, newSizeBytes, options)
        ret0, _ := ret[0].(int32)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ResizeOrModifyDisk indicates an expected call of ResizeOrModifyDisk.
func (mr *MockCloudMockRecorder) ResizeOrModifyDisk(ctx, volumeID, newSizeBytes, options interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResizeOrModifyDisk", reflect.TypeOf((*MockCloud)(nil).ResizeOrModifyDisk), ctx, volumeID, newSizeBytes, options)
}</span>

// WaitForAttachmentState mocks base method.
func (m *MockCloud) WaitForAttachmentState(ctx context.Context, expectedState types.VolumeAttachmentState, volumeID, expectedInstance, expectedDevice string, alreadyAssigned bool) (*types.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "WaitForAttachmentState", ctx, expectedState, volumeID, expectedInstance, expectedDevice, alreadyAssigned)
        ret0, _ := ret[0].(*types.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// WaitForAttachmentState indicates an expected call of WaitForAttachmentState.
func (mr *MockCloudMockRecorder) WaitForAttachmentState(ctx, expectedState, volumeID, expectedInstance, expectedDevice, alreadyAssigned interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForAttachmentState", reflect.TypeOf((*MockCloud)(nil).WaitForAttachmentState), ctx, expectedState, volumeID, expectedInstance, expectedDevice, alreadyAssigned)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/cloud/ec2_interface.go

// Package cloud is a generated GoMock package.
package cloud

import (
        context "context"
        reflect "reflect"

        ec2 "github.com/aws/aws-sdk-go-v2/service/ec2"
        gomock "github.com/golang/mock/gomock"
)

// MockEC2API is a mock of EC2API interface.
type MockEC2API struct {
        ctrl     *gomock.Controller
        recorder *MockEC2APIMockRecorder
}

// MockEC2APIMockRecorder is the mock recorder for MockEC2API.
type MockEC2APIMockRecorder struct {
        mock *MockEC2API
}

// NewMockEC2API creates a new mock instance.
func NewMockEC2API(ctrl *gomock.Controller) *MockEC2API <span class="cov8" title="1">{
        mock := &amp;MockEC2API{ctrl: ctrl}
        mock.recorder = &amp;MockEC2APIMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEC2API) EXPECT() *MockEC2APIMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AttachVolume mocks base method.
func (m *MockEC2API) AttachVolume(ctx context.Context, params *ec2.AttachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.AttachVolumeOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "AttachVolume", varargs...)
        ret0, _ := ret[0].(*ec2.AttachVolumeOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// AttachVolume indicates an expected call of AttachVolume.
func (mr *MockEC2APIMockRecorder) AttachVolume(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachVolume", reflect.TypeOf((*MockEC2API)(nil).AttachVolume), varargs...)
}</span>

// CreateSnapshot mocks base method.
func (m *MockEC2API) CreateSnapshot(ctx context.Context, params *ec2.CreateSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.CreateSnapshotOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "CreateSnapshot", varargs...)
        ret0, _ := ret[0].(*ec2.CreateSnapshotOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CreateSnapshot indicates an expected call of CreateSnapshot.
func (mr *MockEC2APIMockRecorder) CreateSnapshot(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateSnapshot", reflect.TypeOf((*MockEC2API)(nil).CreateSnapshot), varargs...)
}</span>

// CreateTags mocks base method.
func (m *MockEC2API) CreateTags(ctx context.Context, params *ec2.CreateTagsInput, optFns ...func(*ec2.Options)) (*ec2.CreateTagsOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "CreateTags", varargs...)
        ret0, _ := ret[0].(*ec2.CreateTagsOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CreateTags indicates an expected call of CreateTags.
func (mr *MockEC2APIMockRecorder) CreateTags(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTags", reflect.TypeOf((*MockEC2API)(nil).CreateTags), varargs...)
}</span>

// CreateVolume mocks base method.
func (m *MockEC2API) CreateVolume(ctx context.Context, params *ec2.CreateVolumeInput, optFns ...func(*ec2.Options)) (*ec2.CreateVolumeOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "CreateVolume", varargs...)
        ret0, _ := ret[0].(*ec2.CreateVolumeOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// CreateVolume indicates an expected call of CreateVolume.
func (mr *MockEC2APIMockRecorder) CreateVolume(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateVolume", reflect.TypeOf((*MockEC2API)(nil).CreateVolume), varargs...)
}</span>

// DeleteSnapshot mocks base method.
func (m *MockEC2API) DeleteSnapshot(ctx context.Context, params *ec2.DeleteSnapshotInput, optFns ...func(*ec2.Options)) (*ec2.DeleteSnapshotOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeleteSnapshot", varargs...)
        ret0, _ := ret[0].(*ec2.DeleteSnapshotOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteSnapshot indicates an expected call of DeleteSnapshot.
func (mr *MockEC2APIMockRecorder) DeleteSnapshot(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteSnapshot", reflect.TypeOf((*MockEC2API)(nil).DeleteSnapshot), varargs...)
}</span>

// DeleteTags mocks base method.
func (m *MockEC2API) DeleteTags(ctx context.Context, params *ec2.DeleteTagsInput, optFns ...func(*ec2.Options)) (*ec2.DeleteTagsOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeleteTags", varargs...)
        ret0, _ := ret[0].(*ec2.DeleteTagsOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteTags indicates an expected call of DeleteTags.
func (mr *MockEC2APIMockRecorder) DeleteTags(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTags", reflect.TypeOf((*MockEC2API)(nil).DeleteTags), varargs...)
}</span>

// DeleteVolume mocks base method.
func (m *MockEC2API) DeleteVolume(ctx context.Context, params *ec2.DeleteVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DeleteVolumeOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DeleteVolume", varargs...)
        ret0, _ := ret[0].(*ec2.DeleteVolumeOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DeleteVolume indicates an expected call of DeleteVolume.
func (mr *MockEC2APIMockRecorder) DeleteVolume(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteVolume", reflect.TypeOf((*MockEC2API)(nil).DeleteVolume), varargs...)
}</span>

// DescribeAvailabilityZones mocks base method.
func (m *MockEC2API) DescribeAvailabilityZones(ctx context.Context, params *ec2.DescribeAvailabilityZonesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeAvailabilityZonesOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DescribeAvailabilityZones", varargs...)
        ret0, _ := ret[0].(*ec2.DescribeAvailabilityZonesOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DescribeAvailabilityZones indicates an expected call of DescribeAvailabilityZones.
func (mr *MockEC2APIMockRecorder) DescribeAvailabilityZones(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeAvailabilityZones", reflect.TypeOf((*MockEC2API)(nil).DescribeAvailabilityZones), varargs...)
}</span>

// DescribeInstances mocks base method.
func (m *MockEC2API) DescribeInstances(ctx context.Context, params *ec2.DescribeInstancesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeInstancesOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DescribeInstances", varargs...)
        ret0, _ := ret[0].(*ec2.DescribeInstancesOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DescribeInstances indicates an expected call of DescribeInstances.
func (mr *MockEC2APIMockRecorder) DescribeInstances(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeInstances", reflect.TypeOf((*MockEC2API)(nil).DescribeInstances), varargs...)
}</span>

// DescribeSnapshots mocks base method.
func (m *MockEC2API) DescribeSnapshots(ctx context.Context, params *ec2.DescribeSnapshotsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeSnapshotsOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DescribeSnapshots", varargs...)
        ret0, _ := ret[0].(*ec2.DescribeSnapshotsOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DescribeSnapshots indicates an expected call of DescribeSnapshots.
func (mr *MockEC2APIMockRecorder) DescribeSnapshots(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeSnapshots", reflect.TypeOf((*MockEC2API)(nil).DescribeSnapshots), varargs...)
}</span>

// DescribeTags mocks base method.
func (m *MockEC2API) DescribeTags(ctx context.Context, params *ec2.DescribeTagsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeTagsOutput, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "DescribeTags", varargs...)
        ret0, _ := ret[0].(*ec2.DescribeTagsOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DescribeTags indicates an expected call of DescribeTags.
func (mr *MockEC2APIMockRecorder) DescribeTags(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeTags", reflect.TypeOf((*MockEC2API)(nil).DescribeTags), varargs...)
}</span>

// DescribeVolumes mocks base method.
func (m *MockEC2API) DescribeVolumes(ctx context.Context, params *ec2.DescribeVolumesInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DescribeVolumes", varargs...)
        ret0, _ := ret[0].(*ec2.DescribeVolumesOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DescribeVolumes indicates an expected call of DescribeVolumes.
func (mr *MockEC2APIMockRecorder) DescribeVolumes(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeVolumes", reflect.TypeOf((*MockEC2API)(nil).DescribeVolumes), varargs...)
}</span>

// DescribeVolumesModifications mocks base method.
func (m *MockEC2API) DescribeVolumesModifications(ctx context.Context, params *ec2.DescribeVolumesModificationsInput, optFns ...func(*ec2.Options)) (*ec2.DescribeVolumesModificationsOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DescribeVolumesModifications", varargs...)
        ret0, _ := ret[0].(*ec2.DescribeVolumesModificationsOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DescribeVolumesModifications indicates an expected call of DescribeVolumesModifications.
func (mr *MockEC2APIMockRecorder) DescribeVolumesModifications(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DescribeVolumesModifications", reflect.TypeOf((*MockEC2API)(nil).DescribeVolumesModifications), varargs...)
}</span>

// DetachVolume mocks base method.
func (m *MockEC2API) DetachVolume(ctx context.Context, params *ec2.DetachVolumeInput, optFns ...func(*ec2.Options)) (*ec2.DetachVolumeOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "DetachVolume", varargs...)
        ret0, _ := ret[0].(*ec2.DetachVolumeOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// DetachVolume indicates an expected call of DetachVolume.
func (mr *MockEC2APIMockRecorder) DetachVolume(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachVolume", reflect.TypeOf((*MockEC2API)(nil).DetachVolume), varargs...)
}</span>

// EnableFastSnapshotRestores mocks base method.
func (m *MockEC2API) EnableFastSnapshotRestores(ctx context.Context, params *ec2.EnableFastSnapshotRestoresInput, optFns ...func(*ec2.Options)) (*ec2.EnableFastSnapshotRestoresOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "EnableFastSnapshotRestores", varargs...)
        ret0, _ := ret[0].(*ec2.EnableFastSnapshotRestoresOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// EnableFastSnapshotRestores indicates an expected call of EnableFastSnapshotRestores.
func (mr *MockEC2APIMockRecorder) EnableFastSnapshotRestores(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableFastSnapshotRestores", reflect.TypeOf((*MockEC2API)(nil).EnableFastSnapshotRestores), varargs...)
}</span>

// ModifyVolume mocks base method.
func (m *MockEC2API) ModifyVolume(ctx context.Context, params *ec2.ModifyVolumeInput, optFns ...func(*ec2.Options)) (*ec2.ModifyVolumeOutput, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, params}
        for _, a := range optFns </span><span class="cov8" title="1">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "ModifyVolume", varargs...)
        ret0, _ := ret[0].(*ec2.ModifyVolumeOutput)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// ModifyVolume indicates an expected call of ModifyVolume.
func (mr *MockEC2APIMockRecorder) ModifyVolume(ctx, params interface{}, optFns ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, params}, optFns...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ModifyVolume", reflect.TypeOf((*MockEC2API)(nil).ModifyVolume), varargs...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloud

import (
        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/aws/retry"
)

const (
        // retryMaxAttempt sets max number of EC2 API call attempts.
        // Set high enough to ensure default sidecar timeout will cancel context long before we stop retrying.
        retryMaxAttempt = 50
)

// retryManager dictates the retry strategies of EC2 API calls.
// Each mutating EC2 API has its own retryer because the AWS SDK throttles on a retryer object level, not by API name.
// While default AWS accounts share request tokens between mutating APIs, users can raise limits for individual APIs.
// Separate retryers ensures that throttling one API doesn't unintentionally throttle others with separate token buckets.
type retryManager struct {
        createVolumeRetryer                            aws.Retryer
        deleteVolumeRetryer                            aws.Retryer
        attachVolumeRetryer                            aws.Retryer
        detachVolumeRetryer                            aws.Retryer
        modifyVolumeRetryer                            aws.Retryer
        createSnapshotRetryer                          aws.Retryer
        deleteSnapshotRetryer                          aws.Retryer
        enableFastSnapshotRestoresRetryer              aws.Retryer
        unbatchableDescribeVolumesModificationsRetryer aws.Retryer
}

func newRetryManager() *retryManager <span class="cov8" title="1">{
        return &amp;retryManager{
                createVolumeRetryer:                            newAdaptiveRetryer(),
                attachVolumeRetryer:                            newAdaptiveRetryer(),
                deleteVolumeRetryer:                            newAdaptiveRetryer(),
                detachVolumeRetryer:                            newAdaptiveRetryer(),
                modifyVolumeRetryer:                            newAdaptiveRetryer(),
                createSnapshotRetryer:                          newAdaptiveRetryer(),
                deleteSnapshotRetryer:                          newAdaptiveRetryer(),
                enableFastSnapshotRestoresRetryer:              newAdaptiveRetryer(),
                unbatchableDescribeVolumesModificationsRetryer: newAdaptiveRetryer(),
        }
}</span>

// newAdaptiveRetryer restricts attempts of API calls that recently hit throttle errors.
func newAdaptiveRetryer() *retry.AdaptiveMode <span class="cov8" title="1">{
        return retry.NewAdaptiveMode(func(ao *retry.AdaptiveModeOptions) </span><span class="cov8" title="1">{
                ao.StandardOptions = append(ao.StandardOptions, func(so *retry.StandardOptions) </span><span class="cov8" title="1">{
                        so.MaxAttempts = retryMaxAttempt
                }</span>)
        })
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cloud

import (
        "regexp"
        "strings"
)

// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances
const (
        highMemoryMetalInstancesMaxVolumes   = 19
        highMemoryVirtualInstancesMaxVolumes = 27
        baremetalMaxVolumes                  = 31
        nonNitroMaxAttachments               = 39
        nitroMaxAttachments                  = 28
)

//nolint:gochecknoinits // TODO Refactor to avoid using init function to prevent side-effects
func init() <span class="cov8" title="1">{
        // This list of Nitro instance types have a dedicated Amazon EBS volume limit of up to 128 attachments, depending on instance size.
        // The limit is not shared with other device attachments: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/volume_limits.html#nitro-system-limits
        instanceFamilies := []string{"m8g", "m8gd", "m7i", "m7i-flex", "m7a", "c8g", "c8gd", "c7i", "c7i-flex", "c7a", "r7a", "r7i", "r7iz", "r8g", "r8gd", "x8g", "u7i", "u7inh", "g6", "g6e", "gr6", "i7i", "i7ie", "i8g", "p5", "p5e", "p5en", "u7i-6tb", "u7i-8tb", "u7i-12tb", "u7in-16tb", "u7in-24tb", "u7in-32tb", "u7inh-32tb", "f2", "trn2", "trn2u"}
        commonInstanceSizes := []string{"medium", "large", "xlarge", "2xlarge", "4xlarge", "6xlarge", "8xlarge", "12xlarge"}
        dedicatedVolumeLimits["p4d.24xlarge"] = 28
        dedicatedVolumeLimits["trn2.48xlarge"] = 64
        dedicatedVolumeLimits["trn2u.48xlarge"] = 64
        dedicatedVolumeLimits["hpc7a.12xlarge"] = 27
        dedicatedVolumeLimits["hpc7a.24xlarge"] = 27
        dedicatedVolumeLimits["hpc7a.48xlarge"] = 27
        dedicatedVolumeLimits["hpc7a.96xlarge"] = 27
        dedicatedVolumeLimits["p6-b200.48xlarge"] = 64

        for _, family := range instanceFamilies </span><span class="cov8" title="1">{
                for _, size := range commonInstanceSizes </span><span class="cov8" title="1">{
                        dedicatedVolumeLimits[family+"."+size] = 32
                }</span>
                <span class="cov8" title="1">dedicatedVolumeLimits[family+".metal-16xl"] = 39
                dedicatedVolumeLimits[family+".metal-24xl"] = 39
                dedicatedVolumeLimits[family+".16xlarge"] = 48
                dedicatedVolumeLimits[family+".24xlarge"] = 64
                dedicatedVolumeLimits[family+".metal-32xl"] = 79
                dedicatedVolumeLimits[family+".metal-48xl"] = 79
                dedicatedVolumeLimits[family+".32xlarge"] = 88
                dedicatedVolumeLimits[family+".48xlarge"] = 128
                dedicatedVolumeLimits[family+".112xlarge"] = 128
                dedicatedVolumeLimits[family+".224xlarge"] = 128
                dedicatedVolumeLimits[family+".480xlarge"] = 128</span>
        }
}

var dedicatedVolumeLimits = map[string]int{}

// List of nitro instance types can be found here: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances
var nonNitroInstanceFamilies = map[string]struct{}{
        "t2":  {},
        "c3":  {},
        "m3":  {},
        "r3":  {},
        "c4":  {},
        "m4":  {},
        "r4":  {},
        "x1e": {},
        "x1":  {},
        "p2":  {},
        "p3":  {},
        "g3":  {},
        "d2":  {},
        "h1":  {},
        "f1":  {},
}

func IsNitroInstanceType(it string) bool <span class="cov0" title="0">{
        strs := strings.Split(it, ".")

        if len(strs) != 2 </span><span class="cov0" title="0">{
                panic("cannot determine family of instance type")</span>
        }

        <span class="cov0" title="0">family := strs[0]
        _, ok := nonNitroInstanceFamilies[family]
        return !ok</span>
}

func GetMaxAttachments(nitro bool) int <span class="cov0" title="0">{
        if nitro </span><span class="cov0" title="0">{
                return nitroMaxAttachments
        }</span>
        <span class="cov0" title="0">return nonNitroMaxAttachments</span>
}

// Some instance types have a maximum limit of EBS volumes
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/volume_limits.html
var maxVolumeLimits = map[string]int{
        "d3.8xlarge":    3,
        "d3en.12xlarge": 3,
        "g5.48xlarge":   9,
        "inf1.xlarge":   26,
        "inf1.2xlarge":  26,
        "inf1.6xlarge":  23,
        "inf1.24xlarge": 11,
        "mac1.metal":    16,
}

func GetEBSLimitForInstanceType(it string) (int, bool) <span class="cov0" title="0">{
        if v, ok := maxVolumeLimits[it]; ok </span><span class="cov0" title="0">{
                return v, ok
        }</span>

        <span class="cov0" title="0">highMemoryMetalRegex := `^u-[a-z0-9]+\.metal$`
        re := regexp.MustCompile(highMemoryMetalRegex)

        if ok := re.MatchString(it); ok </span><span class="cov0" title="0">{
                return highMemoryMetalInstancesMaxVolumes, true
        }</span>

        <span class="cov0" title="0">highMemoryVirtualRegex := `^u-[a-z0-9]+\.[a-z0-9]+`
        re = regexp.MustCompile(highMemoryVirtualRegex)

        if ok := re.MatchString(it); ok </span><span class="cov0" title="0">{
                return highMemoryVirtualInstancesMaxVolumes, true
        }</span>

        <span class="cov0" title="0">bareMetalRegex := `[a-z0-9]+\.metal$`
        re = regexp.MustCompile(bareMetalRegex)

        if ok := re.MatchString(it); ok </span><span class="cov0" title="0">{
                return baremetalMaxVolumes, true
        }</span>

        <span class="cov0" title="0">return 0, false</span>
}

func GetDedicatedLimitForInstanceType(it string) int <span class="cov0" title="0">{
        if limit, ok := dedicatedVolumeLimits[it]; ok </span><span class="cov0" title="0">{
                return limit
        }</span> else<span class="cov0" title="0"> {
                return 0
        }</span>
}

// GetReservedSlotsForInstanceType calculates how many attachment slots are already used up by other devices on shared EBS volume limit instances.
func GetReservedSlotsForInstanceType(it string) int <span class="cov0" title="0">{
        total := 0
        nvmeInstanceStoreVolumes, ok := nvmeInstanceStoreVolumes[it]
        if ok </span><span class="cov0" title="0">{
                total += nvmeInstanceStoreVolumes
        }</span>
        <span class="cov0" title="0">gpus, ok := gpuInstanceGpus[it]
        if ok </span><span class="cov0" title="0">{
                total += gpus
        }</span>
        <span class="cov0" title="0">acceleratorSlots, ok := acceleratorSlotsTaken[it]
        if ok </span><span class="cov0" title="0">{
                total += acceleratorSlots
        }</span>
        <span class="cov0" title="0">return total</span>
}

// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-store-volumes.html
// IMDS does not provide NVMe instance store data; we'll just list all instances here
// g5.48xlarge and p4d.24xlarge are not added to this table as they are in the maxVolumeLimits.
var nvmeInstanceStoreVolumes = map[string]int{
        "c1.medium":        1,
        "c1.xlarge":        4,
        "c3.2xlarge":       2,
        "c3.4xlarge":       2,
        "c3.8xlarge":       2,
        "c3.large":         2,
        "c3.xlarge":        2,
        "c5ad.12xlarge":    2,
        "c5ad.16xlarge":    2,
        "c5ad.24xlarge":    2,
        "c5ad.2xlarge":     1,
        "c5ad.4xlarge":     2,
        "c5ad.8xlarge":     2,
        "c5ad.large":       1,
        "c5ad.xlarge":      1,
        "c5d.12xlarge":     2,
        "c5d.18xlarge":     2,
        "c5d.24xlarge":     4,
        "c5d.2xlarge":      1,
        "c5d.4xlarge":      1,
        "c5d.9xlarge":      1,
        "c5d.large":        1,
        "c5d.metal":        4,
        "c5d.xlarge":       1,
        "c6gd.12xlarge":    2,
        "c6gd.16xlarge":    2,
        "c6gd.2xlarge":     1,
        "c6gd.4xlarge":     1,
        "c6gd.8xlarge":     1,
        "c6gd.large":       1,
        "c6gd.medium":      1,
        "c6gd.metal":       2,
        "c6gd.xlarge":      1,
        "c6id.12xlarge":    2,
        "c6id.16xlarge":    2,
        "c6id.24xlarge":    4,
        "c6id.2xlarge":     1,
        "c6id.32xlarge":    4,
        "c6id.4xlarge":     1,
        "c6id.8xlarge":     1,
        "c6id.large":       1,
        "c6id.metal":       4,
        "c6id.xlarge":      1,
        "c7gd.12xlarge":    2,
        "c7gd.16xlarge":    2,
        "c7gd.2xlarge":     1,
        "c7gd.4xlarge":     1,
        "c7gd.8xlarge":     1,
        "c7gd.large":       1,
        "c7gd.medium":      1,
        "c7gd.metal":       2,
        "c7gd.xlarge":      1,
        "d2.2xlarge":       6,
        "d2.4xlarge":       12,
        "d2.8xlarge":       24,
        "d2.xlarge":        3,
        "d3.2xlarge":       6,
        "d3.4xlarge":       12,
        "d3.8xlarge":       24,
        "d3en.12xlarge":    24,
        "d3en.2xlarge":     4,
        "d3en.4xlarge":     8,
        "d3en.6xlarge":     12,
        "d3en.8xlarge":     16,
        "d3en.xlarge":      2,
        "d3.xlarge":        3,
        "dl1.24xlarge":     4,
        "f1.16xlarge":      4,
        "f1.2xlarge":       1,
        "f1.4xlarge":       1,
        "f2.12xlarge":      2,
        "f2.48xlarge":      8,
        "f2.6xlarge":       1,
        "g4ad.16xlarge":    2,
        "g4ad.2xlarge":     1,
        "g4ad.4xlarge":     1,
        "g4ad.8xlarge":     1,
        "g4ad.xlarge":      1,
        "g4dn.12xlarge":    1,
        "g4dn.16xlarge":    1,
        "g4dn.2xlarge":     1,
        "g4dn.4xlarge":     1,
        "g4dn.8xlarge":     1,
        "g4dn.metal":       2,
        "g4dn.xlarge":      1,
        "g5.12xlarge":      1,
        "g5.16xlarge":      1,
        "g5.24xlarge":      1,
        "g5.2xlarge":       1,
        "g5.4xlarge":       1,
        "g5.8xlarge":       1,
        "g5.xlarge":        1,
        "g6.12xlarge":      4,
        "g6.16xlarge":      2,
        "g6.24xlarge":      4,
        "g6.2xlarge":       1,
        "g6.48xlarge":      8,
        "g6.4xlarge":       1,
        "g6.8xlarge":       2,
        "g6e.12xlarge":     2,
        "g6e.16xlarge":     2,
        "g6e.24xlarge":     2,
        "g6e.2xlarge":      1,
        "g6e.48xlarge":     4,
        "g6e.4xlarge":      1,
        "g6e.8xlarge":      2,
        "g6e.xlarge":       1,
        "g6.xlarge":        1,
        "gd.12xlarge":      2,
        "gr6.4xlarge":      1,
        "gr6.8xlarge":      2,
        "h1.16xlarge":      8,
        "h1.2xlarge":       1,
        "h1.4xlarge":       2,
        "h1.8xlarge":       4,
        "hpc6id.32xlarge":  4,
        "i2.2xlarge":       2,
        "i2.4xlarge":       4,
        "i2.8xlarge":       8,
        "i2.xlarge":        1,
        "i3.16xlarge":      8,
        "i3.2xlarge":       1,
        "i3.4xlarge":       2,
        "i3.8xlarge":       4,
        "i3en.12xlarge":    4,
        "i3en.24xlarge":    8,
        "i3en.2xlarge":     2,
        "i3en.3xlarge":     1,
        "i3en.6xlarge":     2,
        "i3en.large":       1,
        "i3en.metal":       8,
        "i3en.xlarge":      1,
        "i3.large":         1,
        "i3.metal":         8,
        "i3.xlarge":        1,
        "i4g.16xlarge":     4,
        "i4g.2xlarge":      1,
        "i4g.4xlarge":      1,
        "i4g.8xlarge":      2,
        "i4g.large":        1,
        "i4g.xlarge":       1,
        "i4i.12xlarge":     3,
        "i4i.16xlarge":     4,
        "i4i.24xlarge":     6,
        "i4i.2xlarge":      1,
        "i4i.32xlarge":     8,
        "i4i.4xlarge":      1,
        "i4i.8xlarge":      2,
        "i4i.large":        1,
        "i4i.metal":        8,
        "i4i.xlarge":       1,
        "i7ie.12xlarge":    4,
        "i7ie.18xlarge":    6,
        "i7ie.24xlarge":    8,
        "i7ie.2xlarge":     2,
        "i7ie.3xlarge":     1,
        "i7ie.48xlarge":    16,
        "i7ie.6xlarge":     2,
        "i7ie.large":       1,
        "i7ie.xlarge":      1,
        "i8g.12xlarge":     3,
        "i8g.16xlarge":     4,
        "i8g.24xlarge":     6,
        "i8g.2xlarge":      1,
        "i8g.4xlarge":      1,
        "i8g.8xlarge":      2,
        "i8g.large":        1,
        "i8g.metal-24xl":   6,
        "i8g.xlarge":       1,
        "im4gn.16xlarge":   4,
        "im4gn.2xlarge":    1,
        "im4gn.4xlarge":    1,
        "im4gn.8xlarge":    2,
        "im4gn.large":      1,
        "im4gn.xlarge":     1,
        "is4gen.2xlarge":   1,
        "is4gen.4xlarge":   2,
        "is4gen.8xlarge":   4,
        "is4gen.large":     1,
        "is4gen.medium":    1,
        "is4gen.xlarge":    1,
        "m1.large":         2,
        "m1.medium":        1,
        "m1.small":         1,
        "m1.xlarge":        4,
        "m2.2xlarge":       1,
        "m2.4xlarge":       2,
        "m2.xlarge":        1,
        "m3.2xlarge":       2,
        "m3.large":         1,
        "m3.medium":        1,
        "m3.xlarge":        2,
        "m5ad.12xlarge":    2,
        "m5ad.16xlarge":    4,
        "m5ad.24xlarge":    4,
        "m5ad.2xlarge":     1,
        "m5ad.4xlarge":     2,
        "m5ad.8xlarge":     2,
        "m5ad.large":       1,
        "m5ad.xlarge":      1,
        "m5d.12xlarge":     2,
        "m5d.16xlarge":     4,
        "m5d.24xlarge":     4,
        "m5d.2xlarge":      1,
        "m5d.4xlarge":      2,
        "m5d.8xlarge":      2,
        "m5d.large":        1,
        "m5d.metal":        4,
        "m5dn.12xlarge":    2,
        "m5dn.16xlarge":    4,
        "m5dn.24xlarge":    4,
        "m5dn.2xlarge":     1,
        "m5dn.4xlarge":     2,
        "m5dn.8xlarge":     2,
        "m5dn.large":       1,
        "m5dn.metal":       4,
        "m5dn.xlarge":      1,
        "m5d.xlarge":       1,
        "m6gd.12xlarge":    2,
        "m6gd.16xlarge":    2,
        "m6gd.2xlarge":     1,
        "m6gd.4xlarge":     1,
        "m6gd.8xlarge":     1,
        "m6gd.large":       1,
        "m6gd.medium":      1,
        "m6gd.metal":       2,
        "m6gd.xlarge":      1,
        "m6id.12xlarge":    2,
        "m6id.16xlarge":    2,
        "m6id.24xlarge":    4,
        "m6id.2xlarge":     1,
        "m6id.32xlarge":    4,
        "m6id.4xlarge":     1,
        "m6id.8xlarge":     1,
        "m6id.large":       1,
        "m6id.metal":       4,
        "m6idn.12xlarge":   2,
        "m6idn.16xlarge":   2,
        "m6idn.24xlarge":   4,
        "m6idn.2xlarge":    1,
        "m6idn.32xlarge":   4,
        "m6idn.4xlarge":    1,
        "m6idn.8xlarge":    1,
        "m6idn.large":      1,
        "m6idn.metal":      4,
        "m6idn.xlarge":     1,
        "m6id.xlarge":      1,
        "m7gd.12xlarge":    2,
        "m7gd.16xlarge":    2,
        "m7gd.2xlarge":     1,
        "m7gd.4xlarge":     1,
        "m7gd.8xlarge":     1,
        "m7gd.large":       1,
        "m7gd.medium":      1,
        "m7gd.metal":       2,
        "m7gd.xlarge":      1,
        "p3dn.24xlarge":    2,
        "p4de.24xlarge":    8,
        "p5.48xlarge":      8,
        "p5e.48xlarge":     8,
        "p5en.48xlarge":    8,
        "r3.2xlarge":       1,
        "r3.4xlarge":       1,
        "r3.8xlarge":       2,
        "r3.large":         1,
        "r3.xlarge":        1,
        "r5ad.12xlarge":    2,
        "r5ad.16xlarge":    4,
        "r5ad.24xlarge":    4,
        "r5ad.2xlarge":     1,
        "r5ad.4xlarge":     2,
        "r5ad.8xlarge":     2,
        "r5ad.large":       1,
        "r5ad.xlarge":      1,
        "r5d.12xlarge":     2,
        "r5d.16xlarge":     4,
        "r5d.24xlarge":     4,
        "r5d.2xlarge":      1,
        "r5d.4xlarge":      2,
        "r5d.8xlarge":      2,
        "r5d.large":        1,
        "r5d.metal":        4,
        "r5dn.12xlarge":    2,
        "r5dn.16xlarge":    4,
        "r5dn.24xlarge":    4,
        "r5dn.2xlarge":     1,
        "r5dn.4xlarge":     2,
        "r5dn.8xlarge":     2,
        "r5dn.large":       1,
        "r5dn.metal":       4,
        "r5dn.xlarge":      1,
        "r5d.xlarge":       1,
        "r6gd.12xlarge":    2,
        "r6gd.16xlarge":    2,
        "r6gd.2xlarge":     1,
        "r6gd.4xlarge":     1,
        "r6gd.8xlarge":     1,
        "r6gd.large":       1,
        "r6gd.medium":      1,
        "r6gd.metal":       2,
        "r6gd.xlarge":      1,
        "r6id.12xlarge":    2,
        "r6id.16xlarge":    2,
        "r6id.24xlarge":    4,
        "r6id.2xlarge":     1,
        "r6id.32xlarge":    4,
        "r6id.4xlarge":     1,
        "r6id.8xlarge":     1,
        "r6id.large":       1,
        "r6id.metal":       4,
        "r6idn.12xlarge":   2,
        "r6idn.16xlarge":   2,
        "r6idn.24xlarge":   4,
        "r6idn.2xlarge":    1,
        "r6idn.32xlarge":   4,
        "r6idn.4xlarge":    1,
        "r6idn.8xlarge":    1,
        "r6idn.large":      1,
        "r6idn.metal":      4,
        "r6idn.xlarge":     1,
        "r6id.xlarge":      1,
        "r7gd.12xlarge":    2,
        "r7gd.16xlarge":    2,
        "r7gd.2xlarge":     1,
        "r7gd.4xlarge":     1,
        "r7gd.8xlarge":     1,
        "r7gd.large":       1,
        "r7gd.medium":      1,
        "r7gd.metal":       2,
        "r7gd.xlarge":      1,
        "trn1.2xlarge":     1,
        "trn1.32xlarge":    4,
        "trn1n.32xlarge":   4,
        "x1.16xlarge":      1,
        "x1.32xlarge":      2,
        "x1e.16xlarge":     1,
        "x1e.2xlarge":      1,
        "x1e.32xlarge":     2,
        "x1e.4xlarge":      1,
        "x1e.8xlarge":      1,
        "x1e.xlarge":       1,
        "x2gd.12xlarge":    2,
        "x2gd.16xlarge":    2,
        "x2gd.2xlarge":     1,
        "x2gd.4xlarge":     1,
        "x2gd.8xlarge":     1,
        "x2gd.large":       1,
        "x2gd.medium":      1,
        "x2gd.metal":       2,
        "x2gd.xlarge":      1,
        "x2idn.16xlarge":   1,
        "x2idn.24xlarge":   2,
        "x2idn.32xlarge":   2,
        "x2idn.metal":      2,
        "x2iedn.16xlarge":  1,
        "x2iedn.24xlarge":  2,
        "x2iedn.2xlarge":   1,
        "x2iedn.32xlarge":  2,
        "x2iedn.4xlarge":   1,
        "x2iedn.8xlarge":   1,
        "x2iedn.metal":     2,
        "x2iedn.xlarge":    1,
        "z1d.12xlarge":     2,
        "z1d.2xlarge":      1,
        "z1d.3xlarge":      1,
        "z1d.6xlarge":      1,
        "z1d.large":        1,
        "z1d.metal":        2,
        "z1d.xlarge":       1,
        "P6-B200.48xlarge": 8,
}

// https://aws.amazon.com/ec2/instance-types
// Despite the dl1.24xlarge having Gaudi Accelerators describe instance types considers them GPUs as such that instance type is in this table
// g5.48xlarge and p4d.24xlarge are not added to this table as they are in the maxVolumeLimits.
var gpuInstanceGpus = map[string]int{
        "dl1.24xlarge":     8,
        "g3.16xlarge":      4,
        "g3.4xlarge":       1,
        "g3.8xlarge":       2,
        "g3s.xlarge":       1,
        "g4ad.16xlarge":    4,
        "g4ad.2xlarge":     1,
        "g4ad.4xlarge":     1,
        "g4ad.8xlarge":     2,
        "g4ad.xlarge":      1,
        "g4dn.12xlarge":    4,
        "g4dn.16xlarge":    1,
        "g4dn.2xlarge":     1,
        "g4dn.4xlarge":     1,
        "g4dn.8xlarge":     1,
        "g4dn.metal":       8,
        "g4dn.xlarge":      1,
        "g5.12xlarge":      4,
        "g5.16xlarge":      1,
        "g5.24xlarge":      4,
        "g5.2xlarge":       1,
        "g5.4xlarge":       1,
        "g5.8xlarge":       1,
        "g5g.16xlarge":     2,
        "g5g.2xlarge":      1,
        "g5g.4xlarge":      1,
        "g5g.8xlarge":      1,
        "g5g.metal":        2,
        "g5g.xlarge":       1,
        "g5.xlarge":        1,
        "g6.12xlarge":      4,
        "g6.16xlarge":      1,
        "g6.24xlarge":      4,
        "g6.2xlarge":       1,
        "g6.48xlarge":      8,
        "g6.4xlarge":       1,
        "g6.8xlarge":       1,
        "g6e.12xlarge":     4,
        "g6e.16xlarge":     1,
        "g6e.24xlarge":     4,
        "g6e.2xlarge":      1,
        "g6e.48xlarge":     8,
        "g6e.4xlarge":      1,
        "g6e.8xlarge":      1,
        "g6e.xlarge":       1,
        "g6.xlarge":        1,
        "gr6.4xlarge":      1,
        "gr6.8xlarge":      1,
        "p2.16xlarge":      16,
        "p2.8xlarge":       8,
        "p2.xlarge":        1,
        "p3.16xlarge":      8,
        "p3.2xlarge":       1,
        "p3.8xlarge":       4,
        "p3dn.24xlarge":    8,
        "p4de.24xlarge":    8,
        "p5.48xlarge":      8,
        "p5e.48xlarge":     8,
        "p5en.48xlarge":    8,
        "p6-b200.48xlarge": 8,
}

// Note this table is not a reflection of how many accelerators an instance has but of how many slots their combined accelerators take up
// VT instance type accelerators take two slots each with the exception of the vt1.24xlarge which takes 0 slots for its accelerators
// inf1 instance types are purposely not added to this table as they are in the maxVolumeLimits table
// https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/volume_limits.html
var acceleratorSlotsTaken = map[string]int{
        "vt1.3xlarge":    2,
        "vt1.6xlarge":    4,
        "vt1.24xlarge":   0,
        "dl2q.24xlarge":  8,
        "inf2.xlarge":    1,
        "inf2.8xlarge":   1,
        "inf2.24xlarge":  6,
        "inf2.48xlarge":  12,
        "trn1.2xlarge":   1,
        "trn1.32xlarge":  16,
        "trn1n.32xlarge": 16,
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package coalescer combines multiple requests made over a period of time into a single request
package coalescer

import (
        "time"

        "k8s.io/klog/v2"
)

// Coalescer is an interface to combine multiple requests made over a period of time into a single request
//
// When a request is received that matches an existing in-flight request, the coalescer will attempt to
// merge that request into the existing request pool using the provided mergeFunction
//
// When the delay on the request expires (determined by the time the first request comes in), the merged
// input is passed to the execution function, and the result to all waiting callers (those that were
// not rejected during the merge step).
type Coalescer[InputType any, ResultType any] interface {
        // Coalesce is a function to coalesce a given input
        // key = only requests with this same key will be coalesced (such as volume ID)
        // input = input to merge with other inputs
        // It is NOT guaranteed all callers receive the same result (for example, if
        // an input fails to merge, only that caller will receive an error)
        Coalesce(key string, input InputType) (ResultType, error)
}

// New is a function to creates a new coalescer and immediately begin processing requests
// delay = the time to wait for other requests to coalesce before executing
// mergeFunction = a function to merge a new input with the existing inputs
// (should return an error if the new input cannot be combined with the existing inputs,
// otherwise return the new merged input)
// executeFunction = the function to call when the delay expires.
func New[InputType any, ResultType any](delay time.Duration,
        mergeFunction func(input InputType, existing InputType) (InputType, error),
        executeFunction func(key string, input InputType) (ResultType, error),
) Coalescer[InputType, ResultType] <span class="cov8" title="1">{
        c := coalescer[InputType, ResultType]{
                delay:           delay,
                mergeFunction:   mergeFunction,
                executeFunction: executeFunction,
                inputChannel:    make(chan newInput[InputType, ResultType]),
                timerChannel:    make(chan string),
                pendingInputs:   make(map[string]pendingInput[InputType, ResultType]),
        }

        go c.coalescerThread()
        return &amp;c
}</span>

// Type to store a result or error in channels.
type result[ResultType any] struct {
        result ResultType
        err    error
}

// Type to send inputs from Coalesce() to coalescerThread() via channel
// Includes a return channel for the result.
type newInput[InputType any, ResultType any] struct {
        key           string
        input         InputType
        resultChannel chan result[ResultType]
}

// Type to store pending inputs in the input map.
type pendingInput[InputType any, ResultType any] struct {
        input          InputType
        resultChannels []chan result[ResultType]
}

type coalescer[InputType any, ResultType any] struct {
        delay           time.Duration
        mergeFunction   func(input InputType, existing InputType) (InputType, error)
        executeFunction func(key string, input InputType) (ResultType, error)

        inputChannel chan newInput[InputType, ResultType]
        timerChannel chan string

        pendingInputs map[string]pendingInput[InputType, ResultType]
}

func (c *coalescer[InputType, ResultType]) Coalesce(key string, input InputType) (ResultType, error) <span class="cov8" title="1">{
        resultChannel := make(chan result[ResultType])

        c.inputChannel &lt;- newInput[InputType, ResultType]{
                key:           key,
                input:         input,
                resultChannel: resultChannel,
        }
        result := &lt;-resultChannel

        if result.err != nil </span><span class="cov8" title="1">{
                return *new(ResultType), result.err
        }</span> else<span class="cov8" title="1"> {
                return result.result, nil
        }</span>
}

func (c *coalescer[InputType, ResultType]) coalescerThread() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case i := &lt;-c.inputChannel:<span class="cov8" title="1">
                        klog.V(7).InfoS("coalescerThread: Input received", "key", i.key, "input", i.input)
                        if pending, ok := c.pendingInputs[i.key]; ok </span><span class="cov8" title="1">{
                                klog.V(7).InfoS("coalescerThread: Input matched existing input, attempting to merge", "key", i.key)
                                newInput, err := c.mergeFunction(i.input, pending.input)

                                if err == nil </span><span class="cov8" title="1">{
                                        klog.V(7).InfoS("coalescerThread: Merged input into existing inputs", "key", i.key)
                                        pending.input = newInput
                                        pending.resultChannels = append(pending.resultChannels, i.resultChannel)
                                        c.pendingInputs[i.key] = pending
                                }</span> else<span class="cov8" title="1"> {
                                        klog.V(7).InfoS("coalescerThread: Failed to merge inputs into existing inputs", "key", i.key)
                                        i.resultChannel &lt;- result[ResultType]{
                                                err: err,
                                        }
                                }</span>
                        } else<span class="cov8" title="1"> {
                                klog.V(7).InfoS("coalescerThread: New input, setting up fresh coalesce operation", "key", i.key)
                                c.pendingInputs[i.key] = pendingInput[InputType, ResultType]{
                                        input: i.input,
                                        resultChannels: []chan result[ResultType]{
                                                i.resultChannel,
                                        },
                                }
                                time.AfterFunc(c.delay, func() </span><span class="cov8" title="1">{
                                        c.timerChannel &lt;- i.key
                                }</span>)
                        }

                case k := &lt;-c.timerChannel:<span class="cov8" title="1">
                        klog.V(7).InfoS("coalescerThread: Coalescing delay reached, spawning execution thread", "key", k)
                        pending := c.pendingInputs[k]
                        delete(c.pendingInputs, k)

                        go func() </span><span class="cov8" title="1">{
                                r, err := c.executeFunction(k, pending.input)
                                klog.V(7).InfoS("coalescerThread: Finished executing", "key", k, "result", r, "error", err)
                                result := result[ResultType]{
                                        result: r,
                                        err:    err,
                                }
                                for _, c := range pending.resultChannels </span><span class="cov8" title="1">{
                                        c &lt;- result
                                }</span>
                        }()
                }
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import "time"

// constants of keys in PublishContext.
const (
        // devicePathKey represents key for device path in PublishContext
        // devicePath is the device path where the volume is attached to.
        DevicePathKey = "devicePath"
)

// constants of keys in VolumeContext.
const (
        // VolumeAttributePartition represents key for partition config in VolumeContext
        // this represents the partition number on a device used to mount.
        VolumeAttributePartition = "partition"
)

// constants of keys in volume parameters.
const (
        // VolumeTypeKey represents key for volume type.
        VolumeTypeKey = "type"

        // IopsPerGBKey represents key for IOPS per GB.
        IopsPerGBKey = "iopspergb"

        // AllowAutoIOPSPerGBIncreaseKey represents key for allowing automatic increase of IOPS.
        AllowAutoIOPSPerGBIncreaseKey = "allowautoiopspergbincrease"

        // VolumeInitializationRateKey represents key for volume initialization rate when creating volumes from snapshots.
        VolumeInitializationRateKey = "volumeinitializationrate"

        // Iops represents key for IOPS for volume.
        IopsKey = "iops"

        // ThroughputKey represents key for throughput.
        ThroughputKey = "throughput"

        // EncryptedKey represents key for whether filesystem is encrypted.
        EncryptedKey = "encrypted"

        // KmsKeyId represents key for KMS encryption key.
        KmsKeyIDKey = "kmskeyid"

        // PVCNameKey contains name of the PVC for which is a volume provisioned.
        PVCNameKey = "csi.storage.k8s.io/pvc/name"

        // PVCNamespaceKey contains namespace of the PVC for which is a volume provisioned.
        PVCNamespaceKey = "csi.storage.k8s.io/pvc/namespace"

        // PVNameKey contains name of the final PV that will be used for the dynamically
        // provisioned volume.
        PVNameKey = "csi.storage.k8s.io/pv/name"

        // VolumeSnapshotNameKey contains name of the snapshot.
        VolumeSnapshotNameKey = "csi.storage.k8s.io/volumesnapshot/name"

        // VolumeSnapshotNamespaceKey contains namespace of the snapshot.
        VolumeSnapshotNamespaceKey = "csi.storage.k8s.io/volumesnapshot/namespace"

        // VolumeSnapshotCotentNameKey contains name of the VolumeSnapshotContent that is the source
        // for the snapshot.
        VolumeSnapshotContentNameKey = "csi.storage.k8s.io/volumesnapshotcontent/name"

        // BlockExpressKey increases the iops limit for io2 volumes to the block express limit.
        BlockExpressKey = "blockexpress"

        // FSTypeKey configures the file system type that will be formatted during volume creation.
        FSTypeKey = "csi.storage.k8s.io/fstype"

        // BlockSizeKey configures the block size when formatting a volume.
        BlockSizeKey = "blocksize"

        // InodeSizeKey configures the inode size when formatting a volume.
        InodeSizeKey = "inodesize"

        // BytesPerInodeKey configures the `bytes-per-inode` when formatting a volume.
        BytesPerInodeKey = "bytesperinode"

        // NumberOfInodesKey configures the `number-of-inodes` when formatting a volume.
        NumberOfInodesKey = "numberofinodes"

        // Ext4ClusterSizeKey enables the bigalloc option when formatting an ext4 volume.
        Ext4BigAllocKey = "ext4bigalloc"

        // Ext4ClusterSizeKey configures the cluster size when formatting an ext4 volume with the bigalloc option enabled.
        Ext4ClusterSizeKey = "ext4clustersize"

        // TagKeyPrefix contains the prefix of a volume parameter that designates it as
        // a tag to be attached to the resource.
        TagKeyPrefix = "tagSpecification"

        // OutpostArn represents key for outpost's arn.
        OutpostArnKey = "outpostarn"
)

// constants of keys in snapshot parameters.
const (
        // FastSnapShotRestoreAvailabilityZones represents key for fast snapshot restore availability zones.
        FastSnapshotRestoreAvailabilityZones = "fastsnapshotrestoreavailabilityzones"
)

// constants for volume tags and their values.
const (
        // ResourceLifecycleTagPrefix is prefix of tag for provisioned EBS volume that
        // marks them as owned by the cluster. Used only when --cluster-id is set.
        ResourceLifecycleTagPrefix = "kubernetes.io/cluster/"

        // ResourceLifecycleOwned is the value we use when tagging resources to indicate
        // that the resource is considered owned and managed by the cluster,
        // and in particular that the lifecycle is tied to the lifecycle of the cluster.
        // From k8s.io/legacy-cloud-providers/aws/tags.go.
        ResourceLifecycleOwned = "owned"

        // NameTag is tag applied to provisioned EBS volume for backward compatibility with
        // in-tree volume plugin. Used only when --cluster-id is set.
        NameTag = "Name"

        // KubernetesClusterTag is tag applied to provisioned EBS volume for backward compatibility with
        // in-tree volume plugin. Used only when --cluster-id is set.
        // See https://github.com/kubernetes/cloud-provider-aws/blob/release-1.20/pkg/providers/v1/tags.go#L38-L41.
        KubernetesClusterTag = "KubernetesCluster"

        // PVCNameTag is tag applied to provisioned EBS volume for backward compatibility
        // with in-tree volume plugin. Value of the tag is PVC name. It is applied only when
        // the external provisioner sidecar is started with --extra-create-metadata=true and
        // thus provides such metadata to the CSI driver.
        PVCNameTag = "kubernetes.io/created-for/pvc/name"

        // PVCNamespaceTag is tag applied to provisioned EBS volume for backward compatibility
        // with in-tree volume plugin. Value of the tag is PVC namespace. It is applied only when
        // the external provisioner sidecar is started with --extra-create-metadata=true and
        // thus provides such metadata to the CSI driver.
        PVCNamespaceTag = "kubernetes.io/created-for/pvc/namespace"

        // PVNameTag is tag applied to provisioned EBS volume for backward compatibility
        // with in-tree volume plugin. Value of the tag is PV name. It is applied only when
        // the external provisioner sidecar is started with --extra-create-metadata=true and
        // thus provides such metadata to the CSI driver.
        PVNameTag = "kubernetes.io/created-for/pv/name"
)

// constants for default command line flag values.
const (
        DefaultCSIEndpoint                       = "unix://tmp/csi.sock"
        DefaultModifyVolumeRequestHandlerTimeout = 2 * time.Second
)

// constants for fstypes.
const (
        // FSTypeExt3 represents the ext3 filesystem type.
        FSTypeExt3 = "ext3"
        // FSTypeExt4 represents the ext4 filesystem type.
        FSTypeExt4 = "ext4"
        // FSTypeXfs represents the xfs filesystem type.
        FSTypeXfs = "xfs"
        // FSTypeNtfs represents the ntfs filesystem type.
        FSTypeNtfs = "ntfs"
)

// constants for node k8s API use.
const (
        // AgentNotReadyNodeTaintKey contains the key of taints to be removed on driver startup.
        AgentNotReadyNodeTaintKey = "ebs.csi.aws.com/agent-not-ready"
)

type fileSystemConfig struct {
        NotSupportedParams map[string]struct{}
}

func (fsConfig fileSystemConfig) isParameterSupported(paramName string) bool <span class="cov8" title="1">{
        _, notSupported := fsConfig.NotSupportedParams[paramName]
        return !notSupported
}</span>

var (
        FileSystemConfigs = map[string]fileSystemConfig{
                FSTypeExt3: {
                        NotSupportedParams: map[string]struct{}{
                                Ext4BigAllocKey:    {},
                                Ext4ClusterSizeKey: {},
                        },
                },
                FSTypeExt4: {
                        NotSupportedParams: map[string]struct{}{},
                },
                FSTypeXfs: {
                        NotSupportedParams: map[string]struct{}{
                                BytesPerInodeKey:   {},
                                NumberOfInodesKey:  {},
                                Ext4BigAllocKey:    {},
                                Ext4ClusterSizeKey: {},
                        },
                },
                FSTypeNtfs: {
                        NotSupportedParams: map[string]struct{}{
                                BlockSizeKey:       {},
                                InodeSizeKey:       {},
                                BytesPerInodeKey:   {},
                                NumberOfInodesKey:  {},
                                Ext4BigAllocKey:    {},
                                Ext4ClusterSizeKey: {},
                        },
                },
        }
)
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws/arn"
        "github.com/awslabs/volume-modifier-for-k8s/pkg/rpc"
        csi "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/coalescer"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/internal"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util/template"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
        "k8s.io/klog/v2"
)

// Supported access modes.
const (
        SingleNodeWriter     = csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER
        MultiNodeMultiWriter = csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER
)

var (
        // controllerCaps represents the capability of controller service.
        controllerCaps = []csi.ControllerServiceCapability_RPC_Type{
                csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME,
                csi.ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME,
                csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT,
                csi.ControllerServiceCapability_RPC_LIST_SNAPSHOTS,
                csi.ControllerServiceCapability_RPC_EXPAND_VOLUME,
                csi.ControllerServiceCapability_RPC_MODIFY_VOLUME,
        }
)

const trueStr = "true"
const isManagedByDriver = trueStr

// ControllerService represents the controller service of CSI driver.
type ControllerService struct {
        cloud                 cloud.Cloud
        inFlight              *internal.InFlight
        options               *Options
        modifyVolumeCoalescer coalescer.Coalescer[modifyVolumeRequest, int32]
        rpc.UnimplementedModifyServer
        csi.UnimplementedControllerServer
}

// NewControllerService creates a new controller service.
func NewControllerService(c cloud.Cloud, o *Options) *ControllerService <span class="cov8" title="1">{
        return &amp;ControllerService{
                cloud:                 c,
                options:               o,
                inFlight:              internal.NewInFlight(),
                modifyVolumeCoalescer: newModifyVolumeCoalescer(c, o),
        }
}</span>

func (d *ControllerService) CreateVolume(ctx context.Context, req *csi.CreateVolumeRequest) (*csi.CreateVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("CreateVolume: called", "args", util.SanitizeRequest(req))
        if err := validateCreateVolumeRequest(req); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">volSizeBytes, err := getVolSizeBytes(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">volName := req.GetName()
        volCap := req.GetVolumeCapabilities()

        multiAttach := false
        for _, c := range volCap </span><span class="cov8" title="1">{
                if c.GetAccessMode().GetMode() == MultiNodeMultiWriter &amp;&amp; isBlock(c) </span><span class="cov8" title="1">{
                        klog.V(4).InfoS("CreateVolume: multi-attach is enabled", "volumeID", volName)
                        multiAttach = true
                }</span>
        }

        // check if a request is already in-flight
        <span class="cov8" title="1">if ok := d.inFlight.Insert(volName); !ok </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("Create volume request for %s is already in progress", volName)
                return nil, status.Error(codes.Aborted, msg)
        }</span>
        <span class="cov8" title="1">defer d.inFlight.Delete(volName)

        var (
                volumeType               string
                iopsPerGB                int32
                allowIOPSPerGBIncrease   bool
                iops                     int32
                throughput               int32
                volumeInitializationRate int32
                isEncrypted              bool
                blockExpress             bool
                kmsKeyID                 string
                tagsToEvaluate           = make([]string, 0)
                volumeTags               = map[string]string{
                        cloud.VolumeNameTagKey:   volName,
                        cloud.AwsEbsDriverTagKey: isManagedByDriver,
                }
                blockSize       string
                inodeSize       string
                bytesPerInode   string
                numberOfInodes  string
                ext4BigAlloc    bool
                ext4ClusterSize string
        )

        tProps := new(template.PVProps)

        for key, value := range req.GetParameters() </span><span class="cov8" title="1">{
                switch strings.ToLower(key) </span>{
                case "fstype":<span class="cov0" title="0">
                        klog.InfoS("\"fstype\" is deprecated, please use \"csi.storage.k8s.io/fstype\" instead")</span>
                case VolumeTypeKey:<span class="cov8" title="1">
                        volumeType = value</span>
                case IopsPerGBKey:<span class="cov8" title="1">
                        parseIopsPerGBKey, parseIopsPerGBKeyErr := strconv.ParseInt(value, 10, 32)
                        if parseIopsPerGBKeyErr != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse invalid iopsPerGB: %v", parseIopsPerGBKeyErr)
                        }</span>
                        <span class="cov8" title="1">iopsPerGB = int32(parseIopsPerGBKey)</span>
                case AllowAutoIOPSPerGBIncreaseKey:<span class="cov0" title="0">
                        allowIOPSPerGBIncrease = isTrue(value)</span>
                case IopsKey:<span class="cov8" title="1">
                        parseIopsKey, parseIopsKeyErr := strconv.ParseInt(value, 10, 32)
                        if parseIopsKeyErr != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse invalid iops: %v", parseIopsKeyErr)
                        }</span>
                        <span class="cov8" title="1">iops = int32(parseIopsKey)</span>
                case VolumeInitializationRateKey:<span class="cov8" title="1">
                        parseInitRate, parseInitRateErr := strconv.ParseInt(value, 10, 32)
                        if parseInitRateErr != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse invalid volumeInitializationRate: %v", parseInitRateErr)
                        }</span>
                        <span class="cov8" title="1">volumeInitializationRate = int32(parseInitRate)</span>
                case ThroughputKey:<span class="cov8" title="1">
                        parseThroughput, parseThroughputErr := strconv.ParseInt(value, 10, 32)
                        if parseThroughputErr != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse invalid throughput: %v", parseThroughputErr)
                        }</span>
                        <span class="cov8" title="1">throughput = int32(parseThroughput)</span>
                case EncryptedKey:<span class="cov8" title="1">
                        isEncrypted = isTrue(value)</span>
                case KmsKeyIDKey:<span class="cov8" title="1">
                        kmsKeyID = value</span>
                case PVCNameKey:<span class="cov8" title="1">
                        volumeTags[PVCNameTag] = value
                        tProps.PVCName = value</span>
                case PVCNamespaceKey:<span class="cov8" title="1">
                        volumeTags[PVCNamespaceTag] = value
                        tProps.PVCNamespace = value</span>
                case PVNameKey:<span class="cov8" title="1">
                        volumeTags[PVNameTag] = value
                        tProps.PVName = value</span>
                case BlockExpressKey:<span class="cov8" title="1">
                        blockExpress = isTrue(value)</span>
                case BlockSizeKey:<span class="cov8" title="1">
                        if isAlphanumeric := util.StringIsAlphanumeric(value); !isAlphanumeric </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse blockSize (%s): %v", value, err)
                        }</span>
                        <span class="cov8" title="1">blockSize = value</span>
                case InodeSizeKey:<span class="cov8" title="1">
                        if isAlphanumeric := util.StringIsAlphanumeric(value); !isAlphanumeric </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse inodeSize (%s): %v", value, err)
                        }</span>
                        <span class="cov8" title="1">inodeSize = value</span>
                case BytesPerInodeKey:<span class="cov8" title="1">
                        if isAlphanumeric := util.StringIsAlphanumeric(value); !isAlphanumeric </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse bytesPerInode (%s): %v", value, err)
                        }</span>
                        <span class="cov8" title="1">bytesPerInode = value</span>
                case NumberOfInodesKey:<span class="cov8" title="1">
                        if isAlphanumeric := util.StringIsAlphanumeric(value); !isAlphanumeric </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse numberOfInodes (%s): %v", value, err)
                        }</span>
                        <span class="cov8" title="1">numberOfInodes = value</span>
                case Ext4BigAllocKey:<span class="cov8" title="1">
                        ext4BigAlloc = isTrue(value)</span>
                case Ext4ClusterSizeKey:<span class="cov8" title="1">
                        if isAlphanumeric := util.StringIsAlphanumeric(value); !isAlphanumeric </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse ext4ClusterSize (%s): %v", value, err)
                        }</span>
                        <span class="cov8" title="1">ext4ClusterSize = value</span>
                default:<span class="cov8" title="1">
                        if strings.HasPrefix(key, TagKeyPrefix) </span><span class="cov8" title="1">{
                                tagsToEvaluate = append(tagsToEvaluate, value)
                        }</span> else<span class="cov8" title="1"> {
                                return nil, status.Errorf(codes.InvalidArgument, "Invalid parameter key %s for CreateVolume", key)
                        }</span>
                }
        }

        <span class="cov8" title="1">mutableParameters := req.GetMutableParameters()

        // "Values specified in mutable_parameters MUST take precedence over the values from parameters."
        // https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume
        for key, value := range mutableParameters </span><span class="cov8" title="1">{
                switch key </span>{
                case IopsKey:<span class="cov8" title="1">
                        vacIops, err := strconv.ParseInt(value, 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse IOPS: %q", value)
                        }</span>
                        <span class="cov8" title="1">iops = int32(vacIops)</span>
                case ThroughputKey:<span class="cov0" title="0">
                        vacThroughput, err := strconv.ParseInt(value, 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse throughput: %q", value)
                        }</span>
                        <span class="cov0" title="0">throughput = int32(vacThroughput)</span>
                case DeprecatedModificationKeyVolumeType:<span class="cov0" title="0">
                        if _, ok := mutableParameters[ModificationKeyVolumeType]; ok </span><span class="cov0" title="0">{
                                klog.Infof("Ignoring deprecated key `volumeType` because preferred key `type` is present")
                                continue</span>
                        }
                        <span class="cov0" title="0">klog.InfoS("Key `volumeType` is deprecated, please use `type` instead")
                        volumeType = value</span>
                case VolumeTypeKey:<span class="cov0" title="0">
                        volumeType = value</span>
                default:<span class="cov0" title="0">
                        switch </span>{
                        case strings.HasPrefix(key, ModificationAddTag):<span class="cov0" title="0">
                                tagsToEvaluate = append(tagsToEvaluate, value)</span>
                        default:<span class="cov0" title="0">
                                return nil, status.Errorf(codes.InvalidArgument, "Invalid mutable parameter key: %s", key)</span>
                        }
                }
        }

        <span class="cov8" title="1">for key, value := range d.options.ExtraTags </span><span class="cov8" title="1">{
                tagsToEvaluate = append(tagsToEvaluate, key+"="+value)
        }</span>

        <span class="cov8" title="1">addTags, err := template.Evaluate(tagsToEvaluate, tProps, d.options.WarnOnInvalidTag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "Error interpolating tag value: %v", err)
        }</span>

        <span class="cov8" title="1">if err = validateExtraTags(addTags, d.options.WarnOnInvalidTag); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "Invalid tag value: %v", err)
        }</span>

        <span class="cov8" title="1">for k, v := range addTags </span><span class="cov8" title="1">{
                volumeTags[k] = v
        }</span>

        <span class="cov8" title="1">responseCtx := map[string]string{}

        if len(blockSize) &gt; 0 </span><span class="cov8" title="1">{
                responseCtx[BlockSizeKey] = blockSize
                if err = validateFormattingOption(volCap, BlockSizeKey, FileSystemConfigs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(inodeSize) &gt; 0 </span><span class="cov8" title="1">{
                responseCtx[InodeSizeKey] = inodeSize
                if err = validateFormattingOption(volCap, InodeSizeKey, FileSystemConfigs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(bytesPerInode) &gt; 0 </span><span class="cov8" title="1">{
                responseCtx[BytesPerInodeKey] = bytesPerInode
                if err = validateFormattingOption(volCap, BytesPerInodeKey, FileSystemConfigs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(numberOfInodes) &gt; 0 </span><span class="cov8" title="1">{
                responseCtx[NumberOfInodesKey] = numberOfInodes
                if err = validateFormattingOption(volCap, NumberOfInodesKey, FileSystemConfigs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if ext4BigAlloc </span><span class="cov8" title="1">{
                responseCtx[Ext4BigAllocKey] = trueStr
                if err = validateFormattingOption(volCap, Ext4BigAllocKey, FileSystemConfigs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if len(ext4ClusterSize) &gt; 0 </span><span class="cov8" title="1">{
                responseCtx[Ext4ClusterSizeKey] = ext4ClusterSize
                if err = validateFormattingOption(volCap, Ext4ClusterSizeKey, FileSystemConfigs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if !ext4BigAlloc &amp;&amp; len(ext4ClusterSize) &gt; 0 </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Cannot set ext4BigAllocClusterSize when ext4BigAlloc is false")
        }</span>

        <span class="cov8" title="1">if blockExpress &amp;&amp; volumeType != cloud.VolumeTypeIO2 </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Block Express is only supported on io2 volumes")
        }</span>

        <span class="cov8" title="1">snapshotID := ""
        volumeSource := req.GetVolumeContentSource()
        if volumeSource != nil </span><span class="cov8" title="1">{
                if _, ok := volumeSource.GetType().(*csi.VolumeContentSource_Snapshot); !ok </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, "Unsupported volumeContentSource type")
                }</span>
                <span class="cov8" title="1">sourceSnapshot := volumeSource.GetSnapshot()
                if sourceSnapshot == nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, "Error retrieving snapshot from the volumeContentSource")
                }</span>
                <span class="cov8" title="1">snapshotID = sourceSnapshot.GetSnapshotId()</span>
        }

        // create a new volume
        <span class="cov8" title="1">zone := pickAvailabilityZone(req.GetAccessibilityRequirements())
        outpostArn := getOutpostArn(req.GetAccessibilityRequirements())

        // fill volume tags
        if d.options.KubernetesClusterID != "" </span><span class="cov8" title="1">{
                resourceLifecycleTag := ResourceLifecycleTagPrefix + d.options.KubernetesClusterID
                volumeTags[resourceLifecycleTag] = ResourceLifecycleOwned
                volumeTags[NameTag] = d.options.KubernetesClusterID + "-dynamic-" + volName
                volumeTags[KubernetesClusterTag] = d.options.KubernetesClusterID
        }</span>

        <span class="cov8" title="1">opts := &amp;cloud.DiskOptions{
                CapacityBytes:            volSizeBytes,
                Tags:                     volumeTags,
                VolumeType:               volumeType,
                IOPSPerGB:                iopsPerGB,
                AllowIOPSPerGBIncrease:   allowIOPSPerGBIncrease,
                IOPS:                     iops,
                Throughput:               throughput,
                AvailabilityZone:         zone,
                OutpostArn:               outpostArn,
                Encrypted:                isEncrypted,
                BlockExpress:             blockExpress,
                KmsKeyID:                 kmsKeyID,
                SnapshotID:               snapshotID,
                MultiAttachEnabled:       multiAttach,
                VolumeInitializationRate: volumeInitializationRate,
        }

        disk, err := d.cloud.CreateDisk(ctx, volName, opts)
        if err != nil </span><span class="cov8" title="1">{
                var errCode codes.Code
                switch </span>{
                case errors.Is(err, cloud.ErrNotFound):<span class="cov0" title="0">
                        errCode = codes.NotFound</span>
                case errors.Is(err, cloud.ErrIdempotentParameterMismatch), errors.Is(err, cloud.ErrAlreadyExists):<span class="cov8" title="1">
                        errCode = codes.AlreadyExists</span>
                case errors.Is(err, cloud.ErrLimitExceeded):<span class="cov8" title="1">
                        errCode = codes.ResourceExhausted</span>
                default:<span class="cov0" title="0">
                        errCode = codes.Internal</span>
                }
                <span class="cov8" title="1">return nil, status.Errorf(errCode, "Could not create volume %q: %v", volName, err)</span>
        }
        <span class="cov8" title="1">return newCreateVolumeResponse(disk, responseCtx), nil</span>
}

func validateCreateVolumeRequest(req *csi.CreateVolumeRequest) error <span class="cov8" title="1">{
        volName := req.GetName()
        if len(volName) == 0 </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume name not provided")
        }</span>

        <span class="cov8" title="1">volCaps := req.GetVolumeCapabilities()
        if len(volCaps) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, "Volume capabilities not provided")
        }</span>

        <span class="cov8" title="1">if !isValidVolumeCapabilities(volCaps) </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume capabilities not supported")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *ControllerService) DeleteVolume(ctx context.Context, req *csi.DeleteVolumeRequest) (*csi.DeleteVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("DeleteVolume: called", "args", util.SanitizeRequest(req))
        if err := validateDeleteVolumeRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">volumeID := req.GetVolumeId()
        // check if a request is already in-flight
        if ok := d.inFlight.Insert(volumeID); !ok </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(internal.VolumeOperationAlreadyExistsErrorMsg, volumeID)
                return nil, status.Error(codes.Aborted, msg)
        }</span>
        <span class="cov8" title="1">defer d.inFlight.Delete(volumeID)

        if _, err := d.cloud.DeleteDisk(ctx, volumeID); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloud.ErrNotFound) </span><span class="cov8" title="1">{
                        klog.V(4).InfoS("DeleteVolume: volume not found, returning with success")
                        return &amp;csi.DeleteVolumeResponse{}, nil
                }</span>
                <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "Could not delete volume ID %q: %v", volumeID, err)</span>
        }

        <span class="cov8" title="1">return &amp;csi.DeleteVolumeResponse{}, nil</span>
}

func validateDeleteVolumeRequest(req *csi.DeleteVolumeRequest) error <span class="cov8" title="1">{
        if len(req.GetVolumeId()) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *ControllerService) ControllerPublishVolume(ctx context.Context, req *csi.ControllerPublishVolumeRequest) (*csi.ControllerPublishVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("ControllerPublishVolume: called", "args", util.SanitizeRequest(req))
        if err := validateControllerPublishVolumeRequest(req); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">volumeID := req.GetVolumeId()
        nodeID := req.GetNodeId()

        if !d.inFlight.Insert(volumeID + nodeID) </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Aborted, fmt.Sprintf(internal.VolumeOperationAlreadyExistsErrorMsg, volumeID))
        }</span>
        <span class="cov8" title="1">defer d.inFlight.Delete(volumeID + nodeID)

        klog.V(2).InfoS("ControllerPublishVolume: attaching", "volumeID", volumeID, "nodeID", nodeID)
        devicePath, err := d.cloud.AttachDisk(ctx, volumeID, nodeID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloud.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "Volume %q not found", volumeID)
                }</span>
                <span class="cov8" title="1">if errors.Is(err, cloud.ErrLimitExceeded) </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.ResourceExhausted, "Attachment limit exceeded for volume %q on node %q: %v", volumeID, nodeID, err)
                }</span>
                <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "Could not attach volume %q to node %q: %v", volumeID, nodeID, err)</span>
        }
        <span class="cov8" title="1">klog.InfoS("ControllerPublishVolume: attached", "volumeID", volumeID, "nodeID", nodeID, "devicePath", devicePath)

        pvInfo := map[string]string{DevicePathKey: devicePath}
        return &amp;csi.ControllerPublishVolumeResponse{PublishContext: pvInfo}, nil</span>
}

func validateControllerPublishVolumeRequest(req *csi.ControllerPublishVolumeRequest) error <span class="cov8" title="1">{
        if len(req.GetVolumeId()) == 0 </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">if len(req.GetNodeId()) == 0 </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Node ID not provided")
        }</span>

        <span class="cov8" title="1">volCap := req.GetVolumeCapability()
        if volCap == nil </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume capability not provided")
        }</span>

        <span class="cov8" title="1">if !isValidCapability(volCap) </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume capability not supported")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *ControllerService) ControllerUnpublishVolume(ctx context.Context, req *csi.ControllerUnpublishVolumeRequest) (*csi.ControllerUnpublishVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("ControllerUnpublishVolume: called", "args", util.SanitizeRequest(req))

        if err := validateControllerUnpublishVolumeRequest(req); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">volumeID := req.GetVolumeId()
        nodeID := req.GetNodeId()

        if !d.inFlight.Insert(volumeID + nodeID) </span><span class="cov8" title="1">{
                return nil, status.Error(codes.Aborted, fmt.Sprintf(internal.VolumeOperationAlreadyExistsErrorMsg, volumeID))
        }</span>
        <span class="cov8" title="1">defer d.inFlight.Delete(volumeID + nodeID)

        klog.V(2).InfoS("ControllerUnpublishVolume: detaching", "volumeID", volumeID, "nodeID", nodeID)
        if err := d.cloud.DetachDisk(ctx, volumeID, nodeID); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloud.ErrNotFound) </span><span class="cov8" title="1">{
                        klog.InfoS("ControllerUnpublishVolume: attachment not found", "volumeID", volumeID, "nodeID", nodeID)
                        return &amp;csi.ControllerUnpublishVolumeResponse{}, nil
                }</span>
                <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "Could not detach volume %q from node %q: %v", volumeID, nodeID, err)</span>
        }
        <span class="cov8" title="1">klog.InfoS("ControllerUnpublishVolume: detached", "volumeID", volumeID, "nodeID", nodeID)

        return &amp;csi.ControllerUnpublishVolumeResponse{}, nil</span>
}

func validateControllerUnpublishVolumeRequest(req *csi.ControllerUnpublishVolumeRequest) error <span class="cov8" title="1">{
        if len(req.GetVolumeId()) == 0 </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">if len(req.GetNodeId()) == 0 </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Node ID not provided")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (d *ControllerService) ControllerGetCapabilities(ctx context.Context, req *csi.ControllerGetCapabilitiesRequest) (*csi.ControllerGetCapabilitiesResponse, error) <span class="cov0" title="0">{
        klog.V(4).InfoS("ControllerGetCapabilities: called", "args", req)

        caps := make([]*csi.ControllerServiceCapability, 0, len(controllerCaps))
        for _, capability := range controllerCaps </span><span class="cov0" title="0">{
                c := &amp;csi.ControllerServiceCapability{
                        Type: &amp;csi.ControllerServiceCapability_Rpc{
                                Rpc: &amp;csi.ControllerServiceCapability_RPC{
                                        Type: capability,
                                },
                        },
                }
                caps = append(caps, c)
        }</span>
        <span class="cov0" title="0">return &amp;csi.ControllerGetCapabilitiesResponse{Capabilities: caps}, nil</span>
}

func (d *ControllerService) GetCapacity(ctx context.Context, req *csi.GetCapacityRequest) (*csi.GetCapacityResponse, error) <span class="cov0" title="0">{
        klog.V(4).InfoS("GetCapacity: called", "args", req)
        return nil, status.Error(codes.Unimplemented, "")
}</span>

func (d *ControllerService) ListVolumes(ctx context.Context, req *csi.ListVolumesRequest) (*csi.ListVolumesResponse, error) <span class="cov0" title="0">{
        klog.V(4).InfoS("ListVolumes: called", "args", req)
        return nil, status.Error(codes.Unimplemented, "")
}</span>

func (d *ControllerService) ValidateVolumeCapabilities(ctx context.Context, req *csi.ValidateVolumeCapabilitiesRequest) (*csi.ValidateVolumeCapabilitiesResponse, error) <span class="cov0" title="0">{
        klog.V(4).InfoS("ValidateVolumeCapabilities: called", "args", req)
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov0" title="0">volCaps := req.GetVolumeCapabilities()
        if len(volCaps) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Volume capabilities not provided")
        }</span>

        <span class="cov0" title="0">if _, err := d.cloud.GetDiskByID(ctx, volumeID); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, cloud.ErrNotFound) </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.NotFound, "Volume not found")
                }</span>
                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "Could not get volume with ID %q: %v", volumeID, err)</span>
        }

        <span class="cov0" title="0">var confirmed *csi.ValidateVolumeCapabilitiesResponse_Confirmed
        if isValidVolumeCapabilities(volCaps) </span><span class="cov0" title="0">{
                confirmed = &amp;csi.ValidateVolumeCapabilitiesResponse_Confirmed{VolumeCapabilities: volCaps}
        }</span>
        <span class="cov0" title="0">return &amp;csi.ValidateVolumeCapabilitiesResponse{
                Confirmed: confirmed,
        }, nil</span>
}

func (d *ControllerService) ControllerExpandVolume(ctx context.Context, req *csi.ControllerExpandVolumeRequest) (*csi.ControllerExpandVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("ControllerExpandVolume: called", "args", util.SanitizeRequest(req))
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">capRange := req.GetCapacityRange()
        if capRange == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Capacity range not provided")
        }</span>

        <span class="cov8" title="1">newSize := util.RoundUpBytes(capRange.GetRequiredBytes())
        maxVolSize := capRange.GetLimitBytes()
        if maxVolSize &gt; 0 &amp;&amp; maxVolSize &lt; newSize </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "After round-up, volume size exceeds the limit specified")
        }</span>

        <span class="cov8" title="1">actualSizeGiB, err := d.modifyVolumeCoalescer.Coalesce(volumeID, modifyVolumeRequest{
                newSize: newSize,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "Could not resize volume %q: %v", volumeID, err)
        }</span>

        <span class="cov8" title="1">nodeExpansionRequired := true
        // if this is a raw block device, no expansion should be necessary on the node
        capability := req.GetVolumeCapability()
        if capability != nil &amp;&amp; capability.GetBlock() != nil </span><span class="cov0" title="0">{
                nodeExpansionRequired = false
        }</span>

        <span class="cov8" title="1">return &amp;csi.ControllerExpandVolumeResponse{
                CapacityBytes:         util.GiBToBytes(actualSizeGiB),
                NodeExpansionRequired: nodeExpansionRequired,
        }, nil</span>
}

func (d *ControllerService) ControllerModifyVolume(ctx context.Context, req *csi.ControllerModifyVolumeRequest) (*csi.ControllerModifyVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("ControllerModifyVolume: called", "args", util.SanitizeRequest(req))

        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">options, err := parseModifyVolumeParameters(req.GetMutableParameters())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = d.modifyVolumeCoalescer.Coalesce(volumeID, modifyVolumeRequest{
                modifyDiskOptions: options.modifyDiskOptions,
                modifyTagsOptions: options.modifyTagsOptions,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;csi.ControllerModifyVolumeResponse{}, nil</span>
}

func (d *ControllerService) ControllerGetVolume(ctx context.Context, req *csi.ControllerGetVolumeRequest) (*csi.ControllerGetVolumeResponse, error) <span class="cov0" title="0">{
        klog.V(4).InfoS("ControllerGetVolume: called", "args", req)
        return nil, status.Error(codes.Unimplemented, "")
}</span>

func isValidVolumeCapabilities(v []*csi.VolumeCapability) bool <span class="cov8" title="1">{
        for _, c := range v </span><span class="cov8" title="1">{
                if !isValidCapability(c) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func isValidCapability(c *csi.VolumeCapability) bool <span class="cov8" title="1">{
        accessMode := c.GetAccessMode().GetMode()

        //nolint:exhaustive
        switch accessMode </span>{
        case SingleNodeWriter:<span class="cov8" title="1">
                return true</span>

        case MultiNodeMultiWriter:<span class="cov8" title="1">
                if isBlock(c) </span><span class="cov8" title="1">{
                        return true
                }</span> else<span class="cov8" title="1"> {
                        klog.InfoS("isValidCapability: access mode is only supported for block devices", "accessMode", accessMode)
                        return false
                }</span>

        default:<span class="cov8" title="1">
                klog.InfoS("isValidCapability: access mode is not supported", "accessMode", accessMode)
                return false</span>
        }
}

func isBlock(capability *csi.VolumeCapability) bool <span class="cov8" title="1">{
        _, isBlk := capability.GetAccessType().(*csi.VolumeCapability_Block)
        return isBlk
}</span>

func isValidVolumeContext(volContext map[string]string) bool <span class="cov8" title="1">{
        // There could be multiple volume attributes in the volumeContext map
        // Validate here case by case
        if partition, ok := volContext[VolumeAttributePartition]; ok </span><span class="cov8" title="1">{
                partitionInt, err := strconv.ParseInt(partition, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        klog.ErrorS(err, "failed to parse partition as int", "partition", partition)
                        return false
                }</span>
                <span class="cov8" title="1">if partitionInt &lt; 0 </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "invalid partition config", "partition", partition)
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (d *ControllerService) CreateSnapshot(ctx context.Context, req *csi.CreateSnapshotRequest) (*csi.CreateSnapshotResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("CreateSnapshot: called", "args", util.SanitizeRequest(req))
        if err := validateCreateSnapshotRequest(req); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">snapshotName := req.GetName()
        volumeID := req.GetSourceVolumeId()
        var outpostArn string

        // check if a request is already in-flight
        if ok := d.inFlight.Insert(snapshotName); !ok </span><span class="cov8" title="1">{
                msg := fmt.Sprintf(internal.VolumeOperationAlreadyExistsErrorMsg, snapshotName)
                return nil, status.Error(codes.Aborted, msg)
        }</span>
        <span class="cov8" title="1">defer d.inFlight.Delete(snapshotName)

        snapshot, err := d.cloud.GetSnapshotByName(ctx, snapshotName)
        if err != nil &amp;&amp; !errors.Is(err, cloud.ErrNotFound) </span><span class="cov0" title="0">{
                klog.ErrorS(err, "Error looking for the snapshot", "snapshotName", snapshotName)
                return nil, err
        }</span>
        <span class="cov8" title="1">if snapshot != nil </span><span class="cov8" title="1">{
                if snapshot.SourceVolumeID != volumeID </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.AlreadyExists, "Snapshot %s already exists for different volume (%s)", snapshotName, snapshot.SourceVolumeID)
                }</span>
                <span class="cov8" title="1">klog.V(4).InfoS("Snapshot of volume already exists; nothing to do", "snapshotName", snapshotName, "volumeId", volumeID)
                return newCreateSnapshotResponse(snapshot), nil</span>
        }

        <span class="cov8" title="1">snapshotTags := map[string]string{
                cloud.SnapshotNameTagKey: snapshotName,
                cloud.AwsEbsDriverTagKey: isManagedByDriver,
        }

        var vscTags []string
        var fsrAvailabilityZones []string
        vsProps := new(template.VolumeSnapshotProps)
        for key, value := range req.GetParameters() </span><span class="cov8" title="1">{
                switch strings.ToLower(key) </span>{
                case VolumeSnapshotNameKey:<span class="cov0" title="0">
                        vsProps.VolumeSnapshotName = value</span>
                case VolumeSnapshotNamespaceKey:<span class="cov0" title="0">
                        vsProps.VolumeSnapshotNamespace = value</span>
                case VolumeSnapshotContentNameKey:<span class="cov0" title="0">
                        vsProps.VolumeSnapshotContentName = value</span>
                case FastSnapshotRestoreAvailabilityZones:<span class="cov8" title="1">
                        f := strings.ReplaceAll(value, " ", "")
                        fsrAvailabilityZones = strings.Split(f, ",")</span>
                case OutpostArnKey:<span class="cov8" title="1">
                        if arn.IsARN(value) </span><span class="cov8" title="1">{
                                outpostArn = value
                        }</span> else<span class="cov8" title="1"> {
                                return nil, status.Errorf(codes.InvalidArgument, "Invalid parameter value %s is not a valid arn", value)
                        }</span>
                default:<span class="cov8" title="1">
                        if strings.HasPrefix(key, TagKeyPrefix) </span><span class="cov8" title="1">{
                                vscTags = append(vscTags, value)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, status.Errorf(codes.InvalidArgument, "Invalid parameter key %s for CreateSnapshot", key)
                        }</span>
                }
        }

        <span class="cov8" title="1">addTags, err := template.Evaluate(vscTags, vsProps, d.options.WarnOnInvalidTag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "Error interpolating tag value: %v", err)
        }</span>

        <span class="cov8" title="1">if err = validateExtraTags(addTags, d.options.WarnOnInvalidTag); err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "Invalid tag value: %v", err)
        }</span>

        <span class="cov8" title="1">if d.options.KubernetesClusterID != "" </span><span class="cov8" title="1">{
                resourceLifecycleTag := ResourceLifecycleTagPrefix + d.options.KubernetesClusterID
                snapshotTags[resourceLifecycleTag] = ResourceLifecycleOwned
                snapshotTags[NameTag] = d.options.KubernetesClusterID + "-dynamic-" + snapshotName
        }</span>
        <span class="cov8" title="1">for k, v := range d.options.ExtraTags </span><span class="cov8" title="1">{
                snapshotTags[k] = v
        }</span>

        <span class="cov8" title="1">for k, v := range addTags </span><span class="cov8" title="1">{
                snapshotTags[k] = v
        }</span>

        <span class="cov8" title="1">opts := &amp;cloud.SnapshotOptions{
                Tags:       snapshotTags,
                OutpostArn: outpostArn,
        }

        // Check if the availability zone is supported for fast snapshot restore
        if len(fsrAvailabilityZones) &gt; 0 </span><span class="cov8" title="1">{
                zones, err := d.cloud.AvailabilityZones(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        klog.ErrorS(err, "failed to get availability zones")
                }</span> else<span class="cov8" title="1"> {
                        klog.V(4).InfoS("Availability Zones", "zone", zones)
                        for _, az := range fsrAvailabilityZones </span><span class="cov8" title="1">{
                                if _, ok := zones[az]; !ok </span><span class="cov8" title="1">{
                                        return nil, status.Errorf(codes.InvalidArgument, "Availability zone %s is not supported for fast snapshot restore", az)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">snapshot, err = d.cloud.CreateSnapshot(ctx, volumeID, opts)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloud.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.AlreadyExists, "Snapshot %q already exists", snapshotName)
                }</span> else<span class="cov8" title="1"> if errors.Is(err, cloud.ErrLimitExceeded) </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.ResourceExhausted, "Could not create snapshot (resource exhausted) %q: %v", snapshotName, err)
                }</span>
                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "Could not create snapshot %q: %v", snapshotName, err)</span>
        }

        <span class="cov8" title="1">if len(fsrAvailabilityZones) &gt; 0 </span><span class="cov8" title="1">{
                _, err := d.cloud.EnableFastSnapshotRestores(ctx, fsrAvailabilityZones, snapshot.SnapshotID)
                if err != nil </span><span class="cov8" title="1">{
                        if _, deleteErr := d.cloud.DeleteSnapshot(ctx, snapshot.SnapshotID); deleteErr != nil </span><span class="cov0" title="0">{
                                return nil, status.Errorf(codes.Internal, "Could not delete snapshot ID %q: %v", snapshotName, deleteErr)
                        }</span>
                        <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "Failed to create Fast Snapshot Restores for snapshot ID %q: %v", snapshotName, err)</span>
                }
        }
        <span class="cov8" title="1">return newCreateSnapshotResponse(snapshot), nil</span>
}

func validateCreateSnapshotRequest(req *csi.CreateSnapshotRequest) error <span class="cov8" title="1">{
        if len(req.GetName()) == 0 </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Snapshot name not provided")
        }</span>

        <span class="cov8" title="1">if len(req.GetSourceVolumeId()) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, "Snapshot volume source ID not provided")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *ControllerService) DeleteSnapshot(ctx context.Context, req *csi.DeleteSnapshotRequest) (*csi.DeleteSnapshotResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("DeleteSnapshot: called", "args", util.SanitizeRequest(req))
        if err := validateDeleteSnapshotRequest(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">snapshotID := req.GetSnapshotId()

        // check if a request is already in-flight
        if ok := d.inFlight.Insert(snapshotID); !ok </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("DeleteSnapshot for Snapshot %s is already in progress", snapshotID)
                return nil, status.Error(codes.Aborted, msg)
        }</span>
        <span class="cov8" title="1">defer d.inFlight.Delete(snapshotID)

        if _, err := d.cloud.DeleteSnapshot(ctx, snapshotID); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloud.ErrNotFound) </span><span class="cov8" title="1">{
                        klog.V(4).InfoS("DeleteSnapshot: snapshot not found, returning with success")
                        return &amp;csi.DeleteSnapshotResponse{}, nil
                }</span>
                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "Could not delete snapshot ID %q: %v", snapshotID, err)</span>
        }

        <span class="cov8" title="1">return &amp;csi.DeleteSnapshotResponse{}, nil</span>
}

func validateDeleteSnapshotRequest(req *csi.DeleteSnapshotRequest) error <span class="cov8" title="1">{
        if len(req.GetSnapshotId()) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.InvalidArgument, "Snapshot ID not provided")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (d *ControllerService) ListSnapshots(ctx context.Context, req *csi.ListSnapshotsRequest) (*csi.ListSnapshotsResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("ListSnapshots: called", "args", util.SanitizeRequest(req))
        var snapshots []*cloud.Snapshot

        snapshotID := req.GetSnapshotId()
        if len(snapshotID) != 0 </span><span class="cov8" title="1">{
                snapshot, err := d.cloud.GetSnapshotByID(ctx, snapshotID)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, cloud.ErrNotFound) </span><span class="cov8" title="1">{
                                klog.V(4).InfoS("ListSnapshots: snapshot not found, returning with success")
                                return &amp;csi.ListSnapshotsResponse{}, nil
                        }</span>
                        <span class="cov8" title="1">return nil, status.Errorf(codes.Internal, "Could not get snapshot ID %q: %v", snapshotID, err)</span>
                }
                <span class="cov8" title="1">snapshots = append(snapshots, snapshot)
                response := newListSnapshotsResponse(&amp;cloud.ListSnapshotsResponse{
                        Snapshots: snapshots,
                })
                return response, nil</span>
        }

        <span class="cov8" title="1">volumeID := req.GetSourceVolumeId()
        nextToken := req.GetStartingToken()
        maxEntries := req.GetMaxEntries()

        cloudSnapshots, err := d.cloud.ListSnapshots(ctx, volumeID, maxEntries, nextToken)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, cloud.ErrNotFound) </span><span class="cov8" title="1">{
                        klog.V(4).InfoS("ListSnapshots: snapshot not found, returning with success")
                        return &amp;csi.ListSnapshotsResponse{}, nil
                }</span>
                <span class="cov8" title="1">if errors.Is(err, cloud.ErrInvalidMaxResults) </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "Error mapping MaxEntries to AWS MaxResults: %v", err)
                }</span>
                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "Could not list snapshots: %v", err)</span>
        }

        <span class="cov8" title="1">response := newListSnapshotsResponse(cloudSnapshots)
        return response, nil</span>
}

// pickAvailabilityZone selects 1 zone given topology requirement.
// if not found, empty string is returned.
func pickAvailabilityZone(requirement *csi.TopologyRequirement) string <span class="cov8" title="1">{
        if requirement == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, topology := range requirement.GetPreferred() </span><span class="cov8" title="1">{
                zone, exists := topology.GetSegments()[WellKnownZoneTopologyKey]
                if exists </span><span class="cov8" title="1">{
                        return zone
                }</span>

                <span class="cov8" title="1">zone, exists = topology.GetSegments()[ZoneTopologyKey]
                if exists </span><span class="cov8" title="1">{
                        return zone
                }</span>
        }
        <span class="cov8" title="1">for _, topology := range requirement.GetRequisite() </span><span class="cov8" title="1">{
                zone, exists := topology.GetSegments()[WellKnownZoneTopologyKey]
                if exists </span><span class="cov8" title="1">{
                        return zone
                }</span>
                <span class="cov8" title="1">zone, exists = topology.GetSegments()[ZoneTopologyKey]
                if exists </span><span class="cov8" title="1">{
                        return zone
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func getOutpostArn(requirement *csi.TopologyRequirement) string <span class="cov8" title="1">{
        if requirement == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, topology := range requirement.GetPreferred() </span><span class="cov8" title="1">{
                _, exists := topology.GetSegments()[AwsOutpostIDKey]
                if exists </span><span class="cov8" title="1">{
                        return BuildOutpostArn(topology.GetSegments())
                }</span>
        }
        <span class="cov8" title="1">for _, topology := range requirement.GetRequisite() </span><span class="cov8" title="1">{
                _, exists := topology.GetSegments()[AwsOutpostIDKey]
                if exists </span><span class="cov8" title="1">{
                        return BuildOutpostArn(topology.GetSegments())
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

func newCreateVolumeResponse(disk *cloud.Disk, ctx map[string]string) *csi.CreateVolumeResponse <span class="cov8" title="1">{
        var src *csi.VolumeContentSource
        if disk.SnapshotID != "" </span><span class="cov8" title="1">{
                src = &amp;csi.VolumeContentSource{
                        Type: &amp;csi.VolumeContentSource_Snapshot{
                                Snapshot: &amp;csi.VolumeContentSource_SnapshotSource{
                                        SnapshotId: disk.SnapshotID,
                                },
                        },
                }
        }</span>

        <span class="cov8" title="1">segments := map[string]string{WellKnownZoneTopologyKey: disk.AvailabilityZone}

        arn, err := arn.Parse(disk.OutpostArn)

        if err == nil </span><span class="cov8" title="1">{
                segments[AwsRegionKey] = arn.Region
                segments[AwsPartitionKey] = arn.Partition
                segments[AwsAccountIDKey] = arn.AccountID
                segments[AwsOutpostIDKey] = strings.ReplaceAll(arn.Resource, "outpost/", "")
        }</span>

        <span class="cov8" title="1">return &amp;csi.CreateVolumeResponse{
                Volume: &amp;csi.Volume{
                        VolumeId:      disk.VolumeID,
                        CapacityBytes: util.GiBToBytes(disk.CapacityGiB),
                        VolumeContext: ctx,
                        AccessibleTopology: []*csi.Topology{
                                {
                                        Segments: segments,
                                },
                        },
                        ContentSource: src,
                },
        }</span>
}

func newCreateSnapshotResponse(snapshot *cloud.Snapshot) *csi.CreateSnapshotResponse <span class="cov8" title="1">{
        ts := timestamppb.New(snapshot.CreationTime)

        return &amp;csi.CreateSnapshotResponse{
                Snapshot: &amp;csi.Snapshot{
                        SnapshotId:     snapshot.SnapshotID,
                        SourceVolumeId: snapshot.SourceVolumeID,
                        SizeBytes:      util.GiBToBytes(snapshot.Size),
                        CreationTime:   ts,
                        ReadyToUse:     snapshot.ReadyToUse,
                },
        }
}</span>

func newListSnapshotsResponse(cloudResponse *cloud.ListSnapshotsResponse) *csi.ListSnapshotsResponse <span class="cov8" title="1">{
        entries := make([]*csi.ListSnapshotsResponse_Entry, 0, len(cloudResponse.Snapshots))
        for _, snapshot := range cloudResponse.Snapshots </span><span class="cov8" title="1">{
                snapshotResponseEntry := newListSnapshotsResponseEntry(snapshot)
                entries = append(entries, snapshotResponseEntry)
        }</span>
        <span class="cov8" title="1">return &amp;csi.ListSnapshotsResponse{
                Entries:   entries,
                NextToken: cloudResponse.NextToken,
        }</span>
}

func newListSnapshotsResponseEntry(snapshot *cloud.Snapshot) *csi.ListSnapshotsResponse_Entry <span class="cov8" title="1">{
        ts := timestamppb.New(snapshot.CreationTime)

        return &amp;csi.ListSnapshotsResponse_Entry{
                Snapshot: &amp;csi.Snapshot{
                        SnapshotId:     snapshot.SnapshotID,
                        SourceVolumeId: snapshot.SourceVolumeID,
                        SizeBytes:      util.GiBToBytes(snapshot.Size),
                        CreationTime:   ts,
                        ReadyToUse:     snapshot.ReadyToUse,
                },
        }
}</span>

func getVolSizeBytes(req *csi.CreateVolumeRequest) (int64, error) <span class="cov8" title="1">{
        var volSizeBytes int64
        capRange := req.GetCapacityRange()
        if capRange == nil </span><span class="cov8" title="1">{
                volSizeBytes = cloud.DefaultVolumeSize
        }</span> else<span class="cov8" title="1"> {
                volSizeBytes = util.RoundUpBytes(capRange.GetRequiredBytes())
                maxVolSize := capRange.GetLimitBytes()
                if maxVolSize &gt; 0 &amp;&amp; maxVolSize &lt; volSizeBytes </span><span class="cov0" title="0">{
                        return 0, status.Error(codes.InvalidArgument, "After round-up, volume size exceeds the limit specified")
                }</span>
        }
        <span class="cov8" title="1">return volSizeBytes, nil</span>
}

// BuildOutpostArn returns the string representation of the outpost ARN from the given csi.TopologyRequirement.segments.
func BuildOutpostArn(segments map[string]string) string <span class="cov8" title="1">{
        if len(segments[AwsPartitionKey]) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if len(segments[AwsRegionKey]) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(segments[AwsOutpostIDKey]) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(segments[AwsAccountIDKey]) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("arn:%s:outposts:%s:%s:outpost/%s",
                segments[AwsPartitionKey],
                segments[AwsRegionKey],
                segments[AwsAccountIDKey],
                segments[AwsOutpostIDKey],
        )</span>
}

func validateFormattingOption(volumeCapabilities []*csi.VolumeCapability, paramName string, fsConfigs map[string]fileSystemConfig) error <span class="cov8" title="1">{
        for _, volCap := range volumeCapabilities </span><span class="cov8" title="1">{
                if isBlock(volCap) </span><span class="cov0" title="0">{
                        return status.Error(codes.InvalidArgument, fmt.Sprintf("Cannot use %s with block volume", paramName))
                }</span>

                <span class="cov8" title="1">mountVolume := volCap.GetMount()
                if mountVolume == nil </span><span class="cov0" title="0">{
                        return status.Error(codes.InvalidArgument, "CreateVolume: mount is nil within volume capability")
                }</span>

                <span class="cov8" title="1">fsType := mountVolume.GetFsType()
                if supported := fsConfigs[fsType].isParameterSupported(paramName); !supported </span><span class="cov0" title="0">{
                        return status.Errorf(codes.InvalidArgument, "Cannot use %s with fstype %s", paramName, fsType)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func isTrue(value string) bool <span class="cov8" title="1">{
        return value == trueStr
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "context"
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "time"

        "github.com/awslabs/volume-modifier-for-k8s/pkg/rpc"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/coalescer"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util/template"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "k8s.io/klog/v2"
)

const (
        ModificationKeyVolumeType = "type"
        // Retained for backwards compatibility, but not recommended.
        DeprecatedModificationKeyVolumeType = "volumeType"

        ModificationKeyIOPS = "iops"

        ModificationKeyThroughput = "throughput"

        ModificationAddTag = "tagSpecification"

        ModificationDeleteTag = "tagDeletion"
)

type modifyVolumeRequest struct {
        newSize           int64
        modifyDiskOptions cloud.ModifyDiskOptions
        modifyTagsOptions cloud.ModifyTagsOptions
}

func (d *ControllerService) GetCSIDriverModificationCapability(
        _ context.Context,
        _ *rpc.GetCSIDriverModificationCapabilityRequest,
) (*rpc.GetCSIDriverModificationCapabilityResponse, error) <span class="cov0" title="0">{
        return &amp;rpc.GetCSIDriverModificationCapabilityResponse{}, nil
}</span>

func (d *ControllerService) ModifyVolumeProperties(
        ctx context.Context,
        req *rpc.ModifyVolumePropertiesRequest,
) (*rpc.ModifyVolumePropertiesResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("ModifyVolumeProperties called", "req", req)
        name := req.GetName()
        if name == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Volume name not provided")
        }</span>

        <span class="cov8" title="1">options, err := parseModifyVolumeParameters(req.GetParameters())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = d.modifyVolumeCoalescer.Coalesce(name, *options)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;rpc.ModifyVolumePropertiesResponse{}, nil</span>
}

func newModifyVolumeCoalescer(c cloud.Cloud, o *Options) coalescer.Coalescer[modifyVolumeRequest, int32] <span class="cov8" title="1">{
        return coalescer.New[modifyVolumeRequest, int32](o.ModifyVolumeRequestHandlerTimeout, mergeModifyVolumeRequest, executeModifyVolumeRequest(c))
}</span>

func mergeModifyVolumeRequest(input modifyVolumeRequest, existing modifyVolumeRequest) (modifyVolumeRequest, error) <span class="cov8" title="1">{
        if input.newSize != 0 </span><span class="cov8" title="1">{
                if existing.newSize != 0 &amp;&amp; input.newSize != existing.newSize </span><span class="cov8" title="1">{
                        return existing, fmt.Errorf("different size was requested by a previous request. Current: %d, Requested: %d", existing.newSize, input.newSize)
                }</span>
                <span class="cov8" title="1">existing.newSize = input.newSize</span>
        }
        <span class="cov8" title="1">if input.modifyDiskOptions.IOPS != 0 </span><span class="cov8" title="1">{
                if existing.modifyDiskOptions.IOPS != 0 &amp;&amp; input.modifyDiskOptions.IOPS != existing.modifyDiskOptions.IOPS </span><span class="cov8" title="1">{
                        return existing, fmt.Errorf("different IOPS was requested by a previous request. Current: %d, Requested: %d", existing.modifyDiskOptions.IOPS, input.modifyDiskOptions.IOPS)
                }</span>
                <span class="cov0" title="0">existing.modifyDiskOptions.IOPS = input.modifyDiskOptions.IOPS</span>
        }
        <span class="cov8" title="1">if input.modifyDiskOptions.Throughput != 0 </span><span class="cov8" title="1">{
                if existing.modifyDiskOptions.Throughput != 0 &amp;&amp; input.modifyDiskOptions.Throughput != existing.modifyDiskOptions.Throughput </span><span class="cov8" title="1">{
                        return existing, fmt.Errorf("different throughput was requested by a previous request. Current: %d, Requested: %d", existing.modifyDiskOptions.Throughput, input.modifyDiskOptions.Throughput)
                }</span>
                <span class="cov0" title="0">existing.modifyDiskOptions.Throughput = input.modifyDiskOptions.Throughput</span>
        }
        <span class="cov8" title="1">if input.modifyDiskOptions.VolumeType != "" </span><span class="cov8" title="1">{
                if existing.modifyDiskOptions.VolumeType != "" &amp;&amp; input.modifyDiskOptions.VolumeType != existing.modifyDiskOptions.VolumeType </span><span class="cov8" title="1">{
                        return existing, fmt.Errorf("different volume type was requested by a previous request. Current: %s, Requested: %s", existing.modifyDiskOptions.VolumeType, input.modifyDiskOptions.VolumeType)
                }</span>
                <span class="cov8" title="1">existing.modifyDiskOptions.VolumeType = input.modifyDiskOptions.VolumeType</span>
        }
        <span class="cov8" title="1">if len(input.modifyTagsOptions.TagsToAdd) &gt; 0 || len(input.modifyTagsOptions.TagsToDelete) &gt; 0 </span><span class="cov0" title="0">{
                if (len(existing.modifyTagsOptions.TagsToAdd) &gt; 0 || len(existing.modifyTagsOptions.TagsToDelete) &gt; 0) &amp;&amp; !(reflect.DeepEqual(input.modifyTagsOptions, existing.modifyTagsOptions)) </span><span class="cov0" title="0">{
                        return existing, fmt.Errorf("different tags were requested by a previous request. Current: %v, Requested: %v", existing.modifyTagsOptions, input.modifyTagsOptions)
                }</span>
                <span class="cov0" title="0">existing.modifyTagsOptions = cloud.ModifyTagsOptions{
                        TagsToAdd:    input.modifyTagsOptions.TagsToAdd,
                        TagsToDelete: input.modifyTagsOptions.TagsToDelete,
                }</span>
        }
        <span class="cov8" title="1">return existing, nil</span>
}

func executeModifyTagsRequest(volumeID string, options modifyVolumeRequest, c cloud.Cloud, ctx context.Context) error <span class="cov8" title="1">{
        if len(options.modifyTagsOptions.TagsToAdd) &gt; 0 || len(options.modifyTagsOptions.TagsToDelete) &gt; 0 </span><span class="cov0" title="0">{
                err := c.ModifyTags(ctx, volumeID, options.modifyTagsOptions)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, cloud.ErrInvalidArgument) </span><span class="cov0" title="0">{
                                return status.Errorf(codes.InvalidArgument, "Could not modify volume tags (invalid argument) %q: %v", volumeID, err)
                        }</span>
                        <span class="cov0" title="0">return status.Errorf(codes.Internal, "Could not modify volume tags %q: %v", volumeID, err)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func executeModifyVolumeRequest(c cloud.Cloud) func(string, modifyVolumeRequest) (int32, error) <span class="cov8" title="1">{
        return func(volumeID string, req modifyVolumeRequest) (int32, error) </span><span class="cov8" title="1">{
                ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
                defer cancel()
                err := executeModifyTagsRequest(volumeID, req, c, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">if (req.modifyDiskOptions.IOPS != 0) || (req.modifyDiskOptions.Throughput != 0) || (req.modifyDiskOptions.VolumeType != "") || (req.newSize != 0) </span><span class="cov8" title="1">{
                        actualSizeGiB, err := c.ResizeOrModifyDisk(ctx, volumeID, req.newSize, &amp;req.modifyDiskOptions)
                        if err != nil </span><span class="cov8" title="1">{
                                switch </span>{
                                case errors.Is(err, cloud.ErrInvalidArgument):<span class="cov0" title="0">
                                        return 0, status.Errorf(codes.InvalidArgument, "Could not modify volume (invalid argument) %q: %v", volumeID, err)</span>
                                case errors.Is(err, cloud.ErrNotFound):<span class="cov0" title="0">
                                        return 0, status.Errorf(codes.NotFound, "Could not modify volume (not found) %q: %v", volumeID, err)</span>
                                case errors.Is(err, cloud.ErrLimitExceeded):<span class="cov0" title="0">
                                        return 0, status.Errorf(codes.ResourceExhausted, "Could not modify volume (resource exhausted) %q: %v", volumeID, err)</span>
                                default:<span class="cov8" title="1">
                                        return 0, status.Errorf(codes.Internal, "Could not modify volume %q: %v", volumeID, err)</span>
                                }
                        } else<span class="cov8" title="1"> {
                                return actualSizeGiB, nil
                        }</span>
                }
                // No change to the volume was requested, so return an empty result with no error
                <span class="cov0" title="0">return 0, nil</span>
        }
}

func parseModifyVolumeParameters(params map[string]string) (*modifyVolumeRequest, error) <span class="cov8" title="1">{
        options := modifyVolumeRequest{
                modifyTagsOptions: cloud.ModifyTagsOptions{
                        TagsToAdd:    make(map[string]string),
                        TagsToDelete: make([]string, 0),
                },
        }
        var rawTagsToAdd []string
        tProps := new(template.PVProps)
        for key, value := range params </span><span class="cov8" title="1">{
                switch key </span>{
                case ModificationKeyIOPS:<span class="cov8" title="1">
                        iops, err := strconv.ParseInt(value, 10, 32)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse IOPS: %q", value)
                        }</span>
                        <span class="cov8" title="1">options.modifyDiskOptions.IOPS = int32(iops)</span>
                case ModificationKeyThroughput:<span class="cov8" title="1">
                        throughput, err := strconv.ParseInt(value, 10, 32)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "Could not parse throughput: %q", value)
                        }</span>
                        <span class="cov8" title="1">options.modifyDiskOptions.Throughput = int32(throughput)</span>
                case DeprecatedModificationKeyVolumeType:<span class="cov8" title="1">
                        if _, ok := params[ModificationKeyVolumeType]; ok </span><span class="cov8" title="1">{
                                klog.Infof("Ignoring deprecated key `volumeType` because preferred key `type` is present")
                                continue</span>
                        }
                        <span class="cov0" title="0">klog.InfoS("Key `volumeType` is deprecated, please use `type` instead")
                        options.modifyDiskOptions.VolumeType = value</span>
                case ModificationKeyVolumeType:<span class="cov8" title="1">
                        options.modifyDiskOptions.VolumeType = value</span>
                case PVCNameKey:<span class="cov8" title="1">
                        tProps.PVCName = value</span>
                case PVCNamespaceKey:<span class="cov8" title="1">
                        tProps.PVCNamespace = value</span>
                case PVNameKey:<span class="cov8" title="1">
                        tProps.PVName = value</span>
                default:<span class="cov8" title="1">
                        switch </span>{
                        case strings.HasPrefix(key, ModificationAddTag):<span class="cov8" title="1">
                                rawTagsToAdd = append(rawTagsToAdd, value)</span>
                        case strings.HasPrefix(key, ModificationDeleteTag):<span class="cov8" title="1">
                                options.modifyTagsOptions.TagsToDelete = append(options.modifyTagsOptions.TagsToDelete, value)</span>
                        default:<span class="cov8" title="1">
                                return nil, status.Errorf(codes.InvalidArgument, "Invalid mutable parameter key: %s", key)</span>
                        }
                }
        }
        <span class="cov8" title="1">addTags, err := template.Evaluate(rawTagsToAdd, tProps, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Error interpolating tag value: %v", err)
        }</span>
        <span class="cov8" title="1">if err := validateExtraTags(addTags, false); err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "Invalid tag value: %v", err)
        }</span>
        <span class="cov8" title="1">options.modifyTagsOptions.TagsToAdd = addTags
        return &amp;options, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "context"
        "fmt"
        "net"

        "github.com/awslabs/volume-modifier-for-k8s/pkg/rpc"
        csi "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/mounter"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util"
        "go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc"
        "google.golang.org/grpc"
        "k8s.io/client-go/kubernetes"
        "k8s.io/klog/v2"
)

// Mode is the operating mode of the CSI driver.
type Mode string

const (
        // ControllerMode is the mode that only starts the controller service.
        ControllerMode Mode = "controller"
        // NodeMode is the mode that only starts the node service.
        NodeMode Mode = "node"
        // AllMode is the mode that only starts both the controller and the node service.
        AllMode Mode = "all"
)

const (
        DriverName               = "ebs.csi.aws.com"
        AwsPartitionKey          = "topology." + DriverName + "/partition"
        AwsAccountIDKey          = "topology." + DriverName + "/account-id"
        AwsRegionKey             = "topology." + DriverName + "/region"
        AwsOutpostIDKey          = "topology." + DriverName + "/outpost-id"
        WellKnownZoneTopologyKey = "topology.kubernetes.io/zone"
        // Deprecated: Use the WellKnownZoneTopologyKey instead.
        ZoneTopologyKey = "topology." + DriverName + "/zone"
        OSTopologyKey   = "kubernetes.io/os"
)

type Driver struct {
        controller *ControllerService
        node       *NodeService
        srv        *grpc.Server
        options    *Options
        csi.UnimplementedIdentityServer
}

func NewDriver(c cloud.Cloud, o *Options, m mounter.Mounter, md metadata.MetadataService, k kubernetes.Interface) (*Driver, error) <span class="cov8" title="1">{
        klog.InfoS("Driver Information", "Driver", DriverName, "Version", driverVersion)

        if err := ValidateDriverOptions(o); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid driver options: %w", err)
        }</span>

        <span class="cov8" title="1">driver := &amp;Driver{
                options: o,
        }

        switch o.Mode </span>{
        case ControllerMode:<span class="cov8" title="1">
                driver.controller = NewControllerService(c, o)</span>
        case NodeMode:<span class="cov8" title="1">
                driver.node = NewNodeService(o, md, m, k)</span>
        case AllMode:<span class="cov8" title="1">
                driver.controller = NewControllerService(c, o)
                driver.node = NewNodeService(o, md, m, k)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown mode: %s", o.Mode)</span>
        }

        <span class="cov8" title="1">return driver, nil</span>
}

func (d *Driver) Run() error <span class="cov0" title="0">{
        scheme, addr, err := util.ParseEndpoint(d.options.Endpoint, d.options.WindowsHostProcess)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">listener, err := net.Listen(scheme, addr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">logErr := func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                resp, err := handler(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "GRPC error")
                }</span>
                <span class="cov0" title="0">return resp, err</span>
        }

        <span class="cov0" title="0">opts := []grpc.ServerOption{
                grpc.UnaryInterceptor(logErr),
        }

        if d.options.EnableOtelTracing </span><span class="cov0" title="0">{
                opts = append(opts, grpc.StatsHandler(otelgrpc.NewServerHandler()))
        }</span>

        <span class="cov0" title="0">d.srv = grpc.NewServer(opts...)
        csi.RegisterIdentityServer(d.srv, d)

        switch d.options.Mode </span>{
        case ControllerMode:<span class="cov0" title="0">
                csi.RegisterControllerServer(d.srv, d.controller)
                rpc.RegisterModifyServer(d.srv, d.controller)</span>
        case NodeMode:<span class="cov0" title="0">
                csi.RegisterNodeServer(d.srv, d.node)</span>
        case AllMode:<span class="cov0" title="0">
                csi.RegisterControllerServer(d.srv, d.controller)
                csi.RegisterNodeServer(d.srv, d.node)
                rpc.RegisterModifyServer(d.srv, d.controller)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown mode: %s", d.options.Mode)</span>
        }

        <span class="cov0" title="0">klog.V(4).InfoS("Listening for connections", "address", listener.Addr())
        return d.srv.Serve(listener)</span>
}

func (d *Driver) Stop() <span class="cov0" title="0">{
        d.srv.Stop()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "context"

        csi "github.com/container-storage-interface/spec/lib/go/csi"
        "k8s.io/klog/v2"
)

func (d *Driver) GetPluginInfo(ctx context.Context, req *csi.GetPluginInfoRequest) (*csi.GetPluginInfoResponse, error) <span class="cov0" title="0">{
        klog.V(6).InfoS("GetPluginInfo: called", "args", req)
        resp := &amp;csi.GetPluginInfoResponse{
                Name:          DriverName,
                VendorVersion: driverVersion,
        }

        return resp, nil
}</span>

func (d *Driver) GetPluginCapabilities(ctx context.Context, req *csi.GetPluginCapabilitiesRequest) (*csi.GetPluginCapabilitiesResponse, error) <span class="cov0" title="0">{
        klog.V(6).InfoS("GetPluginCapabilities: called", "args", req)
        resp := &amp;csi.GetPluginCapabilitiesResponse{
                Capabilities: []*csi.PluginCapability{
                        {
                                Type: &amp;csi.PluginCapability_Service_{
                                        Service: &amp;csi.PluginCapability_Service{
                                                Type: csi.PluginCapability_Service_CONTROLLER_SERVICE,
                                        },
                                },
                        },
                        {
                                Type: &amp;csi.PluginCapability_Service_{
                                        Service: &amp;csi.PluginCapability_Service{
                                                Type: csi.PluginCapability_Service_VOLUME_ACCESSIBILITY_CONSTRAINTS,
                                        },
                                },
                        },
                },
        }

        return resp, nil
}</span>

func (d *Driver) Probe(ctx context.Context, req *csi.ProbeRequest) (*csi.ProbeResponse, error) <span class="cov0" title="0">{
        klog.V(6).InfoS("Probe: called", "args", req)
        return &amp;csi.ProbeResponse{}, nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package internal

import (
        "sync"

        "k8s.io/klog/v2"
)

// Idempotent is the interface required to manage in flight requests.
type Idempotent interface {
        // The CSI data types are generated using a protobuf.
        // The generated structures are guaranteed to implement the Stringer interface.
        // Example: https://github.com/container-storage-interface/spec/blob/master/lib/go/csi/csi.pb.go#L3508
        // We can use the generated string as the key of our internal inflight database of requests.
        String() string
}

const (
        VolumeOperationAlreadyExistsErrorMsg = "An operation with the given Volume %s already exists"
)

// InFlight is a struct used to manage in flight requests for a unique identifier.
type InFlight struct {
        mux      *sync.Mutex
        inFlight map[string]bool
}

// NewInFlight instanciates a InFlight structures.
func NewInFlight() *InFlight <span class="cov8" title="1">{
        return &amp;InFlight{
                mux:      &amp;sync.Mutex{},
                inFlight: make(map[string]bool),
        }
}</span>

// Insert inserts the entry to the current list of inflight, request key is a unique identifier.
// Returns false when the key already exists.
func (db *InFlight) Insert(key string) bool <span class="cov8" title="1">{
        db.mux.Lock()
        defer db.mux.Unlock()

        _, ok := db.inFlight[key]
        if ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">db.inFlight[key] = true
        return true</span>
}

// Delete removes the entry from the inFlight entries map.
// It doesn't return anything, and will do nothing if the specified key doesn't exist.
func (db *InFlight) Delete(key string) <span class="cov8" title="1">{
        db.mux.Lock()
        defer db.mux.Unlock()

        delete(db.inFlight, key)
        klog.V(4).InfoS("Node Service: volume operation finished", "key", key)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: k8s.io/client-go/kubernetes (interfaces: Interface)

// Package driver is a generated GoMock package.
package driver

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        discovery "k8s.io/client-go/discovery"
        v1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1"
        v1alpha1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1alpha1"
        v1beta1 "k8s.io/client-go/kubernetes/typed/admissionregistration/v1beta1"
        v1alpha10 "k8s.io/client-go/kubernetes/typed/apiserverinternal/v1alpha1"
        v10 "k8s.io/client-go/kubernetes/typed/apps/v1"
        v1beta10 "k8s.io/client-go/kubernetes/typed/apps/v1beta1"
        v1beta2 "k8s.io/client-go/kubernetes/typed/apps/v1beta2"
        v11 "k8s.io/client-go/kubernetes/typed/authentication/v1"
        v1alpha11 "k8s.io/client-go/kubernetes/typed/authentication/v1alpha1"
        v1beta11 "k8s.io/client-go/kubernetes/typed/authentication/v1beta1"
        v12 "k8s.io/client-go/kubernetes/typed/authorization/v1"
        v1beta12 "k8s.io/client-go/kubernetes/typed/authorization/v1beta1"
        v13 "k8s.io/client-go/kubernetes/typed/autoscaling/v1"
        v2 "k8s.io/client-go/kubernetes/typed/autoscaling/v2"
        v2beta1 "k8s.io/client-go/kubernetes/typed/autoscaling/v2beta1"
        v2beta2 "k8s.io/client-go/kubernetes/typed/autoscaling/v2beta2"
        v14 "k8s.io/client-go/kubernetes/typed/batch/v1"
        v1beta13 "k8s.io/client-go/kubernetes/typed/batch/v1beta1"
        v15 "k8s.io/client-go/kubernetes/typed/certificates/v1"
        v1alpha12 "k8s.io/client-go/kubernetes/typed/certificates/v1alpha1"
        v1beta14 "k8s.io/client-go/kubernetes/typed/certificates/v1beta1"
        v16 "k8s.io/client-go/kubernetes/typed/coordination/v1"
        v1alpha2 "k8s.io/client-go/kubernetes/typed/coordination/v1alpha2"
        v1beta15 "k8s.io/client-go/kubernetes/typed/coordination/v1beta1"
        v17 "k8s.io/client-go/kubernetes/typed/core/v1"
        v18 "k8s.io/client-go/kubernetes/typed/discovery/v1"
        v1beta16 "k8s.io/client-go/kubernetes/typed/discovery/v1beta1"
        v19 "k8s.io/client-go/kubernetes/typed/events/v1"
        v1beta17 "k8s.io/client-go/kubernetes/typed/events/v1beta1"
        v1beta18 "k8s.io/client-go/kubernetes/typed/extensions/v1beta1"
        v110 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1"
        v1beta19 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta1"
        v1beta20 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta2"
        v1beta3 "k8s.io/client-go/kubernetes/typed/flowcontrol/v1beta3"
        v111 "k8s.io/client-go/kubernetes/typed/networking/v1"
        v1alpha13 "k8s.io/client-go/kubernetes/typed/networking/v1alpha1"
        v1beta110 "k8s.io/client-go/kubernetes/typed/networking/v1beta1"
        v112 "k8s.io/client-go/kubernetes/typed/node/v1"
        v1alpha14 "k8s.io/client-go/kubernetes/typed/node/v1alpha1"
        v1beta111 "k8s.io/client-go/kubernetes/typed/node/v1beta1"
        v113 "k8s.io/client-go/kubernetes/typed/policy/v1"
        v1beta112 "k8s.io/client-go/kubernetes/typed/policy/v1beta1"
        v114 "k8s.io/client-go/kubernetes/typed/rbac/v1"
        v1alpha15 "k8s.io/client-go/kubernetes/typed/rbac/v1alpha1"
        v1beta113 "k8s.io/client-go/kubernetes/typed/rbac/v1beta1"
        v1alpha3 "k8s.io/client-go/kubernetes/typed/resource/v1alpha3"
        v1beta114 "k8s.io/client-go/kubernetes/typed/resource/v1beta1"
        v1beta21 "k8s.io/client-go/kubernetes/typed/resource/v1beta2"
        v115 "k8s.io/client-go/kubernetes/typed/scheduling/v1"
        v1alpha16 "k8s.io/client-go/kubernetes/typed/scheduling/v1alpha1"
        v1beta115 "k8s.io/client-go/kubernetes/typed/scheduling/v1beta1"
        v116 "k8s.io/client-go/kubernetes/typed/storage/v1"
        v1alpha17 "k8s.io/client-go/kubernetes/typed/storage/v1alpha1"
        v1beta116 "k8s.io/client-go/kubernetes/typed/storage/v1beta1"
        v1alpha18 "k8s.io/client-go/kubernetes/typed/storagemigration/v1alpha1"
)

// MockKubernetesClient is a mock of Interface interface.
type MockKubernetesClient struct {
        ctrl     *gomock.Controller
        recorder *MockKubernetesClientMockRecorder
}

// MockKubernetesClientMockRecorder is the mock recorder for MockKubernetesClient.
type MockKubernetesClientMockRecorder struct {
        mock *MockKubernetesClient
}

// NewMockKubernetesClient creates a new mock instance.
func NewMockKubernetesClient(ctrl *gomock.Controller) *MockKubernetesClient <span class="cov8" title="1">{
        mock := &amp;MockKubernetesClient{ctrl: ctrl}
        mock.recorder = &amp;MockKubernetesClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockKubernetesClient) EXPECT() *MockKubernetesClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AdmissionregistrationV1 mocks base method.
func (m *MockKubernetesClient) AdmissionregistrationV1() v1.AdmissionregistrationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AdmissionregistrationV1")
        ret0, _ := ret[0].(v1.AdmissionregistrationV1Interface)
        return ret0
}</span>

// AdmissionregistrationV1 indicates an expected call of AdmissionregistrationV1.
func (mr *MockKubernetesClientMockRecorder) AdmissionregistrationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdmissionregistrationV1", reflect.TypeOf((*MockKubernetesClient)(nil).AdmissionregistrationV1))
}</span>

// AdmissionregistrationV1alpha1 mocks base method.
func (m *MockKubernetesClient) AdmissionregistrationV1alpha1() v1alpha1.AdmissionregistrationV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AdmissionregistrationV1alpha1")
        ret0, _ := ret[0].(v1alpha1.AdmissionregistrationV1alpha1Interface)
        return ret0
}</span>

// AdmissionregistrationV1alpha1 indicates an expected call of AdmissionregistrationV1alpha1.
func (mr *MockKubernetesClientMockRecorder) AdmissionregistrationV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdmissionregistrationV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).AdmissionregistrationV1alpha1))
}</span>

// AdmissionregistrationV1beta1 mocks base method.
func (m *MockKubernetesClient) AdmissionregistrationV1beta1() v1beta1.AdmissionregistrationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AdmissionregistrationV1beta1")
        ret0, _ := ret[0].(v1beta1.AdmissionregistrationV1beta1Interface)
        return ret0
}</span>

// AdmissionregistrationV1beta1 indicates an expected call of AdmissionregistrationV1beta1.
func (mr *MockKubernetesClientMockRecorder) AdmissionregistrationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AdmissionregistrationV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).AdmissionregistrationV1beta1))
}</span>

// AppsV1 mocks base method.
func (m *MockKubernetesClient) AppsV1() v10.AppsV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AppsV1")
        ret0, _ := ret[0].(v10.AppsV1Interface)
        return ret0
}</span>

// AppsV1 indicates an expected call of AppsV1.
func (mr *MockKubernetesClientMockRecorder) AppsV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppsV1", reflect.TypeOf((*MockKubernetesClient)(nil).AppsV1))
}</span>

// AppsV1beta1 mocks base method.
func (m *MockKubernetesClient) AppsV1beta1() v1beta10.AppsV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AppsV1beta1")
        ret0, _ := ret[0].(v1beta10.AppsV1beta1Interface)
        return ret0
}</span>

// AppsV1beta1 indicates an expected call of AppsV1beta1.
func (mr *MockKubernetesClientMockRecorder) AppsV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppsV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).AppsV1beta1))
}</span>

// AppsV1beta2 mocks base method.
func (m *MockKubernetesClient) AppsV1beta2() v1beta2.AppsV1beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AppsV1beta2")
        ret0, _ := ret[0].(v1beta2.AppsV1beta2Interface)
        return ret0
}</span>

// AppsV1beta2 indicates an expected call of AppsV1beta2.
func (mr *MockKubernetesClientMockRecorder) AppsV1beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppsV1beta2", reflect.TypeOf((*MockKubernetesClient)(nil).AppsV1beta2))
}</span>

// AuthenticationV1 mocks base method.
func (m *MockKubernetesClient) AuthenticationV1() v11.AuthenticationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticationV1")
        ret0, _ := ret[0].(v11.AuthenticationV1Interface)
        return ret0
}</span>

// AuthenticationV1 indicates an expected call of AuthenticationV1.
func (mr *MockKubernetesClientMockRecorder) AuthenticationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationV1", reflect.TypeOf((*MockKubernetesClient)(nil).AuthenticationV1))
}</span>

// AuthenticationV1alpha1 mocks base method.
func (m *MockKubernetesClient) AuthenticationV1alpha1() v1alpha11.AuthenticationV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticationV1alpha1")
        ret0, _ := ret[0].(v1alpha11.AuthenticationV1alpha1Interface)
        return ret0
}</span>

// AuthenticationV1alpha1 indicates an expected call of AuthenticationV1alpha1.
func (mr *MockKubernetesClientMockRecorder) AuthenticationV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).AuthenticationV1alpha1))
}</span>

// AuthenticationV1beta1 mocks base method.
func (m *MockKubernetesClient) AuthenticationV1beta1() v1beta11.AuthenticationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticationV1beta1")
        ret0, _ := ret[0].(v1beta11.AuthenticationV1beta1Interface)
        return ret0
}</span>

// AuthenticationV1beta1 indicates an expected call of AuthenticationV1beta1.
func (mr *MockKubernetesClientMockRecorder) AuthenticationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticationV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).AuthenticationV1beta1))
}</span>

// AuthorizationV1 mocks base method.
func (m *MockKubernetesClient) AuthorizationV1() v12.AuthorizationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthorizationV1")
        ret0, _ := ret[0].(v12.AuthorizationV1Interface)
        return ret0
}</span>

// AuthorizationV1 indicates an expected call of AuthorizationV1.
func (mr *MockKubernetesClientMockRecorder) AuthorizationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthorizationV1", reflect.TypeOf((*MockKubernetesClient)(nil).AuthorizationV1))
}</span>

// AuthorizationV1beta1 mocks base method.
func (m *MockKubernetesClient) AuthorizationV1beta1() v1beta12.AuthorizationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthorizationV1beta1")
        ret0, _ := ret[0].(v1beta12.AuthorizationV1beta1Interface)
        return ret0
}</span>

// AuthorizationV1beta1 indicates an expected call of AuthorizationV1beta1.
func (mr *MockKubernetesClientMockRecorder) AuthorizationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthorizationV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).AuthorizationV1beta1))
}</span>

// AutoscalingV1 mocks base method.
func (m *MockKubernetesClient) AutoscalingV1() v13.AutoscalingV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV1")
        ret0, _ := ret[0].(v13.AutoscalingV1Interface)
        return ret0
}</span>

// AutoscalingV1 indicates an expected call of AutoscalingV1.
func (mr *MockKubernetesClientMockRecorder) AutoscalingV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV1", reflect.TypeOf((*MockKubernetesClient)(nil).AutoscalingV1))
}</span>

// AutoscalingV2 mocks base method.
func (m *MockKubernetesClient) AutoscalingV2() v2.AutoscalingV2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV2")
        ret0, _ := ret[0].(v2.AutoscalingV2Interface)
        return ret0
}</span>

// AutoscalingV2 indicates an expected call of AutoscalingV2.
func (mr *MockKubernetesClientMockRecorder) AutoscalingV2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV2", reflect.TypeOf((*MockKubernetesClient)(nil).AutoscalingV2))
}</span>

// AutoscalingV2beta1 mocks base method.
func (m *MockKubernetesClient) AutoscalingV2beta1() v2beta1.AutoscalingV2beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV2beta1")
        ret0, _ := ret[0].(v2beta1.AutoscalingV2beta1Interface)
        return ret0
}</span>

// AutoscalingV2beta1 indicates an expected call of AutoscalingV2beta1.
func (mr *MockKubernetesClientMockRecorder) AutoscalingV2beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV2beta1", reflect.TypeOf((*MockKubernetesClient)(nil).AutoscalingV2beta1))
}</span>

// AutoscalingV2beta2 mocks base method.
func (m *MockKubernetesClient) AutoscalingV2beta2() v2beta2.AutoscalingV2beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AutoscalingV2beta2")
        ret0, _ := ret[0].(v2beta2.AutoscalingV2beta2Interface)
        return ret0
}</span>

// AutoscalingV2beta2 indicates an expected call of AutoscalingV2beta2.
func (mr *MockKubernetesClientMockRecorder) AutoscalingV2beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AutoscalingV2beta2", reflect.TypeOf((*MockKubernetesClient)(nil).AutoscalingV2beta2))
}</span>

// BatchV1 mocks base method.
func (m *MockKubernetesClient) BatchV1() v14.BatchV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchV1")
        ret0, _ := ret[0].(v14.BatchV1Interface)
        return ret0
}</span>

// BatchV1 indicates an expected call of BatchV1.
func (mr *MockKubernetesClientMockRecorder) BatchV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchV1", reflect.TypeOf((*MockKubernetesClient)(nil).BatchV1))
}</span>

// BatchV1beta1 mocks base method.
func (m *MockKubernetesClient) BatchV1beta1() v1beta13.BatchV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "BatchV1beta1")
        ret0, _ := ret[0].(v1beta13.BatchV1beta1Interface)
        return ret0
}</span>

// BatchV1beta1 indicates an expected call of BatchV1beta1.
func (mr *MockKubernetesClientMockRecorder) BatchV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).BatchV1beta1))
}</span>

// CertificatesV1 mocks base method.
func (m *MockKubernetesClient) CertificatesV1() v15.CertificatesV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CertificatesV1")
        ret0, _ := ret[0].(v15.CertificatesV1Interface)
        return ret0
}</span>

// CertificatesV1 indicates an expected call of CertificatesV1.
func (mr *MockKubernetesClientMockRecorder) CertificatesV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertificatesV1", reflect.TypeOf((*MockKubernetesClient)(nil).CertificatesV1))
}</span>

// CertificatesV1alpha1 mocks base method.
func (m *MockKubernetesClient) CertificatesV1alpha1() v1alpha12.CertificatesV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CertificatesV1alpha1")
        ret0, _ := ret[0].(v1alpha12.CertificatesV1alpha1Interface)
        return ret0
}</span>

// CertificatesV1alpha1 indicates an expected call of CertificatesV1alpha1.
func (mr *MockKubernetesClientMockRecorder) CertificatesV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertificatesV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).CertificatesV1alpha1))
}</span>

// CertificatesV1beta1 mocks base method.
func (m *MockKubernetesClient) CertificatesV1beta1() v1beta14.CertificatesV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CertificatesV1beta1")
        ret0, _ := ret[0].(v1beta14.CertificatesV1beta1Interface)
        return ret0
}</span>

// CertificatesV1beta1 indicates an expected call of CertificatesV1beta1.
func (mr *MockKubernetesClientMockRecorder) CertificatesV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CertificatesV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).CertificatesV1beta1))
}</span>

// CoordinationV1 mocks base method.
func (m *MockKubernetesClient) CoordinationV1() v16.CoordinationV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoordinationV1")
        ret0, _ := ret[0].(v16.CoordinationV1Interface)
        return ret0
}</span>

// CoordinationV1 indicates an expected call of CoordinationV1.
func (mr *MockKubernetesClientMockRecorder) CoordinationV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoordinationV1", reflect.TypeOf((*MockKubernetesClient)(nil).CoordinationV1))
}</span>

// CoordinationV1alpha2 mocks base method.
func (m *MockKubernetesClient) CoordinationV1alpha2() v1alpha2.CoordinationV1alpha2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoordinationV1alpha2")
        ret0, _ := ret[0].(v1alpha2.CoordinationV1alpha2Interface)
        return ret0
}</span>

// CoordinationV1alpha2 indicates an expected call of CoordinationV1alpha2.
func (mr *MockKubernetesClientMockRecorder) CoordinationV1alpha2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoordinationV1alpha2", reflect.TypeOf((*MockKubernetesClient)(nil).CoordinationV1alpha2))
}</span>

// CoordinationV1beta1 mocks base method.
func (m *MockKubernetesClient) CoordinationV1beta1() v1beta15.CoordinationV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoordinationV1beta1")
        ret0, _ := ret[0].(v1beta15.CoordinationV1beta1Interface)
        return ret0
}</span>

// CoordinationV1beta1 indicates an expected call of CoordinationV1beta1.
func (mr *MockKubernetesClientMockRecorder) CoordinationV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoordinationV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).CoordinationV1beta1))
}</span>

// CoreV1 mocks base method.
func (m *MockKubernetesClient) CoreV1() v17.CoreV1Interface <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CoreV1")
        ret0, _ := ret[0].(v17.CoreV1Interface)
        return ret0
}</span>

// CoreV1 indicates an expected call of CoreV1.
func (mr *MockKubernetesClientMockRecorder) CoreV1() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CoreV1", reflect.TypeOf((*MockKubernetesClient)(nil).CoreV1))
}</span>

// Discovery mocks base method.
func (m *MockKubernetesClient) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Discovery")
        ret0, _ := ret[0].(discovery.DiscoveryInterface)
        return ret0
}</span>

// Discovery indicates an expected call of Discovery.
func (mr *MockKubernetesClientMockRecorder) Discovery() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Discovery", reflect.TypeOf((*MockKubernetesClient)(nil).Discovery))
}</span>

// DiscoveryV1 mocks base method.
func (m *MockKubernetesClient) DiscoveryV1() v18.DiscoveryV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DiscoveryV1")
        ret0, _ := ret[0].(v18.DiscoveryV1Interface)
        return ret0
}</span>

// DiscoveryV1 indicates an expected call of DiscoveryV1.
func (mr *MockKubernetesClientMockRecorder) DiscoveryV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiscoveryV1", reflect.TypeOf((*MockKubernetesClient)(nil).DiscoveryV1))
}</span>

// DiscoveryV1beta1 mocks base method.
func (m *MockKubernetesClient) DiscoveryV1beta1() v1beta16.DiscoveryV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DiscoveryV1beta1")
        ret0, _ := ret[0].(v1beta16.DiscoveryV1beta1Interface)
        return ret0
}</span>

// DiscoveryV1beta1 indicates an expected call of DiscoveryV1beta1.
func (mr *MockKubernetesClientMockRecorder) DiscoveryV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiscoveryV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).DiscoveryV1beta1))
}</span>

// EventsV1 mocks base method.
func (m *MockKubernetesClient) EventsV1() v19.EventsV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "EventsV1")
        ret0, _ := ret[0].(v19.EventsV1Interface)
        return ret0
}</span>

// EventsV1 indicates an expected call of EventsV1.
func (mr *MockKubernetesClientMockRecorder) EventsV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EventsV1", reflect.TypeOf((*MockKubernetesClient)(nil).EventsV1))
}</span>

// EventsV1beta1 mocks base method.
func (m *MockKubernetesClient) EventsV1beta1() v1beta17.EventsV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "EventsV1beta1")
        ret0, _ := ret[0].(v1beta17.EventsV1beta1Interface)
        return ret0
}</span>

// EventsV1beta1 indicates an expected call of EventsV1beta1.
func (mr *MockKubernetesClientMockRecorder) EventsV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EventsV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).EventsV1beta1))
}</span>

// ExtensionsV1beta1 mocks base method.
func (m *MockKubernetesClient) ExtensionsV1beta1() v1beta18.ExtensionsV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ExtensionsV1beta1")
        ret0, _ := ret[0].(v1beta18.ExtensionsV1beta1Interface)
        return ret0
}</span>

// ExtensionsV1beta1 indicates an expected call of ExtensionsV1beta1.
func (mr *MockKubernetesClientMockRecorder) ExtensionsV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExtensionsV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).ExtensionsV1beta1))
}</span>

// FlowcontrolV1 mocks base method.
func (m *MockKubernetesClient) FlowcontrolV1() v110.FlowcontrolV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1")
        ret0, _ := ret[0].(v110.FlowcontrolV1Interface)
        return ret0
}</span>

// FlowcontrolV1 indicates an expected call of FlowcontrolV1.
func (mr *MockKubernetesClientMockRecorder) FlowcontrolV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1", reflect.TypeOf((*MockKubernetesClient)(nil).FlowcontrolV1))
}</span>

// FlowcontrolV1beta1 mocks base method.
func (m *MockKubernetesClient) FlowcontrolV1beta1() v1beta19.FlowcontrolV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1beta1")
        ret0, _ := ret[0].(v1beta19.FlowcontrolV1beta1Interface)
        return ret0
}</span>

// FlowcontrolV1beta1 indicates an expected call of FlowcontrolV1beta1.
func (mr *MockKubernetesClientMockRecorder) FlowcontrolV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).FlowcontrolV1beta1))
}</span>

// FlowcontrolV1beta2 mocks base method.
func (m *MockKubernetesClient) FlowcontrolV1beta2() v1beta20.FlowcontrolV1beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1beta2")
        ret0, _ := ret[0].(v1beta20.FlowcontrolV1beta2Interface)
        return ret0
}</span>

// FlowcontrolV1beta2 indicates an expected call of FlowcontrolV1beta2.
func (mr *MockKubernetesClientMockRecorder) FlowcontrolV1beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1beta2", reflect.TypeOf((*MockKubernetesClient)(nil).FlowcontrolV1beta2))
}</span>

// FlowcontrolV1beta3 mocks base method.
func (m *MockKubernetesClient) FlowcontrolV1beta3() v1beta3.FlowcontrolV1beta3Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FlowcontrolV1beta3")
        ret0, _ := ret[0].(v1beta3.FlowcontrolV1beta3Interface)
        return ret0
}</span>

// FlowcontrolV1beta3 indicates an expected call of FlowcontrolV1beta3.
func (mr *MockKubernetesClientMockRecorder) FlowcontrolV1beta3() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FlowcontrolV1beta3", reflect.TypeOf((*MockKubernetesClient)(nil).FlowcontrolV1beta3))
}</span>

// InternalV1alpha1 mocks base method.
func (m *MockKubernetesClient) InternalV1alpha1() v1alpha10.InternalV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "InternalV1alpha1")
        ret0, _ := ret[0].(v1alpha10.InternalV1alpha1Interface)
        return ret0
}</span>

// InternalV1alpha1 indicates an expected call of InternalV1alpha1.
func (mr *MockKubernetesClientMockRecorder) InternalV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InternalV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).InternalV1alpha1))
}</span>

// NetworkingV1 mocks base method.
func (m *MockKubernetesClient) NetworkingV1() v111.NetworkingV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NetworkingV1")
        ret0, _ := ret[0].(v111.NetworkingV1Interface)
        return ret0
}</span>

// NetworkingV1 indicates an expected call of NetworkingV1.
func (mr *MockKubernetesClientMockRecorder) NetworkingV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkingV1", reflect.TypeOf((*MockKubernetesClient)(nil).NetworkingV1))
}</span>

// NetworkingV1alpha1 mocks base method.
func (m *MockKubernetesClient) NetworkingV1alpha1() v1alpha13.NetworkingV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NetworkingV1alpha1")
        ret0, _ := ret[0].(v1alpha13.NetworkingV1alpha1Interface)
        return ret0
}</span>

// NetworkingV1alpha1 indicates an expected call of NetworkingV1alpha1.
func (mr *MockKubernetesClientMockRecorder) NetworkingV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkingV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).NetworkingV1alpha1))
}</span>

// NetworkingV1beta1 mocks base method.
func (m *MockKubernetesClient) NetworkingV1beta1() v1beta110.NetworkingV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NetworkingV1beta1")
        ret0, _ := ret[0].(v1beta110.NetworkingV1beta1Interface)
        return ret0
}</span>

// NetworkingV1beta1 indicates an expected call of NetworkingV1beta1.
func (mr *MockKubernetesClientMockRecorder) NetworkingV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NetworkingV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).NetworkingV1beta1))
}</span>

// NodeV1 mocks base method.
func (m *MockKubernetesClient) NodeV1() v112.NodeV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NodeV1")
        ret0, _ := ret[0].(v112.NodeV1Interface)
        return ret0
}</span>

// NodeV1 indicates an expected call of NodeV1.
func (mr *MockKubernetesClientMockRecorder) NodeV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NodeV1", reflect.TypeOf((*MockKubernetesClient)(nil).NodeV1))
}</span>

// NodeV1alpha1 mocks base method.
func (m *MockKubernetesClient) NodeV1alpha1() v1alpha14.NodeV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NodeV1alpha1")
        ret0, _ := ret[0].(v1alpha14.NodeV1alpha1Interface)
        return ret0
}</span>

// NodeV1alpha1 indicates an expected call of NodeV1alpha1.
func (mr *MockKubernetesClientMockRecorder) NodeV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NodeV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).NodeV1alpha1))
}</span>

// NodeV1beta1 mocks base method.
func (m *MockKubernetesClient) NodeV1beta1() v1beta111.NodeV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NodeV1beta1")
        ret0, _ := ret[0].(v1beta111.NodeV1beta1Interface)
        return ret0
}</span>

// NodeV1beta1 indicates an expected call of NodeV1beta1.
func (mr *MockKubernetesClientMockRecorder) NodeV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NodeV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).NodeV1beta1))
}</span>

// PolicyV1 mocks base method.
func (m *MockKubernetesClient) PolicyV1() v113.PolicyV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PolicyV1")
        ret0, _ := ret[0].(v113.PolicyV1Interface)
        return ret0
}</span>

// PolicyV1 indicates an expected call of PolicyV1.
func (mr *MockKubernetesClientMockRecorder) PolicyV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PolicyV1", reflect.TypeOf((*MockKubernetesClient)(nil).PolicyV1))
}</span>

// PolicyV1beta1 mocks base method.
func (m *MockKubernetesClient) PolicyV1beta1() v1beta112.PolicyV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PolicyV1beta1")
        ret0, _ := ret[0].(v1beta112.PolicyV1beta1Interface)
        return ret0
}</span>

// PolicyV1beta1 indicates an expected call of PolicyV1beta1.
func (mr *MockKubernetesClientMockRecorder) PolicyV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PolicyV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).PolicyV1beta1))
}</span>

// RbacV1 mocks base method.
func (m *MockKubernetesClient) RbacV1() v114.RbacV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RbacV1")
        ret0, _ := ret[0].(v114.RbacV1Interface)
        return ret0
}</span>

// RbacV1 indicates an expected call of RbacV1.
func (mr *MockKubernetesClientMockRecorder) RbacV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RbacV1", reflect.TypeOf((*MockKubernetesClient)(nil).RbacV1))
}</span>

// RbacV1alpha1 mocks base method.
func (m *MockKubernetesClient) RbacV1alpha1() v1alpha15.RbacV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RbacV1alpha1")
        ret0, _ := ret[0].(v1alpha15.RbacV1alpha1Interface)
        return ret0
}</span>

// RbacV1alpha1 indicates an expected call of RbacV1alpha1.
func (mr *MockKubernetesClientMockRecorder) RbacV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RbacV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).RbacV1alpha1))
}</span>

// RbacV1beta1 mocks base method.
func (m *MockKubernetesClient) RbacV1beta1() v1beta113.RbacV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RbacV1beta1")
        ret0, _ := ret[0].(v1beta113.RbacV1beta1Interface)
        return ret0
}</span>

// RbacV1beta1 indicates an expected call of RbacV1beta1.
func (mr *MockKubernetesClientMockRecorder) RbacV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RbacV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).RbacV1beta1))
}</span>

// ResourceV1alpha3 mocks base method.
func (m *MockKubernetesClient) ResourceV1alpha3() v1alpha3.ResourceV1alpha3Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceV1alpha3")
        ret0, _ := ret[0].(v1alpha3.ResourceV1alpha3Interface)
        return ret0
}</span>

// ResourceV1alpha3 indicates an expected call of ResourceV1alpha3.
func (mr *MockKubernetesClientMockRecorder) ResourceV1alpha3() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceV1alpha3", reflect.TypeOf((*MockKubernetesClient)(nil).ResourceV1alpha3))
}</span>

// ResourceV1beta1 mocks base method.
func (m *MockKubernetesClient) ResourceV1beta1() v1beta114.ResourceV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceV1beta1")
        ret0, _ := ret[0].(v1beta114.ResourceV1beta1Interface)
        return ret0
}</span>

// ResourceV1beta1 indicates an expected call of ResourceV1beta1.
func (mr *MockKubernetesClientMockRecorder) ResourceV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).ResourceV1beta1))
}</span>

// ResourceV1beta2 mocks base method.
func (m *MockKubernetesClient) ResourceV1beta2() v1beta21.ResourceV1beta2Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceV1beta2")
        ret0, _ := ret[0].(v1beta21.ResourceV1beta2Interface)
        return ret0
}</span>

// ResourceV1beta2 indicates an expected call of ResourceV1beta2.
func (mr *MockKubernetesClientMockRecorder) ResourceV1beta2() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceV1beta2", reflect.TypeOf((*MockKubernetesClient)(nil).ResourceV1beta2))
}</span>

// SchedulingV1 mocks base method.
func (m *MockKubernetesClient) SchedulingV1() v115.SchedulingV1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SchedulingV1")
        ret0, _ := ret[0].(v115.SchedulingV1Interface)
        return ret0
}</span>

// SchedulingV1 indicates an expected call of SchedulingV1.
func (mr *MockKubernetesClientMockRecorder) SchedulingV1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulingV1", reflect.TypeOf((*MockKubernetesClient)(nil).SchedulingV1))
}</span>

// SchedulingV1alpha1 mocks base method.
func (m *MockKubernetesClient) SchedulingV1alpha1() v1alpha16.SchedulingV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SchedulingV1alpha1")
        ret0, _ := ret[0].(v1alpha16.SchedulingV1alpha1Interface)
        return ret0
}</span>

// SchedulingV1alpha1 indicates an expected call of SchedulingV1alpha1.
func (mr *MockKubernetesClientMockRecorder) SchedulingV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulingV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).SchedulingV1alpha1))
}</span>

// SchedulingV1beta1 mocks base method.
func (m *MockKubernetesClient) SchedulingV1beta1() v1beta115.SchedulingV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SchedulingV1beta1")
        ret0, _ := ret[0].(v1beta115.SchedulingV1beta1Interface)
        return ret0
}</span>

// SchedulingV1beta1 indicates an expected call of SchedulingV1beta1.
func (mr *MockKubernetesClientMockRecorder) SchedulingV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SchedulingV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).SchedulingV1beta1))
}</span>

// StorageV1 mocks base method.
func (m *MockKubernetesClient) StorageV1() v116.StorageV1Interface <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageV1")
        ret0, _ := ret[0].(v116.StorageV1Interface)
        return ret0
}</span>

// StorageV1 indicates an expected call of StorageV1.
func (mr *MockKubernetesClientMockRecorder) StorageV1() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageV1", reflect.TypeOf((*MockKubernetesClient)(nil).StorageV1))
}</span>

// StorageV1alpha1 mocks base method.
func (m *MockKubernetesClient) StorageV1alpha1() v1alpha17.StorageV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageV1alpha1")
        ret0, _ := ret[0].(v1alpha17.StorageV1alpha1Interface)
        return ret0
}</span>

// StorageV1alpha1 indicates an expected call of StorageV1alpha1.
func (mr *MockKubernetesClientMockRecorder) StorageV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).StorageV1alpha1))
}</span>

// StorageV1beta1 mocks base method.
func (m *MockKubernetesClient) StorageV1beta1() v1beta116.StorageV1beta1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageV1beta1")
        ret0, _ := ret[0].(v1beta116.StorageV1beta1Interface)
        return ret0
}</span>

// StorageV1beta1 indicates an expected call of StorageV1beta1.
func (mr *MockKubernetesClientMockRecorder) StorageV1beta1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageV1beta1", reflect.TypeOf((*MockKubernetesClient)(nil).StorageV1beta1))
}</span>

// StoragemigrationV1alpha1 mocks base method.
func (m *MockKubernetesClient) StoragemigrationV1alpha1() v1alpha18.StoragemigrationV1alpha1Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StoragemigrationV1alpha1")
        ret0, _ := ret[0].(v1alpha18.StoragemigrationV1alpha1Interface)
        return ret0
}</span>

// StoragemigrationV1alpha1 indicates an expected call of StoragemigrationV1alpha1.
func (mr *MockKubernetesClientMockRecorder) StoragemigrationV1alpha1() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StoragemigrationV1alpha1", reflect.TypeOf((*MockKubernetesClient)(nil).StoragemigrationV1alpha1))
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: k8s.io/client-go/kubernetes/typed/core/v1 (interfaces: CoreV1Interface,NodeInterface)

// Package driver is a generated GoMock package.
package driver

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        v1 "k8s.io/api/core/v1"
        v10 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        v11 "k8s.io/client-go/applyconfigurations/core/v1"
        v12 "k8s.io/client-go/kubernetes/typed/core/v1"
        rest "k8s.io/client-go/rest"
)

// MockCoreV1Interface is a mock of CoreV1Interface interface.
type MockCoreV1Interface struct {
        ctrl     *gomock.Controller
        recorder *MockCoreV1InterfaceMockRecorder
}

// MockCoreV1InterfaceMockRecorder is the mock recorder for MockCoreV1Interface.
type MockCoreV1InterfaceMockRecorder struct {
        mock *MockCoreV1Interface
}

// NewMockCoreV1Interface creates a new mock instance.
func NewMockCoreV1Interface(ctrl *gomock.Controller) *MockCoreV1Interface <span class="cov8" title="1">{
        mock := &amp;MockCoreV1Interface{ctrl: ctrl}
        mock.recorder = &amp;MockCoreV1InterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCoreV1Interface) EXPECT() *MockCoreV1InterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// ComponentStatuses mocks base method.
func (m *MockCoreV1Interface) ComponentStatuses() v12.ComponentStatusInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ComponentStatuses")
        ret0, _ := ret[0].(v12.ComponentStatusInterface)
        return ret0
}</span>

// ComponentStatuses indicates an expected call of ComponentStatuses.
func (mr *MockCoreV1InterfaceMockRecorder) ComponentStatuses() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ComponentStatuses", reflect.TypeOf((*MockCoreV1Interface)(nil).ComponentStatuses))
}</span>

// ConfigMaps mocks base method.
func (m *MockCoreV1Interface) ConfigMaps(arg0 string) v12.ConfigMapInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ConfigMaps", arg0)
        ret0, _ := ret[0].(v12.ConfigMapInterface)
        return ret0
}</span>

// ConfigMaps indicates an expected call of ConfigMaps.
func (mr *MockCoreV1InterfaceMockRecorder) ConfigMaps(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConfigMaps", reflect.TypeOf((*MockCoreV1Interface)(nil).ConfigMaps), arg0)
}</span>

// Endpoints mocks base method.
func (m *MockCoreV1Interface) Endpoints(arg0 string) v12.EndpointsInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Endpoints", arg0)
        ret0, _ := ret[0].(v12.EndpointsInterface)
        return ret0
}</span>

// Endpoints indicates an expected call of Endpoints.
func (mr *MockCoreV1InterfaceMockRecorder) Endpoints(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Endpoints", reflect.TypeOf((*MockCoreV1Interface)(nil).Endpoints), arg0)
}</span>

// Events mocks base method.
func (m *MockCoreV1Interface) Events(arg0 string) v12.EventInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Events", arg0)
        ret0, _ := ret[0].(v12.EventInterface)
        return ret0
}</span>

// Events indicates an expected call of Events.
func (mr *MockCoreV1InterfaceMockRecorder) Events(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Events", reflect.TypeOf((*MockCoreV1Interface)(nil).Events), arg0)
}</span>

// LimitRanges mocks base method.
func (m *MockCoreV1Interface) LimitRanges(arg0 string) v12.LimitRangeInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LimitRanges", arg0)
        ret0, _ := ret[0].(v12.LimitRangeInterface)
        return ret0
}</span>

// LimitRanges indicates an expected call of LimitRanges.
func (mr *MockCoreV1InterfaceMockRecorder) LimitRanges(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LimitRanges", reflect.TypeOf((*MockCoreV1Interface)(nil).LimitRanges), arg0)
}</span>

// Namespaces mocks base method.
func (m *MockCoreV1Interface) Namespaces() v12.NamespaceInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Namespaces")
        ret0, _ := ret[0].(v12.NamespaceInterface)
        return ret0
}</span>

// Namespaces indicates an expected call of Namespaces.
func (mr *MockCoreV1InterfaceMockRecorder) Namespaces() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Namespaces", reflect.TypeOf((*MockCoreV1Interface)(nil).Namespaces))
}</span>

// Nodes mocks base method.
func (m *MockCoreV1Interface) Nodes() v12.NodeInterface <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Nodes")
        ret0, _ := ret[0].(v12.NodeInterface)
        return ret0
}</span>

// Nodes indicates an expected call of Nodes.
func (mr *MockCoreV1InterfaceMockRecorder) Nodes() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Nodes", reflect.TypeOf((*MockCoreV1Interface)(nil).Nodes))
}</span>

// PersistentVolumeClaims mocks base method.
func (m *MockCoreV1Interface) PersistentVolumeClaims(arg0 string) v12.PersistentVolumeClaimInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PersistentVolumeClaims", arg0)
        ret0, _ := ret[0].(v12.PersistentVolumeClaimInterface)
        return ret0
}</span>

// PersistentVolumeClaims indicates an expected call of PersistentVolumeClaims.
func (mr *MockCoreV1InterfaceMockRecorder) PersistentVolumeClaims(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistentVolumeClaims", reflect.TypeOf((*MockCoreV1Interface)(nil).PersistentVolumeClaims), arg0)
}</span>

// PersistentVolumes mocks base method.
func (m *MockCoreV1Interface) PersistentVolumes() v12.PersistentVolumeInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PersistentVolumes")
        ret0, _ := ret[0].(v12.PersistentVolumeInterface)
        return ret0
}</span>

// PersistentVolumes indicates an expected call of PersistentVolumes.
func (mr *MockCoreV1InterfaceMockRecorder) PersistentVolumes() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PersistentVolumes", reflect.TypeOf((*MockCoreV1Interface)(nil).PersistentVolumes))
}</span>

// PodTemplates mocks base method.
func (m *MockCoreV1Interface) PodTemplates(arg0 string) v12.PodTemplateInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PodTemplates", arg0)
        ret0, _ := ret[0].(v12.PodTemplateInterface)
        return ret0
}</span>

// PodTemplates indicates an expected call of PodTemplates.
func (mr *MockCoreV1InterfaceMockRecorder) PodTemplates(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PodTemplates", reflect.TypeOf((*MockCoreV1Interface)(nil).PodTemplates), arg0)
}</span>

// Pods mocks base method.
func (m *MockCoreV1Interface) Pods(arg0 string) v12.PodInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Pods", arg0)
        ret0, _ := ret[0].(v12.PodInterface)
        return ret0
}</span>

// Pods indicates an expected call of Pods.
func (mr *MockCoreV1InterfaceMockRecorder) Pods(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Pods", reflect.TypeOf((*MockCoreV1Interface)(nil).Pods), arg0)
}</span>

// RESTClient mocks base method.
func (m *MockCoreV1Interface) RESTClient() rest.Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RESTClient")
        ret0, _ := ret[0].(rest.Interface)
        return ret0
}</span>

// RESTClient indicates an expected call of RESTClient.
func (mr *MockCoreV1InterfaceMockRecorder) RESTClient() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RESTClient", reflect.TypeOf((*MockCoreV1Interface)(nil).RESTClient))
}</span>

// ReplicationControllers mocks base method.
func (m *MockCoreV1Interface) ReplicationControllers(arg0 string) v12.ReplicationControllerInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReplicationControllers", arg0)
        ret0, _ := ret[0].(v12.ReplicationControllerInterface)
        return ret0
}</span>

// ReplicationControllers indicates an expected call of ReplicationControllers.
func (mr *MockCoreV1InterfaceMockRecorder) ReplicationControllers(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplicationControllers", reflect.TypeOf((*MockCoreV1Interface)(nil).ReplicationControllers), arg0)
}</span>

// ResourceQuotas mocks base method.
func (m *MockCoreV1Interface) ResourceQuotas(arg0 string) v12.ResourceQuotaInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ResourceQuotas", arg0)
        ret0, _ := ret[0].(v12.ResourceQuotaInterface)
        return ret0
}</span>

// ResourceQuotas indicates an expected call of ResourceQuotas.
func (mr *MockCoreV1InterfaceMockRecorder) ResourceQuotas(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ResourceQuotas", reflect.TypeOf((*MockCoreV1Interface)(nil).ResourceQuotas), arg0)
}</span>

// Secrets mocks base method.
func (m *MockCoreV1Interface) Secrets(arg0 string) v12.SecretInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Secrets", arg0)
        ret0, _ := ret[0].(v12.SecretInterface)
        return ret0
}</span>

// Secrets indicates an expected call of Secrets.
func (mr *MockCoreV1InterfaceMockRecorder) Secrets(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Secrets", reflect.TypeOf((*MockCoreV1Interface)(nil).Secrets), arg0)
}</span>

// ServiceAccounts mocks base method.
func (m *MockCoreV1Interface) ServiceAccounts(arg0 string) v12.ServiceAccountInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ServiceAccounts", arg0)
        ret0, _ := ret[0].(v12.ServiceAccountInterface)
        return ret0
}</span>

// ServiceAccounts indicates an expected call of ServiceAccounts.
func (mr *MockCoreV1InterfaceMockRecorder) ServiceAccounts(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ServiceAccounts", reflect.TypeOf((*MockCoreV1Interface)(nil).ServiceAccounts), arg0)
}</span>

// Services mocks base method.
func (m *MockCoreV1Interface) Services(arg0 string) v12.ServiceInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Services", arg0)
        ret0, _ := ret[0].(v12.ServiceInterface)
        return ret0
}</span>

// Services indicates an expected call of Services.
func (mr *MockCoreV1InterfaceMockRecorder) Services(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Services", reflect.TypeOf((*MockCoreV1Interface)(nil).Services), arg0)
}</span>

// MockNodeInterface is a mock of NodeInterface interface.
type MockNodeInterface struct {
        ctrl     *gomock.Controller
        recorder *MockNodeInterfaceMockRecorder
}

// MockNodeInterfaceMockRecorder is the mock recorder for MockNodeInterface.
type MockNodeInterfaceMockRecorder struct {
        mock *MockNodeInterface
}

// NewMockNodeInterface creates a new mock instance.
func NewMockNodeInterface(ctrl *gomock.Controller) *MockNodeInterface <span class="cov8" title="1">{
        mock := &amp;MockNodeInterface{ctrl: ctrl}
        mock.recorder = &amp;MockNodeInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNodeInterface) EXPECT() *MockNodeInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Apply mocks base method.
func (m *MockNodeInterface) Apply(arg0 context.Context, arg1 *v11.NodeApplyConfiguration, arg2 v10.ApplyOptions) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Apply", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Apply indicates an expected call of Apply.
func (mr *MockNodeInterfaceMockRecorder) Apply(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockNodeInterface)(nil).Apply), arg0, arg1, arg2)
}</span>

// ApplyStatus mocks base method.
func (m *MockNodeInterface) ApplyStatus(arg0 context.Context, arg1 *v11.NodeApplyConfiguration, arg2 v10.ApplyOptions) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ApplyStatus", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ApplyStatus indicates an expected call of ApplyStatus.
func (mr *MockNodeInterfaceMockRecorder) ApplyStatus(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyStatus", reflect.TypeOf((*MockNodeInterface)(nil).ApplyStatus), arg0, arg1, arg2)
}</span>

// Create mocks base method.
func (m *MockNodeInterface) Create(arg0 context.Context, arg1 *v1.Node, arg2 v10.CreateOptions) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockNodeInterfaceMockRecorder) Create(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockNodeInterface)(nil).Create), arg0, arg1, arg2)
}</span>

// Delete mocks base method.
func (m *MockNodeInterface) Delete(arg0 context.Context, arg1 string, arg2 v10.DeleteOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockNodeInterfaceMockRecorder) Delete(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockNodeInterface)(nil).Delete), arg0, arg1, arg2)
}</span>

// DeleteCollection mocks base method.
func (m *MockNodeInterface) DeleteCollection(arg0 context.Context, arg1 v10.DeleteOptions, arg2 v10.ListOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteCollection", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteCollection indicates an expected call of DeleteCollection.
func (mr *MockNodeInterfaceMockRecorder) DeleteCollection(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockNodeInterface)(nil).DeleteCollection), arg0, arg1, arg2)
}</span>

// Get mocks base method.
func (m *MockNodeInterface) Get(arg0 context.Context, arg1 string, arg2 v10.GetOptions) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockNodeInterfaceMockRecorder) Get(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockNodeInterface)(nil).Get), arg0, arg1, arg2)
}</span>

// List mocks base method.
func (m *MockNodeInterface) List(arg0 context.Context, arg1 v10.ListOptions) (*v1.NodeList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", arg0, arg1)
        ret0, _ := ret[0].(*v1.NodeList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockNodeInterfaceMockRecorder) List(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockNodeInterface)(nil).List), arg0, arg1)
}</span>

// Patch mocks base method.
func (m *MockNodeInterface) Patch(arg0 context.Context, arg1 string, arg2 types.PatchType, arg3 []byte, arg4 v10.PatchOptions, arg5 ...string) (*v1.Node, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
        for _, a := range arg5 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov8" title="1">ret := m.ctrl.Call(m, "Patch", varargs...)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Patch indicates an expected call of Patch.
func (mr *MockNodeInterfaceMockRecorder) Patch(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockNodeInterface)(nil).Patch), varargs...)
}</span>

// PatchStatus mocks base method.
func (m *MockNodeInterface) PatchStatus(arg0 context.Context, arg1 string, arg2 []byte) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PatchStatus", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// PatchStatus indicates an expected call of PatchStatus.
func (mr *MockNodeInterfaceMockRecorder) PatchStatus(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PatchStatus", reflect.TypeOf((*MockNodeInterface)(nil).PatchStatus), arg0, arg1, arg2)
}</span>

// Update mocks base method.
func (m *MockNodeInterface) Update(arg0 context.Context, arg1 *v1.Node, arg2 v10.UpdateOptions) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockNodeInterfaceMockRecorder) Update(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockNodeInterface)(nil).Update), arg0, arg1, arg2)
}</span>

// UpdateStatus mocks base method.
func (m *MockNodeInterface) UpdateStatus(arg0 context.Context, arg1 *v1.Node, arg2 v10.UpdateOptions) (*v1.Node, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateStatus", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.Node)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateStatus indicates an expected call of UpdateStatus.
func (mr *MockNodeInterfaceMockRecorder) UpdateStatus(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatus", reflect.TypeOf((*MockNodeInterface)(nil).UpdateStatus), arg0, arg1, arg2)
}</span>

// Watch mocks base method.
func (m *MockNodeInterface) Watch(arg0 context.Context, arg1 v10.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Watch", arg0, arg1)
        ret0, _ := ret[0].(watch.Interface)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Watch indicates an expected call of Watch.
func (mr *MockNodeInterfaceMockRecorder) Watch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockNodeInterface)(nil).Watch), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: k8s.io/client-go/kubernetes/typed/storage/v1 (interfaces: VolumeAttachmentInterface,StorageV1Interface)

// Package driver is a generated GoMock package.
package driver

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        v1 "k8s.io/api/storage/v1"
        v10 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        v11 "k8s.io/client-go/applyconfigurations/storage/v1"
        v12 "k8s.io/client-go/kubernetes/typed/storage/v1"
        rest "k8s.io/client-go/rest"
)

// MockVolumeAttachmentInterface is a mock of VolumeAttachmentInterface interface.
type MockVolumeAttachmentInterface struct {
        ctrl     *gomock.Controller
        recorder *MockVolumeAttachmentInterfaceMockRecorder
}

// MockVolumeAttachmentInterfaceMockRecorder is the mock recorder for MockVolumeAttachmentInterface.
type MockVolumeAttachmentInterfaceMockRecorder struct {
        mock *MockVolumeAttachmentInterface
}

// NewMockVolumeAttachmentInterface creates a new mock instance.
func NewMockVolumeAttachmentInterface(ctrl *gomock.Controller) *MockVolumeAttachmentInterface <span class="cov0" title="0">{
        mock := &amp;MockVolumeAttachmentInterface{ctrl: ctrl}
        mock.recorder = &amp;MockVolumeAttachmentInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVolumeAttachmentInterface) EXPECT() *MockVolumeAttachmentInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Apply mocks base method.
func (m *MockVolumeAttachmentInterface) Apply(arg0 context.Context, arg1 *v11.VolumeAttachmentApplyConfiguration, arg2 v10.ApplyOptions) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Apply", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Apply indicates an expected call of Apply.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Apply(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Apply), arg0, arg1, arg2)
}</span>

// ApplyStatus mocks base method.
func (m *MockVolumeAttachmentInterface) ApplyStatus(arg0 context.Context, arg1 *v11.VolumeAttachmentApplyConfiguration, arg2 v10.ApplyOptions) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ApplyStatus", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ApplyStatus indicates an expected call of ApplyStatus.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) ApplyStatus(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ApplyStatus", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).ApplyStatus), arg0, arg1, arg2)
}</span>

// Create mocks base method.
func (m *MockVolumeAttachmentInterface) Create(arg0 context.Context, arg1 *v1.VolumeAttachment, arg2 v10.CreateOptions) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Create(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Create), arg0, arg1, arg2)
}</span>

// Delete mocks base method.
func (m *MockVolumeAttachmentInterface) Delete(arg0 context.Context, arg1 string, arg2 v10.DeleteOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Delete(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Delete), arg0, arg1, arg2)
}</span>

// DeleteCollection mocks base method.
func (m *MockVolumeAttachmentInterface) DeleteCollection(arg0 context.Context, arg1 v10.DeleteOptions, arg2 v10.ListOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteCollection", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteCollection indicates an expected call of DeleteCollection.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) DeleteCollection(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).DeleteCollection), arg0, arg1, arg2)
}</span>

// Get mocks base method.
func (m *MockVolumeAttachmentInterface) Get(arg0 context.Context, arg1 string, arg2 v10.GetOptions) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Get(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Get), arg0, arg1, arg2)
}</span>

// List mocks base method.
func (m *MockVolumeAttachmentInterface) List(arg0 context.Context, arg1 v10.ListOptions) (*v1.VolumeAttachmentList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", arg0, arg1)
        ret0, _ := ret[0].(*v1.VolumeAttachmentList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) List(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).List), arg0, arg1)
}</span>

// Patch mocks base method.
func (m *MockVolumeAttachmentInterface) Patch(arg0 context.Context, arg1 string, arg2 types.PatchType, arg3 []byte, arg4 v10.PatchOptions, arg5 ...string) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
        for _, a := range arg5 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Patch", varargs...)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Patch indicates an expected call of Patch.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Patch(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Patch), varargs...)
}</span>

// Update mocks base method.
func (m *MockVolumeAttachmentInterface) Update(arg0 context.Context, arg1 *v1.VolumeAttachment, arg2 v10.UpdateOptions) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Update(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Update), arg0, arg1, arg2)
}</span>

// UpdateStatus mocks base method.
func (m *MockVolumeAttachmentInterface) UpdateStatus(arg0 context.Context, arg1 *v1.VolumeAttachment, arg2 v10.UpdateOptions) (*v1.VolumeAttachment, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateStatus", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.VolumeAttachment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateStatus indicates an expected call of UpdateStatus.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) UpdateStatus(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatus", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).UpdateStatus), arg0, arg1, arg2)
}</span>

// Watch mocks base method.
func (m *MockVolumeAttachmentInterface) Watch(arg0 context.Context, arg1 v10.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Watch", arg0, arg1)
        ret0, _ := ret[0].(watch.Interface)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Watch indicates an expected call of Watch.
func (mr *MockVolumeAttachmentInterfaceMockRecorder) Watch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockVolumeAttachmentInterface)(nil).Watch), arg0, arg1)
}</span>

// MockStorageV1Interface is a mock of StorageV1Interface interface.
type MockStorageV1Interface struct {
        ctrl     *gomock.Controller
        recorder *MockStorageV1InterfaceMockRecorder
}

// MockStorageV1InterfaceMockRecorder is the mock recorder for MockStorageV1Interface.
type MockStorageV1InterfaceMockRecorder struct {
        mock *MockStorageV1Interface
}

// NewMockStorageV1Interface creates a new mock instance.
func NewMockStorageV1Interface(ctrl *gomock.Controller) *MockStorageV1Interface <span class="cov8" title="1">{
        mock := &amp;MockStorageV1Interface{ctrl: ctrl}
        mock.recorder = &amp;MockStorageV1InterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStorageV1Interface) EXPECT() *MockStorageV1InterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CSIDrivers mocks base method.
func (m *MockStorageV1Interface) CSIDrivers() v12.CSIDriverInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CSIDrivers")
        ret0, _ := ret[0].(v12.CSIDriverInterface)
        return ret0
}</span>

// CSIDrivers indicates an expected call of CSIDrivers.
func (mr *MockStorageV1InterfaceMockRecorder) CSIDrivers() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CSIDrivers", reflect.TypeOf((*MockStorageV1Interface)(nil).CSIDrivers))
}</span>

// CSINodes mocks base method.
func (m *MockStorageV1Interface) CSINodes() v12.CSINodeInterface <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CSINodes")
        ret0, _ := ret[0].(v12.CSINodeInterface)
        return ret0
}</span>

// CSINodes indicates an expected call of CSINodes.
func (mr *MockStorageV1InterfaceMockRecorder) CSINodes() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CSINodes", reflect.TypeOf((*MockStorageV1Interface)(nil).CSINodes))
}</span>

// CSIStorageCapacities mocks base method.
func (m *MockStorageV1Interface) CSIStorageCapacities(arg0 string) v12.CSIStorageCapacityInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CSIStorageCapacities", arg0)
        ret0, _ := ret[0].(v12.CSIStorageCapacityInterface)
        return ret0
}</span>

// CSIStorageCapacities indicates an expected call of CSIStorageCapacities.
func (mr *MockStorageV1InterfaceMockRecorder) CSIStorageCapacities(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CSIStorageCapacities", reflect.TypeOf((*MockStorageV1Interface)(nil).CSIStorageCapacities), arg0)
}</span>

// RESTClient mocks base method.
func (m *MockStorageV1Interface) RESTClient() rest.Interface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RESTClient")
        ret0, _ := ret[0].(rest.Interface)
        return ret0
}</span>

// RESTClient indicates an expected call of RESTClient.
func (mr *MockStorageV1InterfaceMockRecorder) RESTClient() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RESTClient", reflect.TypeOf((*MockStorageV1Interface)(nil).RESTClient))
}</span>

// StorageClasses mocks base method.
func (m *MockStorageV1Interface) StorageClasses() v12.StorageClassInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "StorageClasses")
        ret0, _ := ret[0].(v12.StorageClassInterface)
        return ret0
}</span>

// StorageClasses indicates an expected call of StorageClasses.
func (mr *MockStorageV1InterfaceMockRecorder) StorageClasses() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StorageClasses", reflect.TypeOf((*MockStorageV1Interface)(nil).StorageClasses))
}</span>

// VolumeAttachments mocks base method.
func (m *MockStorageV1Interface) VolumeAttachments() v12.VolumeAttachmentInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "VolumeAttachments")
        ret0, _ := ret[0].(v12.VolumeAttachmentInterface)
        return ret0
}</span>

// VolumeAttachments indicates an expected call of VolumeAttachments.
func (mr *MockStorageV1InterfaceMockRecorder) VolumeAttachments() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "VolumeAttachments", reflect.TypeOf((*MockStorageV1Interface)(nil).VolumeAttachments))
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: k8s.io/client-go/kubernetes/typed/storage/v1 (interfaces: CSINodeInterface)

// Package driver is a generated GoMock package.
package driver

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        v1 "k8s.io/api/storage/v1"
        v10 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        v11 "k8s.io/client-go/applyconfigurations/storage/v1"
)

// MockCSINodeInterface is a mock of CSINodeInterface interface.
type MockCSINodeInterface struct {
        ctrl     *gomock.Controller
        recorder *MockCSINodeInterfaceMockRecorder
}

// MockCSINodeInterfaceMockRecorder is the mock recorder for MockCSINodeInterface.
type MockCSINodeInterfaceMockRecorder struct {
        mock *MockCSINodeInterface
}

// NewMockCSINodeInterface creates a new mock instance.
func NewMockCSINodeInterface(ctrl *gomock.Controller) *MockCSINodeInterface <span class="cov8" title="1">{
        mock := &amp;MockCSINodeInterface{ctrl: ctrl}
        mock.recorder = &amp;MockCSINodeInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCSINodeInterface) EXPECT() *MockCSINodeInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Apply mocks base method.
func (m *MockCSINodeInterface) Apply(arg0 context.Context, arg1 *v11.CSINodeApplyConfiguration, arg2 v10.ApplyOptions) (*v1.CSINode, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Apply", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.CSINode)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Apply indicates an expected call of Apply.
func (mr *MockCSINodeInterfaceMockRecorder) Apply(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Apply", reflect.TypeOf((*MockCSINodeInterface)(nil).Apply), arg0, arg1, arg2)
}</span>

// Create mocks base method.
func (m *MockCSINodeInterface) Create(arg0 context.Context, arg1 *v1.CSINode, arg2 v10.CreateOptions) (*v1.CSINode, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.CSINode)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockCSINodeInterfaceMockRecorder) Create(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockCSINodeInterface)(nil).Create), arg0, arg1, arg2)
}</span>

// Delete mocks base method.
func (m *MockCSINodeInterface) Delete(arg0 context.Context, arg1 string, arg2 v10.DeleteOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockCSINodeInterfaceMockRecorder) Delete(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCSINodeInterface)(nil).Delete), arg0, arg1, arg2)
}</span>

// DeleteCollection mocks base method.
func (m *MockCSINodeInterface) DeleteCollection(arg0 context.Context, arg1 v10.DeleteOptions, arg2 v10.ListOptions) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "DeleteCollection", arg0, arg1, arg2)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// DeleteCollection indicates an expected call of DeleteCollection.
func (mr *MockCSINodeInterfaceMockRecorder) DeleteCollection(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteCollection", reflect.TypeOf((*MockCSINodeInterface)(nil).DeleteCollection), arg0, arg1, arg2)
}</span>

// Get mocks base method.
func (m *MockCSINodeInterface) Get(arg0 context.Context, arg1 string, arg2 v10.GetOptions) (*v1.CSINode, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.CSINode)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockCSINodeInterfaceMockRecorder) Get(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCSINodeInterface)(nil).Get), arg0, arg1, arg2)
}</span>

// List mocks base method.
func (m *MockCSINodeInterface) List(arg0 context.Context, arg1 v10.ListOptions) (*v1.CSINodeList, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List", arg0, arg1)
        ret0, _ := ret[0].(*v1.CSINodeList)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockCSINodeInterfaceMockRecorder) List(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockCSINodeInterface)(nil).List), arg0, arg1)
}</span>

// Patch mocks base method.
func (m *MockCSINodeInterface) Patch(arg0 context.Context, arg1 string, arg2 types.PatchType, arg3 []byte, arg4 v10.PatchOptions, arg5 ...string) (*v1.CSINode, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{arg0, arg1, arg2, arg3, arg4}
        for _, a := range arg5 </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "Patch", varargs...)
        ret0, _ := ret[0].(*v1.CSINode)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// Patch indicates an expected call of Patch.
func (mr *MockCSINodeInterfaceMockRecorder) Patch(arg0, arg1, arg2, arg3, arg4 interface{}, arg5 ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{arg0, arg1, arg2, arg3, arg4}, arg5...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Patch", reflect.TypeOf((*MockCSINodeInterface)(nil).Patch), varargs...)
}</span>

// Update mocks base method.
func (m *MockCSINodeInterface) Update(arg0 context.Context, arg1 *v1.CSINode, arg2 v10.UpdateOptions) (*v1.CSINode, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1.CSINode)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockCSINodeInterfaceMockRecorder) Update(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockCSINodeInterface)(nil).Update), arg0, arg1, arg2)
}</span>

// Watch mocks base method.
func (m *MockCSINodeInterface) Watch(arg0 context.Context, arg1 v10.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Watch", arg0, arg1)
        ret0, _ := ret[0].(watch.Interface)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Watch indicates an expected call of Watch.
func (mr *MockCSINodeInterfaceMockRecorder) Watch(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockCSINodeInterface)(nil).Watch), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "time"

        csi "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/driver/internal"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/mounter"
        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/util"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        k8stypes "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/cache"
        "k8s.io/klog/v2"
)

const (
        // default file system type to be used when it is not provided.
        defaultFsType = FSTypeExt4

        // VolumeOperationAlreadyExists is message fmt returned to CO when there is another in-flight call on the given volumeID.
        VolumeOperationAlreadyExists = "An operation with the given volume=%q is already in progress"
)

var (
        ValidFSTypes = map[string]struct{}{
                FSTypeExt3: {},
                FSTypeExt4: {},
                FSTypeXfs:  {},
                FSTypeNtfs: {},
        }
)

var (
        // nodeCaps represents the capability of node service.
        nodeCaps = []csi.NodeServiceCapability_RPC_Type{
                csi.NodeServiceCapability_RPC_STAGE_UNSTAGE_VOLUME,
                csi.NodeServiceCapability_RPC_EXPAND_VOLUME,
                csi.NodeServiceCapability_RPC_GET_VOLUME_STATS,
        }
)

const (
        // taintWatcherDuration is the maximum duration for the not-ready taint watcher to run.
        taintWatcherDuration = 1 * time.Minute
)

// NodeService represents the node service of CSI driver.
type NodeService struct {
        metadata  metadata.MetadataService
        mounter   mounter.Mounter
        inFlight  *internal.InFlight
        options   *Options
        k8sClient kubernetes.Interface
        csi.UnimplementedNodeServer
}

// NewNodeService creates a new node service.
func NewNodeService(o *Options, md metadata.MetadataService, m mounter.Mounter, k kubernetes.Interface) *NodeService <span class="cov8" title="1">{
        if k != nil </span><span class="cov8" title="1">{
                // Watch for the agent‑not‑ready taint for up to one minute and remove it
                // as soon as allocatable is available.
                startNotReadyTaintWatcher(k, taintWatcherDuration)
        }</span>

        <span class="cov8" title="1">return &amp;NodeService{
                metadata:  md,
                mounter:   m,
                inFlight:  internal.NewInFlight(),
                options:   o,
                k8sClient: k,
        }</span>
}

func (d *NodeService) NodeStageVolume(ctx context.Context, req *csi.NodeStageVolumeRequest) (*csi.NodeStageVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeStageVolume: called", "args", util.SanitizeRequest(req))

        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">target := req.GetStagingTargetPath()
        if len(target) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Staging target not provided")
        }</span>

        <span class="cov8" title="1">volCap := req.GetVolumeCapability()
        if volCap == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability not provided")
        }</span>

        <span class="cov8" title="1">if !isValidVolumeCapabilities([]*csi.VolumeCapability{volCap}) </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability not supported")
        }</span>
        <span class="cov8" title="1">volumeContext := req.GetVolumeContext()
        if isValidVolumeContext := isValidVolumeContext(volumeContext); !isValidVolumeContext </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume Attribute is not valid")
        }</span>

        // If the access type is block, do nothing for stage
        <span class="cov8" title="1">if _, isAccessTypeBlock := volCap.GetAccessType().(*csi.VolumeCapability_Block); isAccessTypeBlock </span><span class="cov8" title="1">{
                return &amp;csi.NodeStageVolumeResponse{}, nil
        }</span>

        <span class="cov8" title="1">mountVolume := volCap.GetMount()
        if mountVolume == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "NodeStageVolume: mount is nil within volume capability")
        }</span>

        <span class="cov8" title="1">fsType := mountVolume.GetFsType()
        if len(fsType) == 0 </span><span class="cov8" title="1">{
                fsType = defaultFsType
        }</span>

        <span class="cov8" title="1">_, ok := ValidFSTypes[strings.ToLower(fsType)]
        if !ok </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "NodeStageVolume: invalid fstype %s", fsType)
        }</span>

        <span class="cov8" title="1">context := req.GetVolumeContext()

        blockSize, err := recheckFormattingOptionParameter(context, BlockSizeKey, FileSystemConfigs, fsType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">inodeSize, err := recheckFormattingOptionParameter(context, InodeSizeKey, FileSystemConfigs, fsType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">bytesPerInode, err := recheckFormattingOptionParameter(context, BytesPerInodeKey, FileSystemConfigs, fsType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">numInodes, err := recheckFormattingOptionParameter(context, NumberOfInodesKey, FileSystemConfigs, fsType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ext4BigAlloc, err := recheckFormattingOptionParameter(context, Ext4BigAllocKey, FileSystemConfigs, fsType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ext4ClusterSize, err := recheckFormattingOptionParameter(context, Ext4ClusterSizeKey, FileSystemConfigs, fsType)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mountOptions := collectMountOptions(fsType, mountVolume.GetMountFlags())

        if ok = d.inFlight.Insert(volumeID); !ok </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, VolumeOperationAlreadyExists, volumeID)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodeStageVolume: volume operation finished", "volumeID", volumeID)
                d.inFlight.Delete(volumeID)
        }</span>()

        <span class="cov8" title="1">devicePath, ok := req.GetPublishContext()[DevicePathKey]
        if !ok </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Device path not provided")
        }</span>

        <span class="cov8" title="1">partition := ""
        if part, ok := volumeContext[VolumeAttributePartition]; ok </span><span class="cov8" title="1">{
                if part != "0" </span><span class="cov8" title="1">{
                        partition = part
                }</span> else<span class="cov8" title="1"> {
                        klog.InfoS("NodeStageVolume: invalid partition config, will ignore.", "partition", part)
                }</span>
        }

        <span class="cov8" title="1">source, err := d.mounter.FindDevicePath(devicePath, volumeID, partition, d.metadata.GetRegion())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.NotFound, "Failed to find device path %s. %v", devicePath, err)
        }</span>

        <span class="cov8" title="1">klog.V(4).InfoS("NodeStageVolume: find device path", "devicePath", devicePath, "source", source)
        exists, err := d.mounter.PathExists(target)
        if err != nil </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("failed to check if target %q exists: %v", target, err)
                return nil, status.Error(codes.Internal, msg)
        }</span>
        // When exists is true it means target path was created but device isn't mounted.
        // We don't want to do anything in that case and let the operation proceed.
        // Otherwise we need to create the target directory.
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                // If target path does not exist we need to create the directory where volume will be staged
                klog.V(4).InfoS("NodeStageVolume: creating target dir", "target", target)
                if err = d.mounter.MakeDir(target); err != nil </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf("could not create target dir %q: %v", target, err)
                        return nil, status.Error(codes.Internal, msg)
                }</span>
        }

        // Check if a device is mounted in target directory
        <span class="cov8" title="1">device, _, err := d.mounter.GetDeviceNameFromMount(target)
        if err != nil </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("failed to check if volume is already mounted: %v", err)
                return nil, status.Error(codes.Internal, msg)
        }</span>

        // This operation (NodeStageVolume) MUST be idempotent.
        // If the volume corresponding to the volume_id is already staged to the staging_target_path,
        // and is identical to the specified volume_capability the Plugin MUST reply 0 OK.
        <span class="cov8" title="1">klog.V(4).InfoS("NodeStageVolume: checking if volume is already staged", "device", device, "source", source, "target", target)
        if device == source </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodeStageVolume: volume already staged", "volumeID", volumeID)
                return &amp;csi.NodeStageVolumeResponse{}, nil
        }</span>

        // FormatAndMount will format only if needed
        <span class="cov8" title="1">klog.V(4).InfoS("NodeStageVolume: staging volume", "source", source, "volumeID", volumeID, "target", target, "fstype", fsType)
        formatOptions := []string{}
        if len(blockSize) &gt; 0 </span><span class="cov8" title="1">{
                if fsType == FSTypeXfs </span><span class="cov8" title="1">{
                        blockSize = "size=" + blockSize
                }</span>
                <span class="cov8" title="1">formatOptions = append(formatOptions, "-b", blockSize)</span>
        }
        <span class="cov8" title="1">if len(inodeSize) &gt; 0 </span><span class="cov8" title="1">{
                option := "-I"
                if fsType == FSTypeXfs </span><span class="cov8" title="1">{
                        option, inodeSize = "-i", "size="+inodeSize
                }</span>
                <span class="cov8" title="1">formatOptions = append(formatOptions, option, inodeSize)</span>
        }
        <span class="cov8" title="1">if len(bytesPerInode) &gt; 0 </span><span class="cov8" title="1">{
                formatOptions = append(formatOptions, "-i", bytesPerInode)
        }</span>
        <span class="cov8" title="1">if len(numInodes) &gt; 0 </span><span class="cov8" title="1">{
                formatOptions = append(formatOptions, "-N", numInodes)
        }</span>
        <span class="cov8" title="1">if ext4BigAlloc == "true" </span><span class="cov8" title="1">{
                formatOptions = append(formatOptions, "-O", "bigalloc")
        }</span>
        <span class="cov8" title="1">if len(ext4ClusterSize) &gt; 0 </span><span class="cov8" title="1">{
                formatOptions = append(formatOptions, "-C", ext4ClusterSize)
        }</span>
        <span class="cov8" title="1">if fsType == FSTypeXfs &amp;&amp; d.options.LegacyXFSProgs </span><span class="cov8" title="1">{
                formatOptions = append(formatOptions, "-m", "bigtime=0,inobtcount=0,reflink=0")
        }</span>
        <span class="cov8" title="1">err = d.mounter.FormatAndMountSensitiveWithFormatOptions(source, target, fsType, mountOptions, nil, formatOptions)
        if err != nil </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("could not format %q and mount it at %q: %v", source, target, err)
                return nil, status.Error(codes.Internal, msg)
        }</span>

        <span class="cov8" title="1">needResize, err := d.mounter.NeedResize(source, target)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "Could not determine if volume %q (%q) need to be resized:  %v", req.GetVolumeId(), source, err)
        }</span>

        <span class="cov8" title="1">if needResize </span><span class="cov8" title="1">{
                klog.V(2).InfoS("Volume needs resizing", "source", source)
                if _, err := d.mounter.Resize(source, target); err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "Could not resize volume %q (%q):  %v", volumeID, source, err)
                }</span>
        }
        <span class="cov8" title="1">klog.V(4).InfoS("NodeStageVolume: successfully staged volume", "source", source, "volumeID", volumeID, "target", target, "fstype", fsType)
        return &amp;csi.NodeStageVolumeResponse{}, nil</span>
}

func (d *NodeService) NodeUnstageVolume(ctx context.Context, req *csi.NodeUnstageVolumeRequest) (*csi.NodeUnstageVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeUnstageVolume: called", "args", req)
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">target := req.GetStagingTargetPath()
        if len(target) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Staging target not provided")
        }</span>

        <span class="cov8" title="1">if ok := d.inFlight.Insert(volumeID); !ok </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, VolumeOperationAlreadyExists, volumeID)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodeUnStageVolume: volume operation finished", "volumeID", volumeID)
                d.inFlight.Delete(volumeID)
        }</span>()

        // Check if target directory is a mount point. GetDeviceNameFromMount
        // given a mnt point, finds the device from /proc/mounts
        // returns the device name, reference count, and error code
        <span class="cov8" title="1">dev, refCount, err := d.mounter.GetDeviceNameFromMount(target)
        if err != nil </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("failed to check if target %q is a mount point: %v", target, err)
                return nil, status.Error(codes.Internal, msg)
        }</span>

        // From the spec: If the volume corresponding to the volume_id
        // is not staged to the staging_target_path, the Plugin MUST
        // reply 0 OK.
        <span class="cov8" title="1">if refCount == 0 </span><span class="cov8" title="1">{
                klog.V(5).InfoS("[Debug] NodeUnstageVolume: target not mounted", "target", target)
                return &amp;csi.NodeUnstageVolumeResponse{}, nil
        }</span>

        <span class="cov8" title="1">if refCount &gt; 1 </span><span class="cov8" title="1">{
                klog.InfoS("NodeUnstageVolume: found references to device mounted at target path", "refCount", refCount, "device", dev, "target", target)
        }</span>

        <span class="cov8" title="1">klog.V(4).InfoS("NodeUnstageVolume: unmounting", "target", target)
        err = d.mounter.Unstage(target)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "Could not unmount target %q: %v", target, err)
        }</span>
        <span class="cov8" title="1">klog.V(4).InfoS("NodeUnStageVolume: successfully unstaged volume", "volumeID", volumeID, "target", target)
        return &amp;csi.NodeUnstageVolumeResponse{}, nil</span>
}

func (d *NodeService) NodeExpandVolume(ctx context.Context, req *csi.NodeExpandVolumeRequest) (*csi.NodeExpandVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeExpandVolume: called", "args", util.SanitizeRequest(req))
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>
        <span class="cov8" title="1">volumePath := req.GetVolumePath()
        if len(volumePath) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "volume path must be provided")
        }</span>

        <span class="cov8" title="1">if ok := d.inFlight.Insert(volumeID); !ok </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, VolumeOperationAlreadyExists, volumeID)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodeExpandVolume: volume operation finished", "volumeId", volumeID)
                d.inFlight.Delete(volumeID)
        }</span>()

        <span class="cov8" title="1">volumeCapability := req.GetVolumeCapability()
        // VolumeCapability is optional, if specified, use that as source of truth
        if volumeCapability != nil </span><span class="cov8" title="1">{
                caps := []*csi.VolumeCapability{volumeCapability}
                if !isValidVolumeCapabilities(caps) </span><span class="cov8" title="1">{
                        return nil, status.Error(codes.InvalidArgument, ("VolumeCapability is invalid"))
                }</span>

                <span class="cov8" title="1">if blk := volumeCapability.GetBlock(); blk != nil </span><span class="cov8" title="1">{
                        // Noop for Block NodeExpandVolume
                        klog.V(4).InfoS("NodeExpandVolume: called. Since it is a block device, ignoring...", "volumeID", volumeID, "volumePath", volumePath)
                        return &amp;csi.NodeExpandVolumeResponse{}, nil
                }</span>
        } else<span class="cov8" title="1"> {
                // TODO use util.GenericResizeFS
                // VolumeCapability is nil, check if volumePath point to a block device
                isBlock, err := d.mounter.IsBlockDevice(volumePath)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "failed to determine if volumePath [%v] is a block device: %v", volumePath, err)
                }</span>
                <span class="cov8" title="1">if isBlock </span><span class="cov8" title="1">{
                        // Skip resizing for Block NodeExpandVolume
                        bcap, err := d.mounter.GetBlockSizeBytes(volumePath)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.Internal, "failed to get block capacity on path %s: %v", req.GetVolumePath(), err)
                        }</span>
                        <span class="cov8" title="1">klog.V(4).InfoS("NodeExpandVolume: called, since given volumePath is a block device, ignoring...", "volumeID", volumeID, "volumePath", volumePath)
                        return &amp;csi.NodeExpandVolumeResponse{CapacityBytes: bcap}, nil</span>
                }
        }
        <span class="cov8" title="1">deviceName, _, err := d.mounter.GetDeviceNameFromMount(volumePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "failed to get device name from mount %s: %v", volumePath, err)
        }</span>

        <span class="cov8" title="1">devicePath, err := d.mounter.FindDevicePath(deviceName, volumeID, "", d.metadata.GetRegion())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.NotFound, "failed to find device path for device name %s for mount %s: %v", deviceName, req.GetVolumePath(), err)
        }</span>

        <span class="cov8" title="1">if _, err = d.mounter.Resize(devicePath, volumePath); err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "Could not resize volume %q (%q): %v", volumeID, devicePath, err)
        }</span>

        <span class="cov8" title="1">bcap, err := d.mounter.GetBlockSizeBytes(devicePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "failed to get block capacity on path %s: %v", req.GetVolumePath(), err)
        }</span>
        <span class="cov8" title="1">return &amp;csi.NodeExpandVolumeResponse{CapacityBytes: bcap}, nil</span>
}

func (d *NodeService) NodePublishVolume(ctx context.Context, req *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodePublishVolume: called", "args", util.SanitizeRequest(req))
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">source := req.GetStagingTargetPath()
        if len(source) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Staging target not provided")
        }</span>

        <span class="cov8" title="1">target := req.GetTargetPath()
        if len(target) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Target path not provided")
        }</span>

        <span class="cov8" title="1">volCap := req.GetVolumeCapability()
        if volCap == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability not provided")
        }</span>

        <span class="cov8" title="1">if !isValidVolumeCapabilities([]*csi.VolumeCapability{volCap}) </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume capability not supported")
        }</span>

        <span class="cov8" title="1">if ok := d.inFlight.Insert(volumeID); !ok </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, VolumeOperationAlreadyExists, volumeID)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodePublishVolume: volume operation finished", "volumeId", volumeID)
                d.inFlight.Delete(volumeID)
        }</span>()

        <span class="cov8" title="1">mountOptions := []string{"bind"}
        if req.GetReadonly() </span><span class="cov8" title="1">{
                mountOptions = append(mountOptions, "ro")
        }</span>

        <span class="cov8" title="1">switch mode := volCap.GetAccessType().(type) </span>{
        case *csi.VolumeCapability_Block:<span class="cov8" title="1">
                if err := d.nodePublishVolumeForBlock(req, mountOptions); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        case *csi.VolumeCapability_Mount:<span class="cov8" title="1">
                if err := d.nodePublishVolumeForFileSystem(req, mountOptions, mode); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return &amp;csi.NodePublishVolumeResponse{}, nil</span>
}

func (d *NodeService) NodeUnpublishVolume(ctx context.Context, req *csi.NodeUnpublishVolumeRequest) (*csi.NodeUnpublishVolumeResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeUnpublishVolume: called", "args", util.SanitizeRequest(req))
        volumeID := req.GetVolumeId()
        if len(volumeID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Volume ID not provided")
        }</span>

        <span class="cov8" title="1">target := req.GetTargetPath()
        if len(target) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "Target path not provided")
        }</span>

        <span class="cov8" title="1">if ok := d.inFlight.Insert(volumeID); !ok </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Aborted, VolumeOperationAlreadyExists, volumeID)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodeUnpublishVolume: volume operation finished", "volumeId", volumeID)
                d.inFlight.Delete(volumeID)
        }</span>()

        <span class="cov8" title="1">klog.V(4).InfoS("NodeUnpublishVolume: unmounting", "target", target)
        err := d.mounter.Unpublish(target)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "Could not unmount %q: %v", target, err)
        }</span>

        <span class="cov8" title="1">return &amp;csi.NodeUnpublishVolumeResponse{}, nil</span>
}

func (d *NodeService) NodeGetVolumeStats(ctx context.Context, req *csi.NodeGetVolumeStatsRequest) (*csi.NodeGetVolumeStatsResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeGetVolumeStats: called", "args", req)
        if len(req.GetVolumeId()) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats volume ID was empty")
        }</span>
        <span class="cov8" title="1">if len(req.GetVolumePath()) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats volume path was empty")
        }</span>

        <span class="cov8" title="1">exists, err := d.mounter.PathExists(req.GetVolumePath())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "unknown error when stat on %s: %v", req.GetVolumePath(), err)
        }</span>
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.NotFound, "path %s does not exist", req.GetVolumePath())
        }</span>

        <span class="cov8" title="1">isBlock, err := d.mounter.IsBlockDevice(req.GetVolumePath())

        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.Internal, "failed to determine whether %s is block device: %v", req.GetVolumePath(), err)
        }</span>
        <span class="cov8" title="1">if isBlock </span><span class="cov8" title="1">{
                bcap, blockErr := d.mounter.GetBlockSizeBytes(req.GetVolumePath())
                if blockErr != nil </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.Internal, "failed to get block capacity on path %s: %v", req.GetVolumePath(), blockErr)
                }</span>
                <span class="cov8" title="1">return &amp;csi.NodeGetVolumeStatsResponse{
                        Usage: []*csi.VolumeUsage{
                                {
                                        Unit:  csi.VolumeUsage_BYTES,
                                        Total: bcap,
                                },
                        },
                }, nil</span>
        }

        <span class="cov8" title="1">stats, err := d.mounter.GetVolumeStats(req.GetVolumePath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to get fs info on path %s: %v", req.GetVolumePath(), err)
        }</span>

        <span class="cov8" title="1">usage := []*csi.VolumeUsage{
                {
                        Unit:      csi.VolumeUsage_BYTES,
                        Available: stats.AvailableBytes,
                        Total:     stats.TotalBytes,
                        Used:      stats.UsedBytes,
                },
        }
        if stats.TotalInodes != 0 </span><span class="cov0" title="0">{
                usage = append(usage, &amp;csi.VolumeUsage{
                        Unit:      csi.VolumeUsage_INODES,
                        Available: stats.AvailableInodes,
                        Total:     stats.TotalInodes,
                        Used:      stats.UsedInodes,
                })
        }</span>

        <span class="cov8" title="1">return &amp;csi.NodeGetVolumeStatsResponse{
                Usage: usage,
        }, nil</span>
}

func (d *NodeService) NodeGetCapabilities(ctx context.Context, req *csi.NodeGetCapabilitiesRequest) (*csi.NodeGetCapabilitiesResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeGetCapabilities: called", "args", req)
        caps := make([]*csi.NodeServiceCapability, 0, len(nodeCaps))
        for _, cap := range nodeCaps </span><span class="cov8" title="1">{
                c := &amp;csi.NodeServiceCapability{
                        Type: &amp;csi.NodeServiceCapability_Rpc{
                                Rpc: &amp;csi.NodeServiceCapability_RPC{
                                        Type: cap,
                                },
                        },
                }
                caps = append(caps, c)
        }</span>
        <span class="cov8" title="1">return &amp;csi.NodeGetCapabilitiesResponse{Capabilities: caps}, nil</span>
}

func (d *NodeService) NodeGetInfo(ctx context.Context, req *csi.NodeGetInfoRequest) (*csi.NodeGetInfoResponse, error) <span class="cov8" title="1">{
        klog.V(4).InfoS("NodeGetInfo: called", "args", req)

        if err := d.metadata.UpdateMetadata(d.k8sClient); err != nil </span><span class="cov8" title="1">{
                klog.ErrorS(err, "Failed to update metadata, using cached values")
        }</span>

        <span class="cov8" title="1">zone := d.metadata.GetAvailabilityZone()
        osType := runtime.GOOS

        segments := map[string]string{
                ZoneTopologyKey:          zone,
                WellKnownZoneTopologyKey: zone,
                OSTopologyKey:            osType,
        }

        outpostArn := d.metadata.GetOutpostArn()

        // to my surprise ARN's string representation is not empty for empty ARN
        if len(outpostArn.Resource) &gt; 0 </span><span class="cov8" title="1">{
                segments[AwsRegionKey] = outpostArn.Region
                segments[AwsPartitionKey] = outpostArn.Partition
                segments[AwsAccountIDKey] = outpostArn.AccountID
                segments[AwsOutpostIDKey] = outpostArn.Resource
        }</span>

        <span class="cov8" title="1">topology := &amp;csi.Topology{Segments: segments}
        maxVolumesPerNode := d.getVolumesLimit()
        klog.V(4).InfoS("NodeGetInfo:", "maxVolumesPerNode", maxVolumesPerNode)
        return &amp;csi.NodeGetInfoResponse{
                NodeId:             d.metadata.GetInstanceID(),
                MaxVolumesPerNode:  maxVolumesPerNode,
                AccessibleTopology: topology,
        }, nil</span>
}

func (d *NodeService) nodePublishVolumeForBlock(req *csi.NodePublishVolumeRequest, mountOptions []string) error <span class="cov8" title="1">{
        target := req.GetTargetPath()
        volumeID := req.GetVolumeId()
        volumeContext := req.GetVolumeContext()

        devicePath, exists := req.GetPublishContext()[DevicePathKey]
        if !exists </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Device path not provided")
        }</span>
        <span class="cov8" title="1">if isValidVolumeContext := isValidVolumeContext(volumeContext); !isValidVolumeContext </span><span class="cov8" title="1">{
                return status.Error(codes.InvalidArgument, "Volume Attribute is invalid")
        }</span>

        <span class="cov8" title="1">partition := ""
        if part, ok := req.GetVolumeContext()[VolumeAttributePartition]; ok </span><span class="cov8" title="1">{
                if part != "0" </span><span class="cov8" title="1">{
                        partition = part
                }</span> else<span class="cov8" title="1"> {
                        klog.InfoS("NodePublishVolume: invalid partition config, will ignore.", "partition", part)
                }</span>
        }

        <span class="cov8" title="1">source, err := d.mounter.FindDevicePath(devicePath, volumeID, partition, d.metadata.GetRegion())
        if err != nil </span><span class="cov8" title="1">{
                return status.Errorf(codes.NotFound, "Failed to find device path %s. %v", devicePath, err)
        }</span>

        <span class="cov8" title="1">klog.V(4).InfoS("NodePublishVolume [block]: find device path", "devicePath", devicePath, "source", source)

        globalMountPath := filepath.Dir(target)

        // create the global mount path if it is missing
        // Path in the form of /var/lib/kubelet/plugins/kubernetes.io/csi/volumeDevices/publish/{volumeName}
        exists, err = d.mounter.PathExists(globalMountPath)
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "Could not check if path exists %q: %v", globalMountPath, err)
        }</span>

        <span class="cov8" title="1">if !exists </span><span class="cov0" title="0">{
                if err = d.mounter.MakeDir(globalMountPath); err != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "Could not create dir %q: %v", globalMountPath, err)
                }</span>
        }

        // Create the mount point as a file since bind mount device node requires it to be a file
        // This implementation detail is relied upon by the NVMECollector,
        // which discovers block devices by parsing /proc/self/mountinfo. The bind mount
        // created here ensures block devices appear in mountinfo even without a filesystem.
        <span class="cov8" title="1">klog.V(4).InfoS("NodePublishVolume [block]: making target file", "target", target)
        if err = d.mounter.MakeFile(target); err != nil </span><span class="cov0" title="0">{
                if removeErr := os.Remove(target); removeErr != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "Could not remove mount target %q: %v", target, removeErr)
                }</span>
                <span class="cov0" title="0">return status.Errorf(codes.Internal, "Could not create file %q: %v", target, err)</span>
        }

        // Checking if the target file is already mounted with a device.
        <span class="cov8" title="1">mounted, err := d.isMounted(source, target)
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "Could not check if %q is mounted: %v", target, err)
        }</span>

        <span class="cov8" title="1">if !mounted </span><span class="cov8" title="1">{
                klog.V(4).InfoS("NodePublishVolume [block]: mounting", "source", source, "target", target)
                if err := d.mounter.Mount(source, target, "", mountOptions); err != nil </span><span class="cov0" title="0">{
                        if removeErr := os.Remove(target); removeErr != nil </span><span class="cov0" title="0">{
                                return status.Errorf(codes.Internal, "Could not remove mount target %q: %v", target, removeErr)
                        }</span>
                        <span class="cov0" title="0">return status.Errorf(codes.Internal, "Could not mount %q at %q: %v", source, target, err)</span>
                }
        } else<span class="cov0" title="0"> {
                klog.V(4).InfoS("NodePublishVolume [block]: Target path is already mounted", "target", target)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// isMounted checks if target is mounted. It does NOT return an error if target
// doesn't exist.
func (d *NodeService) isMounted(_ string, target string) (bool, error) <span class="cov8" title="1">{
        /*
                Checking if it's a mount point using IsLikelyNotMountPoint. There are three different return values,
                1. true, err when the directory does not exist or corrupted.
                2. false, nil when the path is already mounted with a device.
                3. true, nil when the path is not mounted with any device.
        */
        notMnt, err := d.mounter.IsLikelyNotMountPoint(target)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                // Checking if the path exists and error is related to Corrupted Mount, in that case, the system could unmount and mount.
                _, pathErr := d.mounter.PathExists(target)
                if pathErr != nil &amp;&amp; d.mounter.IsCorruptedMnt(pathErr) </span><span class="cov0" title="0">{
                        klog.V(4).InfoS("NodePublishVolume: Target path is a corrupted mount. Trying to unmount.", "target", target)
                        if mntErr := d.mounter.Unpublish(target); mntErr != nil </span><span class="cov0" title="0">{
                                return false, status.Errorf(codes.Internal, "Unable to unmount the target %q : %v", target, mntErr)
                        }</span>
                        // After successful unmount, the device is ready to be mounted.
                        <span class="cov0" title="0">return false, nil</span>
                }
                <span class="cov0" title="0">return false, status.Errorf(codes.Internal, "Could not check if %q is a mount point: %v, %v", target, err, pathErr)</span>
        }

        // Do not return os.IsNotExist error. Other errors were handled above.  The
        // Existence of the target should be checked by the caller explicitly and
        // independently because sometimes prior to mount it is expected not to exist
        // (in Windows, the target must NOT exist before a symlink is created at it)
        // and in others it is an error (in Linux, the target mount directory must
        // exist before mount is called on it)
        <span class="cov8" title="1">if err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov0" title="0">{
                klog.V(5).InfoS("[Debug] NodePublishVolume: Target path does not exist", "target", target)
                return false, nil
        }</span>

        <span class="cov8" title="1">if !notMnt </span><span class="cov0" title="0">{
                klog.V(4).InfoS("NodePublishVolume: Target path is already mounted", "target", target)
        }</span>

        <span class="cov8" title="1">return !notMnt, nil</span>
}

func (d *NodeService) nodePublishVolumeForFileSystem(req *csi.NodePublishVolumeRequest, mountOptions []string, mode *csi.VolumeCapability_Mount) error <span class="cov8" title="1">{
        target := req.GetTargetPath()
        source := req.GetStagingTargetPath()
        if m := mode.Mount; m != nil </span><span class="cov8" title="1">{
                for _, f := range m.GetMountFlags() </span><span class="cov0" title="0">{
                        if !hasMountOption(mountOptions, f) </span><span class="cov0" title="0">{
                                mountOptions = append(mountOptions, f)
                        }</span>
                }
        }

        <span class="cov8" title="1">if err := d.mounter.PreparePublishTarget(target); err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "%s", err.Error())
        }</span>

        // Checking if the target directory is already mounted with a device.
        <span class="cov8" title="1">mounted, err := d.isMounted(source, target)
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.Internal, "Could not check if %q is mounted: %v", target, err)
        }</span>

        <span class="cov8" title="1">if !mounted </span><span class="cov8" title="1">{
                fsType := mode.Mount.GetFsType()
                if len(fsType) == 0 </span><span class="cov8" title="1">{
                        fsType = defaultFsType
                }</span>

                <span class="cov8" title="1">_, ok := ValidFSTypes[strings.ToLower(fsType)]
                if !ok </span><span class="cov0" title="0">{
                        return status.Errorf(codes.InvalidArgument, "NodePublishVolume: invalid fstype %s", fsType)
                }</span>

                <span class="cov8" title="1">mountOptions = collectMountOptions(fsType, mountOptions)
                klog.V(4).InfoS("NodePublishVolume: mounting", "source", source, "target", target, "mountOptions", mountOptions, "fsType", fsType)
                if err := d.mounter.Mount(source, target, fsType, mountOptions); err != nil </span><span class="cov0" title="0">{
                        return status.Errorf(codes.Internal, "Could not mount %q at %q: %v", source, target, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getVolumesLimit returns the limit of volumes that the node supports.
func (d *NodeService) getVolumesLimit() int64 <span class="cov8" title="1">{
        if d.options.VolumeAttachLimit &gt;= 0 </span><span class="cov8" title="1">{
                klog.V(4).InfoS("getVolumesLimit: VolumeAttachLimit manually set to", d.options.VolumeAttachLimit, "overriding the default value")
                return d.options.VolumeAttachLimit
        }</span>

        <span class="cov8" title="1">instanceType := d.metadata.GetInstanceType()
        klog.V(4).InfoS("getVolumesLimit:", "instanceType", instanceType)

        isNitro := cloud.IsNitroInstanceType(instanceType)
        availableAttachments := cloud.GetMaxAttachments(isNitro)
        klog.V(4).InfoS("getVolumesLimit:", "availableAttachments", availableAttachments)

        reservedVolumeAttachments := d.options.ReservedVolumeAttachments
        if reservedVolumeAttachments == -1 </span><span class="cov8" title="1">{
                reservedVolumeAttachments = d.metadata.GetNumBlockDeviceMappings() + 1 // +1 for the root device
                klog.V(4).InfoS("getVolumesLimit:", "numBlockDevices", (reservedVolumeAttachments - 1))
        }</span>
        <span class="cov8" title="1">klog.V(4).InfoS("getVolumesLimit:", "reservedVolumeAttachments", reservedVolumeAttachments)

        dedicatedLimit := cloud.GetDedicatedLimitForInstanceType(instanceType)
        maxEBSAttachments, hasMaxVolumeLimit := cloud.GetEBSLimitForInstanceType(instanceType)
        if hasMaxVolumeLimit </span><span class="cov8" title="1">{
                availableAttachments = min(maxEBSAttachments, availableAttachments)
        }</span>
        // For special dedicated limit instance types, the limit is only for EBS volumes
        // For (all other) Nitro instances, attachments are shared between EBS volumes, ENIs and NVMe instance stores
        <span class="cov8" title="1">if dedicatedLimit != 0 </span><span class="cov8" title="1">{
                availableAttachments = dedicatedLimit
                klog.V(4).InfoS("getVolumesLimit:", "dedicatedLimit", dedicatedLimit)
        }</span> else<span class="cov8" title="1"> if isNitro </span><span class="cov8" title="1">{
                enis := d.metadata.GetNumAttachedENIs()
                klog.V(4).InfoS("getVolumesLimit:", "ENIs", enis)
                reservedSlots := cloud.GetReservedSlotsForInstanceType(instanceType)
                klog.V(4).InfoS("getVolumesLimit:", "reservedSlots", reservedSlots)
                if hasMaxVolumeLimit </span><span class="cov8" title="1">{
                        availableAttachments = availableAttachments - (enis - 1) - reservedSlots
                }</span> else<span class="cov8" title="1"> {
                        availableAttachments = availableAttachments - enis - reservedSlots
                }</span>
        }
        <span class="cov8" title="1">availableAttachments -= reservedVolumeAttachments
        if availableAttachments &lt;= 0 </span><span class="cov8" title="1">{
                availableAttachments = 1
        }</span>

        <span class="cov8" title="1">return int64(availableAttachments)</span>
}

// hasMountOption returns a boolean indicating whether the given
// slice already contains a mount option. This is used to prevent
// passing duplicate option to the mount command.
func hasMountOption(options []string, opt string) bool <span class="cov8" title="1">{
        for _, o := range options </span><span class="cov0" title="0">{
                if o == opt </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// collectMountOptions returns array of mount options from
// VolumeCapability_MountVolume and special mount options for
// given filesystem.
func collectMountOptions(fsType string, mntFlags []string) []string <span class="cov8" title="1">{
        var options []string
        for _, opt := range mntFlags </span><span class="cov8" title="1">{
                if !hasMountOption(options, opt) </span><span class="cov8" title="1">{
                        options = append(options, opt)
                }</span>
        }

        // By default, xfs does not allow mounting of two volumes with the same filesystem uuid.
        // Force ignore this uuid to be able to mount volume + its clone / restored snapshot on the same node.
        <span class="cov8" title="1">if fsType == FSTypeXfs </span><span class="cov8" title="1">{
                if !hasMountOption(options, "nouuid") </span><span class="cov8" title="1">{
                        options = append(options, "nouuid")
                }</span>
        }
        <span class="cov8" title="1">return options</span>
}

// startNotReadyTaintWatcher launches a short‑lived Node informer that removes the
// ebs.csi.aws.com/agent‑not‑ready taint. The informer is stopped after maxWatchDuration.
func startNotReadyTaintWatcher(clientset kubernetes.Interface, maxWatchDuration time.Duration) <span class="cov8" title="1">{
        nodeName := os.Getenv("CSI_NODE_NAME")
        if nodeName == "" </span><span class="cov8" title="1">{
                klog.V(4).InfoS("CSI_NODE_NAME missing, skipping taint watcher")
                return
        }</span>

        <span class="cov8" title="1">factory := informers.NewSharedInformerFactoryWithOptions(
                clientset,
                0, // No resync
                informers.WithTweakListOptions(func(lo *metav1.ListOptions) </span><span class="cov8" title="1">{
                        lo.FieldSelector = "metadata.name=" + nodeName
                }</span>),
        )
        <span class="cov8" title="1">informer := factory.Core().V1().Nodes().Informer()

        attemptTaintRemoval := func(n *corev1.Node) </span><span class="cov8" title="1">{
                if !hasNotReadyTaint(n) </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">backoff := wait.Backoff{
                        Duration: 2 * time.Second,
                        Factor:   1.5,
                        Steps:    5,
                }

                ctx, cancel := context.WithTimeout(context.Background(), maxWatchDuration)
                defer cancel()

                err := wait.ExponentialBackoffWithContext(ctx, backoff, func(ctx context.Context) (bool, error) </span><span class="cov8" title="1">{
                        if err := removeNotReadyTaint(ctx, clientset, n); err != nil </span><span class="cov0" title="0">{
                                klog.ErrorS(err, "Failed to remove agent-not-ready taint, retrying", "node", n.Name)
                                return false, nil // Continue retrying
                        }</span>
                        <span class="cov8" title="1">klog.V(2).InfoS("Successfully removed agent-not-ready taint", "node", n.Name)
                        return true, nil</span>
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "Timed out trying to remove agent-not-ready taint", "node", n.Name)
                }</span>
        }

        <span class="cov8" title="1">if _, err := informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov8" title="1">{
                        if n, ok := obj.(*corev1.Node); ok </span><span class="cov8" title="1">{
                                attemptTaintRemoval(n)
                        }</span>
                },
                UpdateFunc: func(_, newObj interface{}) <span class="cov8" title="1">{
                        if n, ok := newObj.(*corev1.Node); ok </span><span class="cov8" title="1">{
                                attemptTaintRemoval(n)
                        }</span>
                },
        }); err != nil <span class="cov0" title="0">{
                klog.ErrorS(err, "Taint‑watcher: failed to add event handler")
                return
        }</span>

        <span class="cov8" title="1">stopCh := make(chan struct{})

        go func() </span><span class="cov8" title="1">{
                factory.Start(stopCh)

                if ok := cache.WaitForCacheSync(stopCh, informer.HasSynced); !ok </span><span class="cov0" title="0">{
                        klog.ErrorS(nil, "Taint-watcher: cache sync failed")
                }</span>

                // Immediate scan in case the taint is already present and no event fires.
                <span class="cov8" title="1">if obj, exists, err := informer.GetStore().GetByKey(nodeName); err == nil &amp;&amp; exists </span><span class="cov8" title="1">{
                        if n, ok := obj.(*corev1.Node); ok </span><span class="cov8" title="1">{
                                attemptTaintRemoval(n)
                        }</span>
                }

                <span class="cov8" title="1">&lt;-time.After(maxWatchDuration)
                klog.V(8).InfoS("Taint-watcher timeout reached; stopping")
                close(stopCh)</span>
        }()
}

func hasNotReadyTaint(n *corev1.Node) bool <span class="cov8" title="1">{
        for _, t := range n.Spec.Taints </span><span class="cov8" title="1">{
                if t.Key == AgentNotReadyNodeTaintKey </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Struct for JSON patch operations.
type JSONPatch struct {
        OP    string      `json:"op,omitempty"`
        Path  string      `json:"path,omitempty"`
        Value interface{} `json:"value"`
}

// removeNotReadyTaint removes the taint ebs.csi.aws.com/agent-not-ready from the local node
// This taint can be optionally applied by users to prevent startup race conditions such as
// https://github.com/kubernetes/kubernetes/issues/95911
func removeNotReadyTaint(ctx context.Context, clientset kubernetes.Interface, node *corev1.Node) error <span class="cov8" title="1">{
        err := checkAllocatable(ctx, clientset, node.Name)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var taintsToKeep []corev1.Taint
        for _, taint := range node.Spec.Taints </span><span class="cov8" title="1">{
                if taint.Key != AgentNotReadyNodeTaintKey </span><span class="cov8" title="1">{
                        taintsToKeep = append(taintsToKeep, taint)
                }</span> else<span class="cov8" title="1"> {
                        klog.V(4).InfoS("Queued taint for removal", "key", taint.Key, "effect", taint.Effect)
                }</span>
        }

        <span class="cov8" title="1">if len(taintsToKeep) == len(node.Spec.Taints) </span><span class="cov8" title="1">{
                klog.V(4).InfoS("No taints to remove on node, skipping taint removal")
                return nil
        }</span>

        <span class="cov8" title="1">patchRemoveTaints := []JSONPatch{
                {
                        OP:    "test",
                        Path:  "/spec/taints",
                        Value: node.Spec.Taints,
                },
                {
                        OP:    "replace",
                        Path:  "/spec/taints",
                        Value: taintsToKeep,
                },
        }

        patch, err := json.Marshal(patchRemoveTaints)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = clientset.CoreV1().Nodes().Patch(ctx, node.Name, k8stypes.JSONPatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">klog.InfoS("Removed taint(s) from local node", "node", node.Name)
        return nil</span>
}

func checkAllocatable(ctx context.Context, clientset kubernetes.Interface, nodeName string) error <span class="cov8" title="1">{
        csiNode, err := clientset.StorageV1().CSINodes().Get(ctx, nodeName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("isAllocatableSet: failed to get CSINode for %s: %w", nodeName, err)
        }</span>

        <span class="cov8" title="1">for _, driver := range csiNode.Spec.Drivers </span><span class="cov8" title="1">{
                if driver.Name == DriverName </span><span class="cov8" title="1">{
                        if driver.Allocatable != nil &amp;&amp; driver.Allocatable.Count != nil </span><span class="cov8" title="1">{
                                klog.InfoS("CSINode Allocatable value is set", "nodeName", nodeName, "count", *driver.Allocatable.Count)
                                return nil
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("isAllocatableSet: allocatable value not set for driver on node %s", nodeName)</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("isAllocatableSet: driver not found on node %s", nodeName)</span>
}

func recheckFormattingOptionParameter(context map[string]string, key string, fsConfigs map[string]fileSystemConfig, fsType string) (value string, err error) <span class="cov8" title="1">{
        v, ok := context[key]
        if ok </span><span class="cov8" title="1">{
                // This check is already performed on the controller side
                // However, because it is potentially security-sensitive, we redo it here to be safe
                if isAlphanumeric := util.StringIsAlphanumeric(v); !isAlphanumeric </span><span class="cov8" title="1">{
                        return "", status.Errorf(codes.InvalidArgument, "Invalid %s (aborting!): %v", key, err)
                }</span>

                // In the case that the default fstype does not support custom sizes we could
                // be using an invalid fstype, so recheck that here
                <span class="cov8" title="1">if supported := fsConfigs[strings.ToLower(fsType)].isParameterSupported(key); !supported </span><span class="cov0" title="0">{
                        return "", status.Errorf(codes.InvalidArgument, "Cannot use %s with fstype %s", key, fsType)
                }</span>
        }
        <span class="cov8" title="1">return v, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "errors"
        "strings"
        "time"

        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud/metadata"
        flag "github.com/spf13/pflag"
        cliflag "k8s.io/component-base/cli/flag"
)

// Options contains options and configuration settings for the driver.
type Options struct {
        Mode Mode

        // Kubeconfig is an absolute path to a kubeconfig file.
        // If empty, the in-cluster config will be loaded.
        Kubeconfig string

        // #### Server options ####

        // Endpoint is the endpoint for the CSI driver server
        Endpoint string
        // HTTPEndpoint is the TCP network address where the HTTP server for metrics will listen
        HTTPEndpoint string
        // MetricsCertFile is the location of the certificate for serving the metrics server over HTTPS
        MetricsCertFile string
        // MetricsKeyFile is the location of the key for serving the metrics server over HTTPS
        MetricsKeyFile string
        // EnableOtelTracing is a flag to enable opentelemetry tracing for the driver
        EnableOtelTracing bool

        // #### Controller options ####

        // ExtraTags is a map of tags that will be attached to each dynamically provisioned
        // resource.
        ExtraTags map[string]string
        // ExtraVolumeTags is a map of tags that will be attached to each dynamically provisioned
        // volume.
        // Deprecated: Use ExtraTags instead.
        ExtraVolumeTags map[string]string
        // ID of the kubernetes cluster.
        KubernetesClusterID string
        // flag to enable sdk debug log
        AwsSdkDebugLog bool
        // flag to warn on invalid tag, instead of returning an error
        WarnOnInvalidTag bool
        // flag to set user agent
        UserAgentExtra string
        // flag to enable batching of API calls
        Batching bool
        // flag to set the timeout for volume modification requests to be coalesced into a single
        // volume modification call to AWS.
        ModifyVolumeRequestHandlerTimeout time.Duration
        // flag to enable deprecated metrics
        DeprecatedMetrics bool

        // #### Node options #####

        // VolumeAttachLimit specifies the value that shall be reported as "maximum number of attachable volumes"
        // in CSINode objects. It is similar to https://kubernetes.io/docs/concepts/storage/storage-limits/#custom-limits
        // which allowed administrators to specify custom volume limits by configuring the kube-scheduler. Also, each AWS
        // machine type has different volume limits. By default, the EBS CSI driver parses the machine type name and then
        // decides the volume limit. However, this is only a rough approximation and not good enough in most cases.
        // Specifying the volume attach limit via command line is the alternative until a more sophisticated solution presents
        // itself (dynamically discovering the maximum number of attachable volume per EC2 machine type, see also
        // https://github.com/kubernetes-sigs/aws-ebs-csi-driver/issues/347).
        VolumeAttachLimit int64
        // ReservedVolumeAttachments specifies number of volume attachments reserved for system use.
        // Typically 1 for the root disk, but may be larger when more system disks are attached to nodes.
        // This option is not used when --volume-attach-limit is specified.
        // When -1, the amount of reserved attachments is loaded from instance metadata that captured state at node boot
        // and may include not only system disks but also CSI volumes (and therefore it may be wrong).
        ReservedVolumeAttachments int
        // ALPHA: WindowsHostProcess indicates whether the driver is running in a Windows privileged container
        WindowsHostProcess bool
        // LegacyXFSProgs formats XFS volumes with `bigtime=0,inobtcount=0,reflink=0`, so that they can be mounted onto nodes with linux kernel ≤ v5.4. Volumes formatted with this option may experience issues after 2038, and will be unable to use some XFS features (for example, reflinks).
        LegacyXFSProgs bool
        // CsiMountPointPath is the path where CSI volumes are expected to be mounted on the node.
        CsiMountPointPath string
        // MetadataSources dictates which sources are used to retrieve instance metadata.
        // The driver will attempt to rely on each source in order until one succeeds.
        // Valid options include 'imds' and 'kubernetes'.
        MetadataSources []string
}

func (o *Options) AddFlags(f *flag.FlagSet) <span class="cov8" title="1">{
        f.StringVar(&amp;o.Kubeconfig, "kubeconfig", "", "Absolute path to a kubeconfig file. The default is the empty string, which causes the in-cluster config to be used")

        // Server options
        f.StringVar(&amp;o.Endpoint, "endpoint", DefaultCSIEndpoint, "Endpoint for the CSI driver server")
        f.StringVar(&amp;o.HTTPEndpoint, "http-endpoint", "", "The TCP network address where the HTTP server for metrics will listen (example: `:8080`). The default is empty string, which means the server is disabled.")
        f.StringVar(&amp;o.MetricsCertFile, "metrics-cert-file", "", "The path to a certificate to use for serving the metrics server over HTTPS. If the certificate is signed by a certificate authority, this file should be the concatenation of the server's certificate, any intermediates, and the CA's certificate. If this is non-empty, --http-endpoint and --metrics-key-file MUST also be non-empty.")
        f.StringVar(&amp;o.MetricsKeyFile, "metrics-key-file", "", "The path to a key to use for serving the metrics server over HTTPS. If this is non-empty, --http-endpoint and --metrics-cert-file MUST also be non-empty.")
        f.BoolVar(&amp;o.EnableOtelTracing, "enable-otel-tracing", false, "To enable opentelemetry tracing for the driver. The tracing is disabled by default. Configure the exporter endpoint with OTEL_EXPORTER_OTLP_ENDPOINT and other env variables, see https://opentelemetry.io/docs/specs/otel/configuration/sdk-environment-variables/#general-sdk-configuration.")
        f.StringSliceVar(&amp;o.MetadataSources, "metadata-sources", metadata.DefaultMetadataSources, "Dictates which sources are used to retrieve instance metadata. The driver will attempt to rely on each source in order until one succeeds. Valid options include 'imds' and 'kubernetes'.")

        // Controller options
        if o.Mode == AllMode || o.Mode == ControllerMode </span><span class="cov8" title="1">{
                f.Var(cliflag.NewMapStringString(&amp;o.ExtraTags), "extra-tags", "Extra tags to attach to each dynamically provisioned resource. It is a comma separated list of key value pairs like '&lt;key1&gt;=&lt;value1&gt;,&lt;key2&gt;=&lt;value2&gt;'")
                f.Var(cliflag.NewMapStringString(&amp;o.ExtraVolumeTags), "extra-volume-tags", "DEPRECATED: Please use --extra-tags instead. Extra volume tags to attach to each dynamically provisioned volume. It is a comma separated list of key value pairs like '&lt;key1&gt;=&lt;value1&gt;,&lt;key2&gt;=&lt;value2&gt;'")
                f.StringVar(&amp;o.KubernetesClusterID, "k8s-tag-cluster-id", "", "ID of the Kubernetes cluster used for tagging provisioned EBS volumes (optional).")
                f.BoolVar(&amp;o.AwsSdkDebugLog, "aws-sdk-debug-log", false, "To enable the aws sdk debug log level (default to false).")
                f.BoolVar(&amp;o.WarnOnInvalidTag, "warn-on-invalid-tag", false, "To warn on invalid tags, instead of returning an error")
                f.StringVar(&amp;o.UserAgentExtra, "user-agent-extra", "", "Extra string appended to user agent.")
                f.BoolVar(&amp;o.Batching, "batching", false, "To enable batching of API calls. This is especially helpful for improving performance in workloads that are sensitive to EC2 rate limits.")
                f.DurationVar(&amp;o.ModifyVolumeRequestHandlerTimeout, "modify-volume-request-handler-timeout", DefaultModifyVolumeRequestHandlerTimeout, "Timeout for the window in which volume modification calls must be received in order for them to coalesce into a single volume modification call to AWS. This must be lower than the csi-resizer and volumemodifier timeouts")
                f.BoolVar(&amp;o.DeprecatedMetrics, "deprecated-metrics", false, "DEPRECATED: To enable deprecated metrics. This parameter is only for backward compatibility and may be removed in a future release.")
        }</span>
        // Node options
        <span class="cov8" title="1">if o.Mode == AllMode || o.Mode == NodeMode </span><span class="cov8" title="1">{
                f.Int64Var(&amp;o.VolumeAttachLimit, "volume-attach-limit", -1, "Value for the maximum number of volumes attachable per node. If specified, the limit applies to all nodes and overrides --reserved-volume-attachments. If not specified, the value is approximated from the instance type.")
                f.IntVar(&amp;o.ReservedVolumeAttachments, "reserved-volume-attachments", -1, "Number of volume attachments reserved for system use. Not used when --volume-attach-limit is specified. The total amount of volume attachments for a node is computed as: &lt;nr. of attachments for corresponding instance type&gt; - &lt;number of NICs, if relevant to the instance type&gt; - &lt;reserved-volume-attachments value&gt;. When -1, the amount of reserved attachments is loaded from instance metadata that captured state at node boot and may include not only system disks but also CSI volumes.")
                f.BoolVar(&amp;o.WindowsHostProcess, "windows-host-process", false, "ALPHA: Indicates whether the driver is running in a Windows privileged container")
                f.BoolVar(&amp;o.LegacyXFSProgs, "legacy-xfs", false, "Warning: This option will be removed in a future version of EBS CSI Driver. Formats XFS volumes with `bigtime=0,inobtcount=0,reflink=0`, so that they can be mounted onto nodes with linux kernel ≤ v5.4. Volumes formatted with this option may experience issues after 2038, and will be unable to use some XFS features (for example, reflinks).")
                f.StringVar(&amp;o.CsiMountPointPath, "csi-mount-point-prefix", "", "A prefix of the mountpoints of all CSI-managed volumes. If this value is non-empty, all volumes mounted to a path beginning with the provided value are assumed to be CSI volumes owned by the EBS CSI Driver and safe to treat as such (for example, by exposing volume metrics).")
        }</span>
}

func (o *Options) Validate() error <span class="cov8" title="1">{
        if o.Mode == AllMode || o.Mode == NodeMode </span><span class="cov8" title="1">{
                if o.VolumeAttachLimit != -1 &amp;&amp; o.ReservedVolumeAttachments != -1 </span><span class="cov8" title="1">{
                        return errors.New("only one of --volume-attach-limit and --reserved-volume-attachments may be specified")
                }</span>
        }

        <span class="cov8" title="1">if o.MetricsCertFile != "" || o.MetricsKeyFile != "" </span><span class="cov8" title="1">{
                switch </span>{
                case o.HTTPEndpoint == "":<span class="cov8" title="1">
                        return errors.New("--http-endpoint MUST be specified when using the metrics server with HTTPS")</span>
                case o.MetricsCertFile == "":<span class="cov8" title="1">
                        return errors.New("--metrics-cert-file MUST be specified when using the metrics server with HTTPS")</span>
                case o.MetricsKeyFile == "":<span class="cov8" title="1">
                        return errors.New("--metrics-key-file MUST be specified when using the metrics server with HTTPS")</span>
                }
        }

        <span class="cov8" title="1">for i, s := range o.MetadataSources </span><span class="cov8" title="1">{
                s = strings.ToLower(strings.TrimSpace(s))
                switch s </span>{
                case metadata.SourceIMDS, metadata.SourceK8s:<span class="cov8" title="1">
                        o.MetadataSources[i] = s</span>
                default:<span class="cov8" title="1">
                        return metadata.InvalidSourceErr(o.MetadataSources, s)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2023 The Kubernetes Authors.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "context"
        "fmt"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        "k8s.io/klog/v2"
)

func InitOtelTracing() (*otlptrace.Exporter, error) <span class="cov0" title="0">{
        // Setup OTLP exporter
        ctx := context.Background()
        exporter, err := otlptracegrpc.New(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create the OTLP exporter: %w", err)
        }</span>

        // Resource will auto populate spans with common attributes
        <span class="cov0" title="0">resource, err := resource.New(ctx,
                resource.WithFromEnv(), // pull attributes from OTEL_RESOURCE_ATTRIBUTES and OTEL_SERVICE_NAME environment variables
                resource.WithProcess(),
                resource.WithOS(),
                resource.WithContainer(),
                resource.WithHost(),
        )
        if err != nil </span><span class="cov0" title="0">{
                klog.ErrorS(err, "failed to create the OTLP resource, spans will lack some metadata")
        }</span>

        // Create a trace provider with the exporter.
        // Use propagator and sampler defined in environment variables.
        <span class="cov0" title="0">traceProvider := trace.NewTracerProvider(trace.WithBatcher(exporter), trace.WithResource(resource))

        // Register the trace provider as global.
        otel.SetTracerProvider(traceProvider)

        return exporter, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "errors"
        "fmt"
        "strings"

        "github.com/kubernetes-sigs/aws-ebs-csi-driver/pkg/cloud"
        "k8s.io/klog/v2"
)

func ValidateDriverOptions(options *Options) error <span class="cov8" title="1">{
        if err := validateExtraTags(options.ExtraTags, false); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid extra tags: %w", err)
        }</span>

        <span class="cov8" title="1">if err := validateMode(options.Mode); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid mode: %w", err)
        }</span>

        <span class="cov8" title="1">if options.ModifyVolumeRequestHandlerTimeout == 0 &amp;&amp; (options.Mode == ControllerMode || options.Mode == AllMode) </span><span class="cov8" title="1">{
                return errors.New("invalid modifyVolumeRequestHandlerTimeout: timeout cannot be zero")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateExtraTags(tags map[string]string, warnOnly bool) error <span class="cov8" title="1">{
        if len(tags) &gt; cloud.MaxNumTagsPerResource </span><span class="cov8" title="1">{
                return fmt.Errorf("too many tags (actual: %d, limit: %d)", len(tags), cloud.MaxNumTagsPerResource)
        }</span>

        <span class="cov8" title="1">validate := func(k, v string) error </span><span class="cov8" title="1">{
                if len(k) &gt; cloud.MaxTagKeyLength </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag key too long (actual: %d, limit: %d)", len(k), cloud.MaxTagKeyLength)
                }</span> else<span class="cov8" title="1"> if len(k) &lt; cloud.MinTagKeyLength </span><span class="cov8" title="1">{
                        return errors.New("tag key cannot be empty (min: 1)")
                }</span>
                <span class="cov8" title="1">if len(v) &gt; cloud.MaxTagValueLength </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag value too long (actual: %d, limit: %d)", len(v), cloud.MaxTagValueLength)
                }</span>
                <span class="cov8" title="1">if k == cloud.VolumeNameTagKey </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag key '%s' is reserved", cloud.VolumeNameTagKey)
                }</span>
                <span class="cov8" title="1">if k == cloud.AwsEbsDriverTagKey </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag key '%s' is reserved", cloud.AwsEbsDriverTagKey)
                }</span>
                <span class="cov8" title="1">if k == cloud.SnapshotNameTagKey </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag key '%s' is reserved", cloud.SnapshotNameTagKey)
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(k, cloud.KubernetesTagKeyPrefix) </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag key prefix '%s' is reserved", cloud.KubernetesTagKeyPrefix)
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(k, cloud.AWSTagKeyPrefix) </span><span class="cov8" title="1">{
                        return fmt.Errorf("tag key prefix '%s' is reserved", cloud.AWSTagKeyPrefix)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">for k, v := range tags </span><span class="cov8" title="1">{
                err := validate(k, v)
                if err != nil </span><span class="cov8" title="1">{
                        if warnOnly </span><span class="cov0" title="0">{
                                klog.InfoS("Skipping tag: the following key-value pair is not valid", "key", k, "value", v, "err", err)
                        }</span> else<span class="cov8" title="1"> {
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func validateMode(mode Mode) error <span class="cov8" title="1">{
        if mode != AllMode &amp;&amp; mode != ControllerMode &amp;&amp; mode != NodeMode </span><span class="cov8" title="1">{
                return fmt.Errorf("mode is not supported (actual: %s, supported: %v)", mode, []Mode{AllMode, ControllerMode, NodeMode})
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package driver

import (
        "encoding/json"
        "fmt"
        "runtime"
)

// These are set during build time via -ldflags.
var (
        driverVersion string
        gitCommit     string
        buildDate     string
)

type VersionInfo struct {
        DriverVersion string `json:"driverVersion"`
        GitCommit     string `json:"gitCommit"`
        BuildDate     string `json:"buildDate"`
        GoVersion     string `json:"goVersion"`
        Compiler      string `json:"compiler"`
        Platform      string `json:"platform"`
}

func GetVersion() VersionInfo <span class="cov8" title="1">{
        return VersionInfo{
                DriverVersion: driverVersion,
                GitCommit:     gitCommit,
                BuildDate:     buildDate,
                GoVersion:     runtime.Version(),
                Compiler:      runtime.Compiler,
                Platform:      fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
        }
}</span>

func GetVersionJSON() (string, error) <span class="cov8" title="1">{
        info := GetVersion()
        marshalled, err := json.MarshalIndent(&amp;info, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(marshalled), nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2024 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package expiringcache

import (
        "sync"
        "time"
)

// ExpiringCache is a thread-safe "time expiring" cache that
// automatically removes objects that are not accessed for a
// configurable delay
//
// It is used in various places where we need to cache data for an
// unknown amount of time, to prevent memory leaks
//
// From the consumer's perspective, it behaves similarly to a map
// KeyType is the type of the object that is used as a key
// ValueType is the type of the object that is stored.
type ExpiringCache[KeyType comparable, ValueType any] interface {
        // Get operates identically to retrieving from a map, returning
        // the value and/or boolean indicating if the value existed in the map
        //
        // Multiple callers can receive the same value simultaneously from Get,
        // it is the caller's responsibility to ensure they are not modified
        Get(key KeyType) (value *ValueType, ok bool)
        // Set operates identically to setting a value in a map, adding an entry
        // or overriding the existing value for a given key
        Set(key KeyType, value *ValueType)
}

type timedValue[ValueType any] struct {
        value *ValueType
        timer *time.Timer
}

type expiringCache[KeyType comparable, ValueType any] struct {
        expirationDelay time.Duration
        values          map[KeyType]timedValue[ValueType]
        mutex           sync.Mutex
}

// New returns a new ExpiringCache
// for a given KeyType, ValueType, and expiration delay.
func New[KeyType comparable, ValueType any](expirationDelay time.Duration) ExpiringCache[KeyType, ValueType] <span class="cov8" title="1">{
        return &amp;expiringCache[KeyType, ValueType]{
                expirationDelay: expirationDelay,
                values:          make(map[KeyType]timedValue[ValueType]),
        }
}</span>

func (c *expiringCache[KeyType, ValueType]) Get(key KeyType) (*ValueType, bool) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if v, ok := c.values[key]; ok </span><span class="cov8" title="1">{
                v.timer.Reset(c.expirationDelay)
                return v.value, true
        }</span> else<span class="cov8" title="1"> {
                return nil, false
        }</span>
}

func (c *expiringCache[KeyType, ValueType]) Set(key KeyType, value *ValueType) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if v, ok := c.values[key]; ok </span><span class="cov8" title="1">{
                v.timer.Reset(c.expirationDelay)
                v.value = value
                c.values[key] = v
        }</span> else<span class="cov8" title="1"> {
                c.values[key] = timedValue[ValueType]{
                        timer: time.AfterFunc(c.expirationDelay, func() </span><span class="cov8" title="1">{
                                c.mutex.Lock()
                                defer c.mutex.Unlock()

                                delete(c.values, key)
                        }</span>),
                        value: value,
                }
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2025 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metrics

import (
        "sync"
        "time"

        "github.com/aws/aws-sdk-go-v2/service/ec2/types"
        "github.com/prometheus/client_golang/prometheus"
)

const (
        metricAsyncDetachSeconds = namespace + "ec2_detach_pending_seconds_total"
        asyncCollectorScrapes    = namespace + "ec2_collector_scrapes_total"
        asyncCollectorDuration   = namespace + "ec2_collector_duration_seconds"
)

type attachment struct {
        volumeID   string
        instanceID string
}

type detachingVolume struct {
        detachStart          time.Time
        lastDetachStateCheck time.Time
        attachmentState      types.VolumeAttachmentState
}

// AsyncEC2Collector contains metrics related to async EC2 operations and utilities for tracking what metrics should be emitted.
type AsyncEC2Collector struct {
        // Metrics
        detachingDuration  *prometheus.Desc
        collectionDuration prometheus.Histogram
        scrapesTotal       prometheus.Counter

        // Utilities
        // detachingVolumes holds any attachment that the controller service expects to be detached but is not.
        // We manage concurrency and memory safety within the struct through mutex and ticker instead of relying
        // on an ExpiringCache because we require that getting a cached value doesn't reset expiration timer.
        detachingVolumes map[attachment]detachingVolume
        mutex            sync.Mutex
        ticker           *time.Ticker
        // lastCacheUpdate helps us not vend out-of-date metrics upon leader election change.
        lastCacheUpdate time.Time
        // minDurationThreshold for volume to not reach detached state for metric emission. Prevents cardinality bombs.
        minDurationThreshold time.Duration
}

// Describe sends the descriptor of each metric in the AsyncEC2Collector to Prometheus.
func (c *AsyncEC2Collector) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov8" title="1">{
        ch &lt;- c.detachingDuration
        ch &lt;- c.collectionDuration.Desc()
        ch &lt;- c.scrapesTotal.Desc()
}</span>

// Collect is invoked by Prometheus at collection time for emitting AsyncEC2Collector metrics.
func (c *AsyncEC2Collector) Collect(ch chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        // Meta metrics for metric collection
        c.scrapesTotal.Inc()
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{
                duration := time.Since(start).Seconds()
                c.collectionDuration.Observe(duration)

                ch &lt;- c.collectionDuration
                ch &lt;- c.scrapesTotal
        }</span>()

        <span class="cov8" title="1">c.mutex.Lock()
        defer c.mutex.Unlock()

        for k, v := range c.detachingVolumes </span><span class="cov8" title="1">{
                if time.Since(v.detachStart) &gt; c.minDurationThreshold </span><span class="cov8" title="1">{
                        if v.attachmentState != types.VolumeAttachmentStateDetached </span><span class="cov8" title="1">{
                                ch &lt;- prometheus.MustNewConstMetric(c.detachingDuration, prometheus.CounterValue, time.Since(v.detachStart).Seconds(), k.volumeID, k.instanceID, string(v.attachmentState))
                        }</span>
                }
        }
}

// TrackDetachment tracks the state of a volume that we expect to detach in our AsyncEC2Collector cache.
func (c *AsyncEC2Collector) TrackDetachment(volumeID, instanceID string, attachmentState types.VolumeAttachmentState) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.mutex.Lock()
        defer c.mutex.Unlock()

        a := attachment{volumeID: volumeID, instanceID: instanceID}

        // Clear if detached
        if attachmentState == types.VolumeAttachmentStateDetached || attachmentState == "" </span><span class="cov0" title="0">{
                delete(c.detachingVolumes, a)
        }</span>

        // Check if first time tracking this attachment
        <span class="cov8" title="1">var detachStart time.Time
        now := time.Now()
        dv, ok := c.detachingVolumes[a]
        if ok </span><span class="cov8" title="1">{
                detachStart = dv.detachStart
        }</span> else<span class="cov8" title="1"> {
                detachStart = now
        }</span>

        <span class="cov8" title="1">c.detachingVolumes[a] = detachingVolume{
                detachStart:          detachStart,
                lastDetachStateCheck: now,
                attachmentState:      attachmentState,
        }</span>
}

// ClearDetachMetric ensures AsyncEC2Collector is not emitting metrics for a given attachment.
func (c *AsyncEC2Collector) ClearDetachMetric(volumeID, instanceID string) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.mutex.Lock()
        defer c.mutex.Unlock()

        a := attachment{volumeID: volumeID, instanceID: instanceID}
        delete(c.detachingVolumes, a)</span>
}

// cleanupCache clears the detachingVolumes cache if no update has been made since minTimeSinceLastUpdate ago.
func (c *AsyncEC2Collector) cleanupCache(minTimeSinceLastUpdate time.Duration) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">c.mutex.Lock()
        defer c.mutex.Unlock()

        for k, v := range c.detachingVolumes </span><span class="cov8" title="1">{
                if time.Since(v.lastDetachStateCheck) &gt; minTimeSinceLastUpdate </span><span class="cov8" title="1">{
                        delete(c.detachingVolumes, k)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metrics

import (
        "net/http"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "k8s.io/klog/v2"
)

const (
        namespace = "aws_ebs_csi_"
)

var (
        r          *metricRecorder // singleton instance of metricRecorder
        once       sync.Once
        operations = []string{
                "CreateVolume",
                "DeleteVolume",
                "AttachVolume",
                "DetachVolume",
                "ModifyVolume",
                "DescribeVolumes",
                "DescribeVolumesModifications",
                "CreateSnapshot",
                "DeleteSnapshot",
                "DescribeSnapshots",
                "DescribeInstances",
                "DescribeAvailabilityZones",
                "DescribeTags",
                "CreateTags",
                "DeleteTags",
                "EnableFastSnapshotRestores",
        }
)

type metricRecorder struct {
        registry        *prometheus.Registry
        metrics         map[string]interface{}
        asyncEC2Metrics *AsyncEC2Collector
}

// Recorder returns the singleton instance of metricRecorder.
// nil is returned if the recorder is not initialized.
func Recorder() *metricRecorder <span class="cov8" title="1">{
        return r
}</span>

// InitializeRecorder initializes a new metricRecorder instance if it hasn't been initialized.
func InitializeRecorder(deprecatedMetrics bool) *metricRecorder <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                r = &amp;metricRecorder{
                        registry: prometheus.NewRegistry(),
                        metrics:  make(map[string]interface{}),
                }
        }</span>)
        <span class="cov8" title="1">return r</span>
}

// InitializeNVME registers the NVMe collector for gathering metrics from NVMe devices.
func (m *metricRecorder) InitializeNVME(csiMountPointPath, instanceID string) <span class="cov0" title="0">{
        registerNVMECollector(r, csiMountPointPath, instanceID)
}</span>

// InitializeAsyncEC2Metrics initializes and registers AsyncEC2Collector for gathering metrics on async EC2 operations.
func (m *metricRecorder) InitializeAsyncEC2Metrics(minimumEmissionThreshold time.Duration) <span class="cov8" title="1">{
        variableLabels := []string{"volume_id", "instance_id", "attachment_state"}
        cacheCleanupInterval := 15 * time.Minute

        r.asyncEC2Metrics = &amp;AsyncEC2Collector{
                detachingDuration: prometheus.NewDesc(metricAsyncDetachSeconds, "Number of seconds csi driver has been waiting for volume to be detached from instance. Label attachment_state shows last seen state for attachment associated with volume_id and instance_id. Metric only valid if emitted from leader.", variableLabels, nil),
                collectionDuration: prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name:    asyncCollectorDuration,
                        Help:    "Histogram of async EC2 collector scrape duration in seconds.",
                        Buckets: []float64{0.01, 0.1, 0.5, 1, 2.5, 5, 10},
                }),
                scrapesTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name: asyncCollectorScrapes,
                        Help: "Total number of async EC2 collector scrapes.",
                }),
                detachingVolumes:     make(map[attachment]detachingVolume),
                minDurationThreshold: minimumEmissionThreshold,
                lastCacheUpdate:      time.Now(),
                ticker:               time.NewTicker(cacheCleanupInterval),
        }
        r.registry.MustRegister(r.asyncEC2Metrics)

        // Prevent leaked memory in case of leader change by clearing cache if no detaches have been tracked in a while
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        &lt;-r.asyncEC2Metrics.ticker.C
                        r.asyncEC2Metrics.cleanupCache(cacheCleanupInterval)
                }</span>
        }()
}

// AsyncEC2Metrics returns AsyncEC2Collector if metrics are enabled.
func AsyncEC2Metrics() *AsyncEC2Collector <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return r.asyncEC2Metrics</span>
}

// IncreaseCount increases the counter metric by 1.
func (m *metricRecorder) IncreaseCount(name string, helpText string, labels map[string]string) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return // recorder is not initialized
        }</span>

        <span class="cov8" title="1">metric, ok := m.metrics[name]

        if !ok </span><span class="cov8" title="1">{
                klog.V(4).InfoS("Metric not found, registering", "name", name, "labels", labels)
                m.registerCounterVec(name, helpText, getLabelNames(labels))
                m.IncreaseCount(name, helpText, labels)
                return
        }</span>

        <span class="cov8" title="1">metricAsCounterVec, ok := metric.(*prometheus.CounterVec)
        if ok </span><span class="cov8" title="1">{
                metricAsCounterVec.With(labels).Inc()
        }</span> else<span class="cov0" title="0"> {
                klog.V(4).InfoS("Could not assert metric as metrics.CounterVec. Metric increase may have been skipped")
        }</span>
}

// ObserveHistogram records the given value in the histogram metric.
func (m *metricRecorder) ObserveHistogram(name string, helpText string, value float64, labels map[string]string, buckets []float64) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return // recorder is not initialized
        }</span>
        <span class="cov8" title="1">metric, ok := m.metrics[name]

        if !ok </span><span class="cov8" title="1">{
                klog.V(4).InfoS("Metric not found, registering", "name", name, "labels", labels, "buckets", buckets)
                m.registerHistogramVec(name, helpText, getLabelNames(labels), buckets)
                m.ObserveHistogram(name, helpText, value, labels, buckets)
                return
        }</span>

        <span class="cov8" title="1">metricAsHistogramVec, ok := metric.(*prometheus.HistogramVec)
        if ok </span><span class="cov8" title="1">{
                metricAsHistogramVec.With(labels).Observe(value)
        }</span> else<span class="cov0" title="0"> {
                klog.V(4).InfoS("Could not assert metric as metrics.HistogramVec. Metric observation may have been skipped")
        }</span>
}

// InitializeMetricsHandler starts a new HTTP server to expose the metrics.
func (m *metricRecorder) InitializeMetricsHandler(address, path, certFile, keyFile string) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                klog.InfoS("InitializeMetricsHandler: metric recorder is not initialized")
                return
        }</span>

        <span class="cov0" title="0">mux := http.NewServeMux()
        mux.Handle(path, promhttp.HandlerFor(m.registry, promhttp.HandlerOpts{ErrorHandling: promhttp.ContinueOnError}))

        server := &amp;http.Server{
                Addr:        address,
                Handler:     mux,
                ReadTimeout: 3 * time.Second,
        }

        go func() </span><span class="cov0" title="0">{
                var err error
                klog.InfoS("Metric server listening", "address", address, "path", path)

                if certFile != "" </span><span class="cov0" title="0">{
                        err = server.ListenAndServeTLS(certFile, keyFile)
                }</span> else<span class="cov0" title="0"> {
                        err = server.ListenAndServe()
                }</span>

                <span class="cov0" title="0">if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        klog.ErrorS(err, "Failed to start metric server", "address", address, "path", path)
                        klog.FlushAndExit(klog.ExitFlushTimeout, 1)
                }</span>
        }()
}

func (m *metricRecorder) registerHistogramVec(name, help string, labels []string, buckets []float64) *prometheus.HistogramVec <span class="cov8" title="1">{
        if metric, exists := m.metrics[name]; exists </span><span class="cov0" title="0">{
                if histogramVec, ok := metric.(*prometheus.HistogramVec); ok </span><span class="cov0" title="0">{
                        return histogramVec
                }</span>
                <span class="cov0" title="0">klog.ErrorS(nil, "Metric exists but is not a HistogramVec", "name", name)
                return nil</span>
        }
        <span class="cov8" title="1">histogram := prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    name,
                        Help:    help,
                        Buckets: buckets,
                },
                labels,
        )
        m.metrics[name] = histogram
        m.registry.MustRegister(histogram)
        return histogram</span>
}

func (m *metricRecorder) registerCounterVec(name, help string, labels []string) <span class="cov8" title="1">{
        if _, exists := m.metrics[name]; exists </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">counter := prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: name,
                        Help: help,
                },
                labels,
        )
        m.metrics[name] = counter
        m.registry.MustRegister(counter)</span>
}

func getLabelNames(labels map[string]string) []string <span class="cov8" title="1">{
        names := make([]string, 0, len(labels))
        for n := range labels </span><span class="cov8" title="1">{
                names = append(names, n)
        }</span>
        <span class="cov8" title="1">return names</span>
}

func (m *metricRecorder) initializeMetricWithOperations(name, help string, labelNames []string) <span class="cov0" title="0">{
        if _, exists := m.metrics[name]; !exists </span><span class="cov0" title="0">{
                metric := m.registerHistogramVec(name, help, labelNames, nil)
                for _, op := range operations </span><span class="cov0" title="0">{
                        metric.WithLabelValues(op)
                }</span>
        }
}

// InitializeAPIMetrics registers and initializes any `aws_ebs_csi` metric that has known label values on driver startup. Setting deprecatedMetrics to true also initializes deprecated metrics.
func (m *metricRecorder) InitializeAPIMetrics(deprecatedMetrics bool) <span class="cov0" title="0">{
        labelNames := []string{"request"}
        m.initializeMetricWithOperations(
                APIRequestDuration,
                APIRequestDurationHelpText,
                labelNames,
        )
        if deprecatedMetrics </span><span class="cov0" title="0">{
                m.initializeMetricWithOperations(
                        DeprecatedAPIRequestDuration,
                        DeprecatedAPIRequestDurationHelpText,
                        labelNames,
                )
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">//go:build linux

// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metrics

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "errors"
        "fmt"
        "math"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"
        "unsafe"

        "github.com/prometheus/client_golang/prometheus"
        "golang.org/x/sys/unix"
        "k8s.io/klog/v2"
)

const (
        // Counter metrics.
        metricReadOps         = namespace + "read_ops_total"
        metricWriteOps        = namespace + "write_ops_total"
        metricReadBytes       = namespace + "read_bytes_total"
        metricWriteBytes      = namespace + "write_bytes_total"
        metricReadOpsSeconds  = namespace + "read_seconds_total"
        metricWriteOpsSeconds = namespace + "write_seconds_total"
        metricExceededIOPS    = namespace + "exceeded_iops_seconds_total"
        metricExceededTP      = namespace + "exceeded_tp_seconds_total"
        metricEC2ExceededIOPS = namespace + "ec2_exceeded_iops_seconds_total"
        metricEC2ExceededTP   = namespace + "ec2_exceeded_tp_seconds_total"
        nvmeCollectorScrapes  = namespace + "nvme_collector_scrapes_total"
        nvmeCollectorErrors   = namespace + "nvme_collector_errors_total"

        // Gauge metrics.
        metricVolumeQueueLength = namespace + "volume_queue_length"

        // Histogram metrics.
        metricReadLatency     = namespace + "read_io_latency_seconds"
        metricWriteLatency    = namespace + "write_io_latency_seconds"
        nvmeCollectorDuration = namespace + "nvme_collector_duration_seconds"

        // Conversion factor.
        microsecondsInSeconds = 1e6
)

// EBSMetrics represents the parsed metrics from the NVMe log page.
type EBSMetrics struct {
        EBSMagic              uint64
        ReadOps               uint64
        WriteOps              uint64
        ReadBytes             uint64
        WriteBytes            uint64
        TotalReadTime         uint64
        TotalWriteTime        uint64
        EBSIOPSExceeded       uint64
        EBSThroughputExceeded uint64
        EC2IOPSExceeded       uint64
        EC2ThroughputExceeded uint64
        QueueLength           uint64
        ReservedArea          [416]byte
        ReadLatency           Histogram
        WriteLatency          Histogram
}

type Histogram struct {
        BinCount uint64
        Bins     [64]HistogramBin
}

type HistogramBin struct {
        Lower uint64
        Upper uint64
        Count uint64
}

// As defined in &lt;linux/nvme_ioctl.h&gt;.
type nvmePassthruCommand struct {
        opcode      uint8
        flags       uint8
        rsvd1       uint16
        nsid        uint32
        cdw2        uint32
        cdw3        uint32
        metadata    uint64
        addr        uint64
        metadataLen uint32
        dataLen     uint32
        cdw10       uint32
        cdw11       uint32
        cdw12       uint32
        cdw13       uint32
        cdw14       uint32
        cdw15       uint32
        timeoutMs   uint32
        result      uint32
}

type NVMECollector struct {
        metrics            map[string]*prometheus.Desc
        csiMountPointPath  string
        instanceID         string
        collectionDuration prometheus.Histogram
        scrapesTotal       prometheus.Counter
        scrapeErrorsTotal  prometheus.Counter
}

var (
        ErrInvalidEBSMagic = errors.New("invalid EBS magic number")
        ErrParseLogPage    = errors.New("failed to parse log page")
)

// NewNVMECollector creates a new instance of NVMECollector.
func NewNVMECollector(path, instanceID string) *NVMECollector <span class="cov8" title="1">{
        variableLabels := []string{"volume_id"}
        constLabels := prometheus.Labels{"instance_id": instanceID}

        return &amp;NVMECollector{
                metrics: map[string]*prometheus.Desc{
                        metricReadOps:           prometheus.NewDesc(metricReadOps, "The total number of completed read operations.", variableLabels, constLabels),
                        metricWriteOps:          prometheus.NewDesc(metricWriteOps, "The total number of completed write operations.", variableLabels, constLabels),
                        metricReadBytes:         prometheus.NewDesc(metricReadBytes, "The total number of read bytes transferred.", variableLabels, constLabels),
                        metricWriteBytes:        prometheus.NewDesc(metricWriteBytes, "The total number of write bytes transferred.", variableLabels, constLabels),
                        metricReadOpsSeconds:    prometheus.NewDesc(metricReadOpsSeconds, "The total time spent, in seconds, by all completed read operations.", variableLabels, constLabels),
                        metricWriteOpsSeconds:   prometheus.NewDesc(metricWriteOpsSeconds, "The total time spent, in seconds, by all completed write operations.", variableLabels, constLabels),
                        metricExceededIOPS:      prometheus.NewDesc(metricExceededIOPS, "The total time, in seconds, that IOPS demand exceeded the volume's provisioned IOPS performance.", variableLabels, constLabels),
                        metricExceededTP:        prometheus.NewDesc(metricExceededTP, "The total time, in seconds, that throughput demand exceeded the volume's provisioned throughput performance.", variableLabels, constLabels),
                        metricEC2ExceededIOPS:   prometheus.NewDesc(metricEC2ExceededIOPS, "The total time, in seconds, that the EBS volume exceeded the attached Amazon EC2 instance's maximum IOPS performance.", variableLabels, constLabels),
                        metricEC2ExceededTP:     prometheus.NewDesc(metricEC2ExceededTP, "The total time, in seconds, that the EBS volume exceeded the attached Amazon EC2 instance's maximum throughput performance.", variableLabels, constLabels),
                        metricVolumeQueueLength: prometheus.NewDesc(metricVolumeQueueLength, "The number of read and write operations waiting to be completed.", variableLabels, constLabels),
                        metricReadLatency:       prometheus.NewDesc(metricReadLatency, "The number of read operations completed within each latency bin, in seconds.", variableLabels, constLabels),
                        metricWriteLatency:      prometheus.NewDesc(metricWriteLatency, "The number of write operations completed within each latency bin, in seconds.", variableLabels, constLabels),
                },
                // Clean CSI mount point path to normalize path
                // Add trailing slash back that Clean prunes
                csiMountPointPath: filepath.Clean(path) + "/",
                instanceID:        instanceID,
                collectionDuration: prometheus.NewHistogram(prometheus.HistogramOpts{
                        Name:        nvmeCollectorDuration,
                        Help:        "Histogram of NVMe collector scrape duration in seconds.",
                        Buckets:     []float64{0.001, 0.0025, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10},
                        ConstLabels: constLabels,
                }),
                scrapesTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name:        nvmeCollectorScrapes,
                        Help:        "Total number of NVMe collector scrapes.",
                        ConstLabels: constLabels,
                }),
                scrapeErrorsTotal: prometheus.NewCounter(prometheus.CounterOpts{
                        Name:        nvmeCollectorErrors,
                        Help:        "Total number of NVMe collector scrape errors.",
                        ConstLabels: constLabels,
                }),
        }
}</span>

func registerNVMECollector(r *metricRecorder, csiMountPointPath, instanceID string) <span class="cov0" title="0">{
        collector := NewNVMECollector(csiMountPointPath, instanceID)
        r.registry.MustRegister(collector)
}</span>

// Describe sends the descriptor of each metric in the NVMECollector to Prometheus.
func (c *NVMECollector) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov0" title="0">{
        for _, desc := range c.metrics </span><span class="cov0" title="0">{
                ch &lt;- desc
        }</span>
        <span class="cov0" title="0">ch &lt;- c.collectionDuration.Desc()
        ch &lt;- c.scrapesTotal.Desc()
        ch &lt;- c.scrapeErrorsTotal.Desc()</span>
}

// Collect is invoked by Prometheus at collection time.
func (c *NVMECollector) Collect(ch chan&lt;- prometheus.Metric) <span class="cov0" title="0">{
        c.scrapesTotal.Inc()
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                duration := time.Since(start).Seconds()
                c.collectionDuration.Observe(duration)

                ch &lt;- c.collectionDuration
                ch &lt;- c.scrapesTotal
                ch &lt;- c.scrapeErrorsTotal
        }</span>()

        <span class="cov0" title="0">devicePaths, err := getCSIManagedDevices(c.csiMountPointPath)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error getting NVMe devices: %v", err)
                c.scrapeErrorsTotal.Inc()
                return
        }</span> else<span class="cov0" title="0"> if len(devicePaths) == 0 </span><span class="cov0" title="0">{
                klog.V(8).InfoS("No NVMe devices found")
                return
        }</span>

        <span class="cov0" title="0">devices, err := fetchDevicePathToVolumeIDMapping(devicePaths)
        if err != nil </span><span class="cov0" title="0">{
                klog.Errorf("Error getting volume IDs: %v", err)
                c.scrapeErrorsTotal.Inc()
                return
        }</span>

        <span class="cov0" title="0">for devicePath, volumeID := range devices </span><span class="cov0" title="0">{
                data, err := getNVMEMetrics(devicePath)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("Error collecting metrics for device %s: %v", devicePath, err)
                        c.scrapeErrorsTotal.Inc()
                        continue</span>
                }

                <span class="cov0" title="0">metrics, err := parseLogPage(data)
                if err != nil </span><span class="cov0" title="0">{
                        klog.Errorf("Error parsing metrics for device %s: %v", devicePath, err)
                        c.scrapeErrorsTotal.Inc()
                        continue</span>
                }

                // Send all collected metrics to Prometheus
                <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricReadOps], prometheus.CounterValue, float64(metrics.ReadOps), volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricWriteOps], prometheus.CounterValue, float64(metrics.WriteOps), volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricReadBytes], prometheus.CounterValue, float64(metrics.ReadBytes), volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricWriteBytes], prometheus.CounterValue, float64(metrics.WriteBytes), volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricReadOpsSeconds], prometheus.CounterValue, float64(metrics.TotalReadTime)/microsecondsInSeconds, volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricWriteOpsSeconds], prometheus.CounterValue, float64(metrics.TotalWriteTime)/microsecondsInSeconds, volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricExceededIOPS], prometheus.CounterValue, float64(metrics.EBSIOPSExceeded)/microsecondsInSeconds, volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricExceededTP], prometheus.CounterValue, float64(metrics.EBSThroughputExceeded)/microsecondsInSeconds, volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricEC2ExceededIOPS], prometheus.CounterValue, float64(metrics.EC2IOPSExceeded)/microsecondsInSeconds, volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricEC2ExceededTP], prometheus.CounterValue, float64(metrics.EC2ThroughputExceeded)/microsecondsInSeconds, volumeID)
                ch &lt;- prometheus.MustNewConstMetric(c.metrics[metricVolumeQueueLength], prometheus.GaugeValue, float64(metrics.QueueLength), volumeID)

                // Read Latency Histogram
                readCount, readBuckets := convertHistogram(metrics.ReadLatency)
                ch &lt;- prometheus.MustNewConstHistogram(
                        c.metrics[metricReadLatency],
                        readCount,
                        0,
                        readBuckets,
                        volumeID,
                )

                // Write Latency Histogram
                writeCount, writeBuckets := convertHistogram(metrics.WriteLatency)
                ch &lt;- prometheus.MustNewConstHistogram(
                        c.metrics[metricWriteLatency],
                        writeCount,
                        0,
                        writeBuckets,
                        volumeID,
                )</span>
        }
}

// convertHistogram converts the Histogram structure to a format suitable for Prometheus histogram metrics.
func convertHistogram(hist Histogram) (uint64, map[float64]uint64) <span class="cov8" title="1">{
        var count uint64
        buckets := make(map[float64]uint64)

        for i := uint64(0); i &lt; hist.BinCount &amp;&amp; i &lt; 64; i++ </span><span class="cov8" title="1">{
                count += hist.Bins[i].Count
                buckets[float64(hist.Bins[i].Upper)/microsecondsInSeconds] = count
        }</span>

        <span class="cov8" title="1">return count, buckets</span>
}

// getNVMEMetrics retrieves NVMe metrics by reading the log page from the NVMe device at the given path.
func getNVMEMetrics(devicePath string) ([]byte, error) <span class="cov0" title="0">{
        f, err := os.OpenFile(devicePath, os.O_RDWR, 0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getNVMEMetrics: error opening device: %w", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        data, err := nvmeReadLogPage(f.Fd(), 0xD0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getNVMEMetrics: error reading log page %w", err)
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}

// nvmeReadLogPage reads an NVMe log page via an ioctl system call.
func nvmeReadLogPage(fd uintptr, logID uint8) ([]byte, error) <span class="cov0" title="0">{
        data := make([]byte, 4096) // 4096 bytes is the length of the log page.
        bufferLen := len(data)

        if bufferLen &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                return nil, errors.New("nvmeReadLogPage: bufferLen exceeds MaxUint32")
        }</span>

        <span class="cov0" title="0">cmd := nvmePassthruCommand{
                opcode:  0x02,
                addr:    uint64(uintptr(unsafe.Pointer(&amp;data[0]))),
                nsid:    1,
                dataLen: uint32(bufferLen),
                cdw10:   uint32(logID) | (1024 &lt;&lt; 16),
        }

        status, _, errno := unix.Syscall(unix.SYS_IOCTL, fd, 0xC0484E41, uintptr(unsafe.Pointer(&amp;cmd)))
        if errno != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nvmeReadLogPage: ioctl error %w", errno)
        }</span>
        <span class="cov0" title="0">if status != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("nvmeReadLogPage: ioctl command failed with status %d", status)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// parseLogPage parses the binary data from an EBS log page into EBSMetrics.
func parseLogPage(data []byte) (EBSMetrics, error) <span class="cov8" title="1">{
        var metrics EBSMetrics
        reader := bytes.NewReader(data)

        if err := binary.Read(reader, binary.LittleEndian, &amp;metrics); err != nil </span><span class="cov8" title="1">{
                return EBSMetrics{}, fmt.Errorf("%w: %w", ErrParseLogPage, err)
        }</span>

        <span class="cov8" title="1">if metrics.EBSMagic != 0x3C23B510 </span><span class="cov8" title="1">{
                return EBSMetrics{}, fmt.Errorf("%w: %x", ErrInvalidEBSMagic, metrics.EBSMagic)
        }</span>

        <span class="cov8" title="1">return metrics, nil</span>
}

// getCSIManagedDevices returns a slice of unique device paths for NVMe devices mounted under the given path.
func getCSIManagedDevices(path string) ([]string, error) <span class="cov0" title="0">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                klog.V(4).InfoS("getCSIManagedDevices: empty path provided, no devices will be matched")
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">deviceMap := make(map[string]bool)

        // Read /proc/self/mountinfo to identify NVMe devices
        mountinfo, err := os.ReadFile("/proc/self/mountinfo")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("getCSIManagedDevices: error reading mountinfo: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(mountinfo), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                fields := strings.Fields(line)

                // https://man7.org/linux/man-pages/man5/proc.5.html
                if len(fields) &lt; 10 </span><span class="cov0" title="0">{
                        continue</span> // Skip lines with insufficient fields
                }

                <span class="cov0" title="0">mountPoint := fields[4]
                if !strings.HasPrefix(mountPoint, path) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check mount source (field 3) for directly mounted NVMe devices
                <span class="cov0" title="0">m := fields[3]
                if strings.HasPrefix(m, "/nvme") </span><span class="cov0" title="0">{
                        device := "/dev" + m
                        deviceMap[device] = true
                }</span>

                // Check root (field 9) for block devices
                <span class="cov0" title="0">r := fields[9]
                if strings.HasPrefix(r, "/dev/nvme") </span><span class="cov0" title="0">{
                        deviceMap[r] = true
                }</span>
        }

        <span class="cov0" title="0">devices := make([]string, 0, len(deviceMap))
        for device := range deviceMap </span><span class="cov0" title="0">{
                devices = append(devices, device)
        }</span>

        <span class="cov0" title="0">return devices, nil</span>
}

type BlockDevice struct {
        Name   string `json:"name"`
        Serial string `json:"serial"`
}

type LsblkOutput struct {
        BlockDevices []BlockDevice `json:"blockdevices"`
}

// mapDevicePathsToVolumeIDs takes a list of device paths and lsblk output, and returns a map of device paths to volume IDs.
func mapDevicePathsToVolumeIDs(devicePaths []string, lsblkOutput []byte) (map[string]string, error) <span class="cov8" title="1">{
        m := make(map[string]string)

        var lsblkData LsblkOutput
        if err := json.Unmarshal(lsblkOutput, &amp;lsblkData); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("mapDevicePathsToVolumeIDs: error unmarshaling JSON: %w", err)
        }</span>

        <span class="cov8" title="1">for _, device := range lsblkData.BlockDevices </span><span class="cov8" title="1">{
                devicePath := "/dev/" + device.Name

                for _, path := range devicePaths </span><span class="cov8" title="1">{
                        if strings.HasPrefix(path, devicePath) </span><span class="cov8" title="1">{
                                volumeID := device.Serial

                                if strings.HasPrefix(volumeID, "vol") &amp;&amp; !strings.HasPrefix(volumeID, "vol-") </span><span class="cov8" title="1">{
                                        volumeID = "vol-" + volumeID[3:]
                                }</span>

                                <span class="cov8" title="1">m[path] = volumeID
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return m, nil</span>
}

func executeLsblk() ([]byte, error) <span class="cov0" title="0">{
        cmd := exec.Command("lsblk", "-nd", "--json", "-o", "NAME,SERIAL")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executeLsblk: error running lsblk: %w", err)
        }</span>
        <span class="cov0" title="0">return output, nil</span>
}

func fetchDevicePathToVolumeIDMapping(devicePaths []string) (map[string]string, error) <span class="cov0" title="0">{
        output, err := executeLsblk()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetchDevicePathToVolumeIDMapping: %w", err)
        }</span>

        <span class="cov0" title="0">return mapDevicePathsToVolumeIDs(devicePaths, output)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/mounter/mount.go

// Package mounter is a generated GoMock package.
package mounter

import (
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        mount_utils "k8s.io/mount-utils"
)

// MockMounter is a mock of Mounter interface.
type MockMounter struct {
        ctrl     *gomock.Controller
        recorder *MockMounterMockRecorder
}

// MockMounterMockRecorder is the mock recorder for MockMounter.
type MockMounterMockRecorder struct {
        mock *MockMounter
}

// NewMockMounter creates a new mock instance.
func NewMockMounter(ctrl *gomock.Controller) *MockMounter <span class="cov0" title="0">{
        mock := &amp;MockMounter{ctrl: ctrl}
        mock.recorder = &amp;MockMounterMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMounter) EXPECT() *MockMounterMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// CanSafelySkipMountPointCheck mocks base method.
func (m *MockMounter) CanSafelySkipMountPointCheck() bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CanSafelySkipMountPointCheck")
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// CanSafelySkipMountPointCheck indicates an expected call of CanSafelySkipMountPointCheck.
func (mr *MockMounterMockRecorder) CanSafelySkipMountPointCheck() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CanSafelySkipMountPointCheck", reflect.TypeOf((*MockMounter)(nil).CanSafelySkipMountPointCheck))
}</span>

// FindDevicePath mocks base method.
func (m *MockMounter) FindDevicePath(devicePath, volumeID, partition, region string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindDevicePath", devicePath, volumeID, partition, region)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindDevicePath indicates an expected call of FindDevicePath.
func (mr *MockMounterMockRecorder) FindDevicePath(devicePath, volumeID, partition, region interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindDevicePath", reflect.TypeOf((*MockMounter)(nil).FindDevicePath), devicePath, volumeID, partition, region)
}</span>

// FormatAndMountSensitiveWithFormatOptions mocks base method.
func (m *MockMounter) FormatAndMountSensitiveWithFormatOptions(source, target, fstype string, options, sensitiveOptions, formatOptions []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FormatAndMountSensitiveWithFormatOptions", source, target, fstype, options, sensitiveOptions, formatOptions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// FormatAndMountSensitiveWithFormatOptions indicates an expected call of FormatAndMountSensitiveWithFormatOptions.
func (mr *MockMounterMockRecorder) FormatAndMountSensitiveWithFormatOptions(source, target, fstype, options, sensitiveOptions, formatOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FormatAndMountSensitiveWithFormatOptions", reflect.TypeOf((*MockMounter)(nil).FormatAndMountSensitiveWithFormatOptions), source, target, fstype, options, sensitiveOptions, formatOptions)
}</span>

// GetBlockSizeBytes mocks base method.
func (m *MockMounter) GetBlockSizeBytes(devicePath string) (int64, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetBlockSizeBytes", devicePath)
        ret0, _ := ret[0].(int64)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetBlockSizeBytes indicates an expected call of GetBlockSizeBytes.
func (mr *MockMounterMockRecorder) GetBlockSizeBytes(devicePath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBlockSizeBytes", reflect.TypeOf((*MockMounter)(nil).GetBlockSizeBytes), devicePath)
}</span>

// GetDeviceNameFromMount mocks base method.
func (m *MockMounter) GetDeviceNameFromMount(mountPath string) (string, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetDeviceNameFromMount", mountPath)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// GetDeviceNameFromMount indicates an expected call of GetDeviceNameFromMount.
func (mr *MockMounterMockRecorder) GetDeviceNameFromMount(mountPath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDeviceNameFromMount", reflect.TypeOf((*MockMounter)(nil).GetDeviceNameFromMount), mountPath)
}</span>

// GetMountRefs mocks base method.
func (m *MockMounter) GetMountRefs(pathname string) ([]string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetMountRefs", pathname)
        ret0, _ := ret[0].([]string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetMountRefs indicates an expected call of GetMountRefs.
func (mr *MockMounterMockRecorder) GetMountRefs(pathname interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMountRefs", reflect.TypeOf((*MockMounter)(nil).GetMountRefs), pathname)
}</span>

// GetVolumeStats mocks base method.
func (m *MockMounter) GetVolumeStats(volumePath string) (VolumeStats, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetVolumeStats", volumePath)
        ret0, _ := ret[0].(VolumeStats)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetVolumeStats indicates an expected call of GetVolumeStats.
func (mr *MockMounterMockRecorder) GetVolumeStats(volumePath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVolumeStats", reflect.TypeOf((*MockMounter)(nil).GetVolumeStats), volumePath)
}</span>

// IsBlockDevice mocks base method.
func (m *MockMounter) IsBlockDevice(fullPath string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsBlockDevice", fullPath)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsBlockDevice indicates an expected call of IsBlockDevice.
func (mr *MockMounterMockRecorder) IsBlockDevice(fullPath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsBlockDevice", reflect.TypeOf((*MockMounter)(nil).IsBlockDevice), fullPath)
}</span>

// IsCorruptedMnt mocks base method.
func (m *MockMounter) IsCorruptedMnt(err error) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsCorruptedMnt", err)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// IsCorruptedMnt indicates an expected call of IsCorruptedMnt.
func (mr *MockMounterMockRecorder) IsCorruptedMnt(err interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsCorruptedMnt", reflect.TypeOf((*MockMounter)(nil).IsCorruptedMnt), err)
}</span>

// IsLikelyNotMountPoint mocks base method.
func (m *MockMounter) IsLikelyNotMountPoint(file string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsLikelyNotMountPoint", file)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsLikelyNotMountPoint indicates an expected call of IsLikelyNotMountPoint.
func (mr *MockMounterMockRecorder) IsLikelyNotMountPoint(file interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsLikelyNotMountPoint", reflect.TypeOf((*MockMounter)(nil).IsLikelyNotMountPoint), file)
}</span>

// IsMountPoint mocks base method.
func (m *MockMounter) IsMountPoint(file string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsMountPoint", file)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// IsMountPoint indicates an expected call of IsMountPoint.
func (mr *MockMounterMockRecorder) IsMountPoint(file interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsMountPoint", reflect.TypeOf((*MockMounter)(nil).IsMountPoint), file)
}</span>

// List mocks base method.
func (m *MockMounter) List() ([]mount_utils.MountPoint, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "List")
        ret0, _ := ret[0].([]mount_utils.MountPoint)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// List indicates an expected call of List.
func (mr *MockMounterMockRecorder) List() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockMounter)(nil).List))
}</span>

// MakeDir mocks base method.
func (m *MockMounter) MakeDir(path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MakeDir", path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MakeDir indicates an expected call of MakeDir.
func (mr *MockMounterMockRecorder) MakeDir(path interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MakeDir", reflect.TypeOf((*MockMounter)(nil).MakeDir), path)
}</span>

// MakeFile mocks base method.
func (m *MockMounter) MakeFile(path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MakeFile", path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MakeFile indicates an expected call of MakeFile.
func (mr *MockMounterMockRecorder) MakeFile(path interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MakeFile", reflect.TypeOf((*MockMounter)(nil).MakeFile), path)
}</span>

// Mount mocks base method.
func (m *MockMounter) Mount(source, target, fstype string, options []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Mount", source, target, fstype, options)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Mount indicates an expected call of Mount.
func (mr *MockMounterMockRecorder) Mount(source, target, fstype, options interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mount", reflect.TypeOf((*MockMounter)(nil).Mount), source, target, fstype, options)
}</span>

// MountSensitive mocks base method.
func (m *MockMounter) MountSensitive(source, target, fstype string, options, sensitiveOptions []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MountSensitive", source, target, fstype, options, sensitiveOptions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MountSensitive indicates an expected call of MountSensitive.
func (mr *MockMounterMockRecorder) MountSensitive(source, target, fstype, options, sensitiveOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountSensitive", reflect.TypeOf((*MockMounter)(nil).MountSensitive), source, target, fstype, options, sensitiveOptions)
}</span>

// MountSensitiveWithoutSystemd mocks base method.
func (m *MockMounter) MountSensitiveWithoutSystemd(source, target, fstype string, options, sensitiveOptions []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MountSensitiveWithoutSystemd", source, target, fstype, options, sensitiveOptions)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MountSensitiveWithoutSystemd indicates an expected call of MountSensitiveWithoutSystemd.
func (mr *MockMounterMockRecorder) MountSensitiveWithoutSystemd(source, target, fstype, options, sensitiveOptions interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountSensitiveWithoutSystemd", reflect.TypeOf((*MockMounter)(nil).MountSensitiveWithoutSystemd), source, target, fstype, options, sensitiveOptions)
}</span>

// MountSensitiveWithoutSystemdWithMountFlags mocks base method.
func (m *MockMounter) MountSensitiveWithoutSystemdWithMountFlags(source, target, fstype string, options, sensitiveOptions, mountFlags []string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "MountSensitiveWithoutSystemdWithMountFlags", source, target, fstype, options, sensitiveOptions, mountFlags)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// MountSensitiveWithoutSystemdWithMountFlags indicates an expected call of MountSensitiveWithoutSystemdWithMountFlags.
func (mr *MockMounterMockRecorder) MountSensitiveWithoutSystemdWithMountFlags(source, target, fstype, options, sensitiveOptions, mountFlags interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountSensitiveWithoutSystemdWithMountFlags", reflect.TypeOf((*MockMounter)(nil).MountSensitiveWithoutSystemdWithMountFlags), source, target, fstype, options, sensitiveOptions, mountFlags)
}</span>

// NeedResize mocks base method.
func (m *MockMounter) NeedResize(devicePath, deviceMountPath string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "NeedResize", devicePath, deviceMountPath)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// NeedResize indicates an expected call of NeedResize.
func (mr *MockMounterMockRecorder) NeedResize(devicePath, deviceMountPath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NeedResize", reflect.TypeOf((*MockMounter)(nil).NeedResize), devicePath, deviceMountPath)
}</span>

// PathExists mocks base method.
func (m *MockMounter) PathExists(path string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PathExists", path)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// PathExists indicates an expected call of PathExists.
func (mr *MockMounterMockRecorder) PathExists(path interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PathExists", reflect.TypeOf((*MockMounter)(nil).PathExists), path)
}</span>

// PreparePublishTarget mocks base method.
func (m *MockMounter) PreparePublishTarget(target string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "PreparePublishTarget", target)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// PreparePublishTarget indicates an expected call of PreparePublishTarget.
func (mr *MockMounterMockRecorder) PreparePublishTarget(target interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreparePublishTarget", reflect.TypeOf((*MockMounter)(nil).PreparePublishTarget), target)
}</span>

// Resize mocks base method.
func (m *MockMounter) Resize(devicePath, deviceMountPath string) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Resize", devicePath, deviceMountPath)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Resize indicates an expected call of Resize.
func (mr *MockMounterMockRecorder) Resize(devicePath, deviceMountPath interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Resize", reflect.TypeOf((*MockMounter)(nil).Resize), devicePath, deviceMountPath)
}</span>

// Unmount mocks base method.
func (m *MockMounter) Unmount(target string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unmount", target)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Unmount indicates an expected call of Unmount.
func (mr *MockMounterMockRecorder) Unmount(target interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unmount", reflect.TypeOf((*MockMounter)(nil).Unmount), target)
}</span>

// Unpublish mocks base method.
func (m *MockMounter) Unpublish(path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unpublish", path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Unpublish indicates an expected call of Unpublish.
func (mr *MockMounterMockRecorder) Unpublish(path interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unpublish", reflect.TypeOf((*MockMounter)(nil).Unpublish), path)
}</span>

// Unstage mocks base method.
func (m *MockMounter) Unstage(path string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Unstage", path)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Unstage indicates an expected call of Unstage.
func (mr *MockMounterMockRecorder) Unstage(path interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unstage", reflect.TypeOf((*MockMounter)(nil).Unstage), path)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package mounter implements OS-specific functionality for interacting with mounts.
//
// The package should any implementation of mount related functionality that is not portable across platforms.
package mounter

import (
        mountutils "k8s.io/mount-utils"
)

// Mounter is the interface implemented by NodeMounter.
// A mix &amp; match of functions defined in upstream libraries. (FormatAndMount
// from struct SafeFormatAndMount, PathExists from an old edition of
// mount.Interface). Define it explicitly so that it can be mocked and to
// insulate from oft-changing upstream interfaces/structs.
type Mounter interface {
        mountutils.Interface

        FormatAndMountSensitiveWithFormatOptions(source string, target string, fstype string, options []string, sensitiveOptions []string, formatOptions []string) error
        IsCorruptedMnt(err error) bool
        GetDeviceNameFromMount(mountPath string) (string, int, error)
        MakeFile(path string) error
        MakeDir(path string) error
        PathExists(path string) (bool, error)
        NeedResize(devicePath string, deviceMountPath string) (bool, error)
        Unpublish(path string) error
        Unstage(path string) error
        Resize(devicePath, deviceMountPath string) (bool, error)
        FindDevicePath(devicePath, volumeID, partition, region string) (string, error)
        PreparePublishTarget(target string) error
        IsBlockDevice(fullPath string) (bool, error)
        GetBlockSizeBytes(devicePath string) (int64, error)
        GetVolumeStats(volumePath string) (VolumeStats, error)
}

// VolumeStats holds volume stats returned by GetVolumeStats.
type VolumeStats struct {
        AvailableBytes int64
        TotalBytes     int64
        UsedBytes      int64

        AvailableInodes int64
        TotalInodes     int64
        UsedInodes      int64
}

// NodeMounter implements Mounter.
// A superstruct of SafeFormatAndMount.
type NodeMounter struct {
        *mountutils.SafeFormatAndMount
}

// NewNodeMounter returns a new intsance of NodeMounter.
func NewNodeMounter(hostprocess bool) (Mounter, error) <span class="cov8" title="1">{
        var safeMounter *mountutils.SafeFormatAndMount
        var err error

        if hostprocess </span><span class="cov0" title="0">{
                safeMounter, err = NewSafeMounterV2()
        }</span> else<span class="cov8" title="1"> {
                safeMounter, err = NewSafeMounter()
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;NodeMounter{safeMounter}, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">//go:build linux

/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mounter

import (
        "errors"
        "fmt"
        "math"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "golang.org/x/sys/unix"
        "k8s.io/klog/v2"
        mountutils "k8s.io/mount-utils"
        utilexec "k8s.io/utils/exec"
)

const (
        nvmeDiskPartitionSuffix = "p"
        diskPartitionSuffix     = ""
)

func NewSafeMounter() (*mountutils.SafeFormatAndMount, error) <span class="cov8" title="1">{
        return &amp;mountutils.SafeFormatAndMount{
                Interface: mountutils.New(""),
                Exec:      utilexec.New(),
        }, nil
}</span>

func NewSafeMounterV2() (*mountutils.SafeFormatAndMount, error) <span class="cov0" title="0">{
        return nil, errors.New("NewSafeMounterV2 is not supported on this platform")
}</span>

// FindDevicePath finds path of device and verifies its existence
// if the device is not nvme, return the path directly
// if the device is nvme, finds and returns the nvme device path eg. /dev/nvme1n1.
func (m *NodeMounter) FindDevicePath(devicePath, volumeID, partition, region string) (string, error) <span class="cov8" title="1">{
        strippedVolumeName := strings.ReplaceAll(volumeID, "-", "")
        canonicalDevicePath := ""

        // If the given path exists, the device MAY be nvme. Further, it MAY be a
        // symlink to the nvme device path like:
        // | $ stat /dev/xvdba
        // | File: ‘/dev/xvdba’ -&gt; ‘nvme1n1’
        // Since these are maybes, not guarantees, the search for the nvme device
        // path below must happen and must rely on volume ID
        exists, err := m.PathExists(devicePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to check if path %q exists: %w", devicePath, err)
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                stat, lstatErr := os.Lstat(devicePath)
                if lstatErr != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to lstat %q: %w", devicePath, lstatErr)
                }</span>

                <span class="cov8" title="1">if stat.Mode()&amp;os.ModeSymlink == os.ModeSymlink </span><span class="cov0" title="0">{
                        canonicalDevicePath, err = filepath.EvalSymlinks(devicePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to evaluate symlink %q: %w", devicePath, err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        canonicalDevicePath = devicePath
                }</span>

                <span class="cov8" title="1">klog.V(5).InfoS("[Debug] The canonical device path was resolved", "devicePath", devicePath, "cacanonicalDevicePath", canonicalDevicePath)
                if err = verifyVolumeSerialMatch(canonicalDevicePath, strippedVolumeName, execRunner); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return m.appendPartition(canonicalDevicePath, partition), nil</span>
        }

        <span class="cov8" title="1">klog.V(5).InfoS("[Debug] Falling back to nvme volume ID lookup", "devicePath", devicePath)

        // AWS recommends identifying devices by volume ID
        // (https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/nvme-ebs-volumes.html),
        // so find the nvme device path using volume ID. This is the magic name on
        // which AWS presents NVME devices under /dev/disk/by-id/. For example,
        // vol-0fab1d5e3f72a5e23 creates a symlink at
        // /dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_vol0fab1d5e3f72a5e23
        nvmeName := "nvme-Amazon_Elastic_Block_Store_" + strippedVolumeName
        nvmeDevicePath, err := findNvmeVolume(nvmeName)

        if err == nil </span><span class="cov0" title="0">{
                klog.V(5).InfoS("[Debug] successfully resolved", "nvmeName", nvmeName, "nvmeDevicePath", nvmeDevicePath)
                canonicalDevicePath = nvmeDevicePath
                if err = verifyVolumeSerialMatch(canonicalDevicePath, strippedVolumeName, execRunner); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">return m.appendPartition(canonicalDevicePath, partition), nil</span>
        } else<span class="cov8" title="1"> {
                klog.V(5).InfoS("[Debug] error searching for nvme path", "nvmeName", nvmeName, "err", err)
        }</span>

        <span class="cov8" title="1">if canonicalDevicePath == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no device path for device %q volume %q found", devicePath, volumeID)
        }</span>

        <span class="cov0" title="0">canonicalDevicePath = m.appendPartition(canonicalDevicePath, partition)
        return canonicalDevicePath, nil</span>
}

// findNvmeVolume looks for the nvme volume with the specified name
// It follows the symlink (if it exists) and returns the absolute path to the device.
func findNvmeVolume(findName string) (device string, err error) <span class="cov8" title="1">{
        p := filepath.Join("/dev/disk/by-id/", findName)
        stat, err := os.Lstat(p)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        klog.V(5).InfoS("[Debug] nvme path not found", "path", p)
                        return "", fmt.Errorf("nvme path %q not found", p)
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("error getting stat of %q: %w", p, err)</span>
        }

        <span class="cov0" title="0">if stat.Mode()&amp;os.ModeSymlink != os.ModeSymlink </span><span class="cov0" title="0">{
                klog.InfoS("nvme file found, but was not a symlink", "path", p)
                return "", fmt.Errorf("nvme file %q found, but was not a symlink", p)
        }</span>
        // Find the target, resolving to an absolute path
        // For example, /dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_vol0fab1d5e3f72a5e23 -&gt; ../../nvme2n1
        <span class="cov0" title="0">resolved, err := filepath.EvalSymlinks(p)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error reading target of symlink %q: %w", p, err)
        }</span>

        <span class="cov0" title="0">if !strings.HasPrefix(resolved, "/dev") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("resolved symlink for %q was unexpected: %q", p, resolved)
        }</span>

        <span class="cov0" title="0">return resolved, nil</span>
}

// execRunner is a helper to inject exec.Comamnd().CombinedOutput() for verifyVolumeSerialMatch
// Tests use a mocked version that does not actually execute any binaries.
func execRunner(name string, arg ...string) ([]byte, error) <span class="cov8" title="1">{
        return exec.Command(name, arg...).CombinedOutput()
}</span>

// verifyVolumeSerialMatch checks the volume serial of the device against the expected volume.
func verifyVolumeSerialMatch(canonicalDevicePath string, strippedVolumeName string, execRunner func(string, ...string) ([]byte, error)) error <span class="cov8" title="1">{
        // In some rare cases, a race condition can lead to the /dev/disk/by-id/ symlink becoming out of date
        // See https://github.com/kubernetes-sigs/aws-ebs-csi-driver/issues/1224 for more info
        // Attempt to use lsblk to double check that the nvme device selected was the correct volume
        output, err := execRunner("lsblk", "--noheadings", "--ascii", "--nodeps", "--output", "SERIAL", canonicalDevicePath)

        if err == nil </span><span class="cov0" title="0">{
                // Look for an EBS volume ID in the output, compare all matches against what we expect
                // (in some rare cases there may be multiple matches due to lsblk printing partitions)
                // If no volume ID is in the output (non-Nitro instances, SBE devices, etc) silently proceed
                volumeRegex := regexp.MustCompile(`vol[a-z0-9]+`)
                for _, volume := range volumeRegex.FindAllString(string(output), -1) </span><span class="cov0" title="0">{
                        klog.V(6).InfoS("Comparing volume serial", "canonicalDevicePath", canonicalDevicePath, "expected", strippedVolumeName, "actual", volume)
                        if volume != strippedVolumeName </span><span class="cov0" title="0">{
                                return fmt.Errorf("refusing to mount %s because it claims to be %s but should be %s", canonicalDevicePath, volume, strippedVolumeName)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // If the command fails (for example, because lsblk is not available), silently ignore the error and proceed
                klog.V(5).ErrorS(err, "Ignoring lsblk failure", "canonicalDevicePath", canonicalDevicePath, "strippedVolumeName", strippedVolumeName)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// PreparePublishTarget creates the target directory for the volume to be mounted.
func (m *NodeMounter) PreparePublishTarget(target string) error <span class="cov0" title="0">{
        klog.V(4).InfoS("NodePublishVolume: creating dir", "target", target)
        if err := m.MakeDir(target); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create dir %q: %w", target, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsBlockDevice checks if the given path is a block device.
func (m *NodeMounter) IsBlockDevice(fullPath string) (bool, error) <span class="cov0" title="0">{
        var st unix.Stat_t
        err := unix.Stat(fullPath, &amp;st)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return (st.Mode &amp; unix.S_IFMT) == unix.S_IFBLK, nil</span>
}

// GetBlockSizeBytes gets the size of the disk in bytes.
func (m *NodeMounter) GetBlockSizeBytes(devicePath string) (int64, error) <span class="cov0" title="0">{
        output, err := m.Exec.Command("blockdev", "--getsize64", devicePath).Output()
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("error when getting size of block volume at path %s: output: %s, err: %w", devicePath, string(output), err)
        }</span>
        <span class="cov0" title="0">strOut := strings.TrimSpace(string(output))
        gotSizeBytes, err := strconv.ParseInt(strOut, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to parse size %s as int", strOut)
        }</span>
        <span class="cov0" title="0">return gotSizeBytes, nil</span>
}

// appendPartition appends the partition to the device path.
func (m *NodeMounter) appendPartition(devicePath, partition string) string <span class="cov8" title="1">{
        if partition == "" </span><span class="cov0" title="0">{
                return devicePath
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(devicePath, "/dev/nvme") </span><span class="cov0" title="0">{
                return devicePath + nvmeDiskPartitionSuffix + partition
        }</span>

        <span class="cov8" title="1">return devicePath + diskPartitionSuffix + partition</span>
}

// GetDeviceNameFromMount returns the volume ID for a mount path.
func (m *NodeMounter) GetDeviceNameFromMount(mountPath string) (string, int, error) <span class="cov8" title="1">{
        return mountutils.GetDeviceNameFromMount(m, mountPath)
}</span>

// IsCorruptedMnt return true if err is about corrupted mount point.
func (m *NodeMounter) IsCorruptedMnt(err error) bool <span class="cov0" title="0">{
        return mountutils.IsCorruptedMnt(err)
}</span>

// This function is mirrored in ./sanity_test.go to make sure sanity test covered this block of code
// Please mirror the change to func MakeFile in ./sanity_test.go.
func (m *NodeMounter) MakeFile(path string) error <span class="cov8" title="1">{
        f, err := os.OpenFile(path, os.O_CREATE, os.FileMode(0644))
        if err != nil </span><span class="cov0" title="0">{
                if !os.IsExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if err = f.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// This function is mirrored in ./sanity_test.go to make sure sanity test covered this block of code
// Please mirror the change to func MakeFile in ./sanity_test.go.
func (m *NodeMounter) MakeDir(path string) error <span class="cov8" title="1">{
        err := os.MkdirAll(path, os.FileMode(0755))
        if err != nil </span><span class="cov0" title="0">{
                if !os.IsExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// This function is mirrored in ./sanity_test.go to make sure sanity test covered this block of code
// Please mirror the change to func MakeFile in ./sanity_test.go.
func (m *NodeMounter) PathExists(path string) (bool, error) <span class="cov8" title="1">{
        return mountutils.PathExists(path)
}</span>

// Resize resizes the filesystem of the given devicePath.
func (m *NodeMounter) Resize(devicePath, deviceMountPath string) (bool, error) <span class="cov0" title="0">{
        return mountutils.NewResizeFs(m.Exec).Resize(devicePath, deviceMountPath)
}</span>

// NeedResize checks if the filesystem of the given devicePath needs to be resized.
func (m *NodeMounter) NeedResize(devicePath string, deviceMountPath string) (bool, error) <span class="cov8" title="1">{
        return mountutils.NewResizeFs(m.Exec).NeedResize(devicePath, deviceMountPath)
}</span>

// Unpublish unmounts the given path.
func (m *NodeMounter) Unpublish(path string) error <span class="cov0" title="0">{
        // On linux, unpublish and unstage both perform an unmount
        return m.Unstage(path)
}</span>

// Unstage unmounts the given path.
func (m *NodeMounter) Unstage(path string) error <span class="cov0" title="0">{
        err := mountutils.CleanupMountPoint(path, m, false)
        // Ignore the error when it contains "not mounted", because that indicates the
        // world is already in the desired state
        //
        // mount-utils attempts to detect this on its own but fails when running on
        // a read-only root filesystem, which our manifests use by default
        if err == nil || strings.Contains(fmt.Sprint(err), "not mounted") </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                return err
        }</span>
}

// GetVolumeStats acquires byte and inode statistics of filesystem at volumePath.
func (m *NodeMounter) GetVolumeStats(volumePath string) (VolumeStats, error) <span class="cov0" title="0">{
        stats := VolumeStats{}

        statfs := &amp;unix.Statfs_t{}
        err := unix.Statfs(volumePath, statfs)
        if err != nil </span><span class="cov0" title="0">{
                return stats, err
        }</span>

        // Get byte stats (safely)
        <span class="cov0" title="0">bsize := statfs.Bsize
        if bsize &lt; 0 </span><span class="cov0" title="0">{
                return stats, fmt.Errorf("negative block size reported: %d", bsize)
        }</span>
        <span class="cov0" title="0">ubsize := uint64(bsize)

        if statfs.Bavail &gt; math.MaxUint64/ubsize </span><span class="cov0" title="0">{
                return stats, errors.New("available bytes calculation would overflow")
        }</span>
        <span class="cov0" title="0">availBytes := statfs.Bavail * ubsize
        if availBytes &gt; math.MaxInt64 </span><span class="cov0" title="0">{
                return stats, errors.New("available bytes value exceeds int64 maximum")
        }</span>
        <span class="cov0" title="0">stats.AvailableBytes = int64(availBytes)

        if statfs.Blocks &gt; math.MaxUint64/ubsize </span><span class="cov0" title="0">{
                return stats, errors.New("total bytes calculation would overflow")
        }</span>
        <span class="cov0" title="0">totBytes := statfs.Blocks * ubsize
        if totBytes &gt; math.MaxInt64 </span><span class="cov0" title="0">{
                return stats, errors.New("total bytes value exceeds int64 maximum")
        }</span>
        <span class="cov0" title="0">stats.TotalBytes = int64(totBytes)

        var usedBlocks uint64
        if statfs.Blocks &gt; statfs.Bfree </span><span class="cov0" title="0">{
                usedBlocks = statfs.Blocks - statfs.Bfree
        }</span> else<span class="cov0" title="0"> {
                usedBlocks = 0
        }</span>

        <span class="cov0" title="0">if usedBlocks &gt; math.MaxUint64/ubsize </span><span class="cov0" title="0">{
                return stats, errors.New("used bytes calculation would overflow")
        }</span>
        <span class="cov0" title="0">usedBytes := usedBlocks * ubsize
        if usedBytes &gt; math.MaxInt64 </span><span class="cov0" title="0">{
                return stats, errors.New("used bytes value exceeds int64 maximum")
        }</span>
        <span class="cov0" title="0">stats.UsedBytes = int64(usedBytes)

        // Get inode stats (safely)
        if statfs.Ffree &gt; math.MaxInt64 </span><span class="cov0" title="0">{
                return stats, errors.New("available inodes value exceeds int64 maximum")
        }</span>
        <span class="cov0" title="0">stats.AvailableInodes = int64(statfs.Ffree)

        if statfs.Files &gt; math.MaxInt64 </span><span class="cov0" title="0">{
                return stats, errors.New("total inodes value exceeds int64 maximum")
        }</span>
        <span class="cov0" title="0">stats.TotalInodes = int64(statfs.Files)

        if stats.TotalInodes &lt; stats.AvailableInodes </span><span class="cov0" title="0">{
                return stats, errors.New("inconsistent inode counts: total &lt; available")
        }</span>
        <span class="cov0" title="0">stats.UsedInodes = stats.TotalInodes - stats.AvailableInodes

        return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package template

import (
        "errors"
        "fmt"
        "html/template"
        "strings"
)

// Disable functions.
func html(...interface{}) (string, error) <span class="cov8" title="1">{
        return "", errors.New("cannot call 'html' function")
}</span>

func js(...interface{}) (string, error) <span class="cov8" title="1">{
        return "", errors.New("cannot call 'js' function")
}</span>

func call(...interface{}) (string, error) <span class="cov8" title="1">{
        return "", errors.New("cannot call 'call' function")
}</span>

func urlquery(...interface{}) (string, error) <span class="cov8" title="1">{
        return "", errors.New("cannot call 'urlquery' function")
}</span>

func contains(arg1, arg2 string) bool <span class="cov8" title="1">{
        return strings.Contains(arg2, arg1)
}</span>

func substring(start, end int, arg string) string <span class="cov8" title="1">{
        if start &lt; 0 </span><span class="cov0" title="0">{
                return arg[:end]
        }</span>

        <span class="cov8" title="1">if end &lt; 0 || end &gt; len(arg) </span><span class="cov0" title="0">{
                return arg[start:]
        }</span>

        <span class="cov8" title="1">return arg[start:end]</span>
}

func field(delim string, idx int, arg string) (string, error) <span class="cov8" title="1">{
        w := strings.Split(arg, delim)
        if idx &gt;= len(w) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("extractWord: cannot index into split string; index = %d, length = %d", idx, len(w))
        }</span>
        <span class="cov8" title="1">return w[idx], nil</span>
}

func index(arg1, arg2 string) int <span class="cov0" title="0">{
        return strings.Index(arg2, arg1)
}</span>

func lastIndex(arg1, arg2 string) int <span class="cov0" title="0">{
        return strings.LastIndex(arg2, arg1)
}</span>

func newFuncMap() template.FuncMap <span class="cov8" title="1">{
        return template.FuncMap{
                "html":      html,
                "js":        js,
                "call":      call,
                "urlquery":  urlquery,
                "contains":  contains,
                "toUpper":   strings.ToUpper,
                "toLower":   strings.ToLower,
                "substring": substring,
                "field":     field,
                "index":     index,
                "lastIndex": lastIndex,
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2024 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the 'License');
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an 'AS IS' BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package template

import (
        "fmt"
        "strings"
        "text/template"

        "k8s.io/klog/v2"
)

type PVProps struct {
        PVCName      string
        PVCNamespace string
        PVName       string
}

type VolumeSnapshotProps struct {
        VolumeSnapshotName        string
        VolumeSnapshotNamespace   string
        VolumeSnapshotContentName string
}

func Evaluate(tm []string, props interface{}, warnOnly bool) (map[string]string, error) <span class="cov8" title="1">{
        md := make(map[string]string)
        for _, s := range tm </span><span class="cov8" title="1">{
                st := strings.SplitN(s, "=", 2)
                if len(st) != 2 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("the key-value pair doesn't contain a value (string: %s)", s)
                }</span>

                <span class="cov8" title="1">key, value := st[0], st[1]

                t := template.New("tmpl").Funcs(newFuncMap())
                val, err := execTemplate(value, props, t)
                if err != nil </span><span class="cov8" title="1">{
                        if warnOnly </span><span class="cov8" title="1">{
                                klog.InfoS("Unable to interpolate value", "key", key, "value", value, "err", err)
                        }</span> else<span class="cov8" title="1"> {
                                return nil, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        md[key] = val
                }</span>
        }
        <span class="cov8" title="1">return md, nil</span>
}

func execTemplate(value string, props interface{}, t *template.Template) (string, error) <span class="cov8" title="1">{
        tmpl, err := t.Parse(value)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">b := new(strings.Builder)
        err = tmpl.Execute(b, props)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return b.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package util

import (
        "fmt"
        "math"
        "net/url"
        "os"
        "path/filepath"
        "reflect"
        "regexp"
        "runtime"
        "strings"

        csi "github.com/container-storage-interface/spec/lib/go/csi"
)

const (
        GiB              = int64(1024 * 1024 * 1024)
        DefaultBlockSize = 4096
)

var (
        isAlphanumericRegex = regexp.MustCompile(`^[a-zA-Z0-9]*$`).MatchString
        // MAC Address Regex Source: https://stackoverflow.com/a/4260512
        isMACAddressRegex = regexp.MustCompile(`([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})`)
)

// RoundUpBytes rounds up the volume size in bytes up to multiplications of GiB.
func RoundUpBytes(volumeSizeBytes int64) int64 <span class="cov8" title="1">{
        return roundUpSize(volumeSizeBytes, GiB) * GiB
}</span>

// RoundUpGiB rounds up the volume size in bytes upto multiplications of GiB
// in the unit of GiB.
func RoundUpGiB(volumeSizeBytes int64) (int32, error) <span class="cov8" title="1">{
        result := roundUpSize(volumeSizeBytes, GiB)
        if result &gt; int64(math.MaxInt32) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("rounded up size exceeds maximum value of int32: %d", result)
        }</span>
        //nolint:gosec // Integer overflow handled
        <span class="cov8" title="1">return int32(result), nil</span>
}

// BytesToGiB converts Bytes to GiB.
func BytesToGiB(volumeSizeBytes int64) int32 <span class="cov8" title="1">{
        result := volumeSizeBytes / GiB
        if result &gt; int64(math.MaxInt32) </span><span class="cov0" title="0">{
                // Handle overflow
                return math.MaxInt32
        }</span>
        //nolint:gosec // Integer overflow handled
        <span class="cov8" title="1">return int32(result)</span>
}

// GiBToBytes converts GiB to Bytes.
func GiBToBytes(volumeSizeGiB int32) int64 <span class="cov8" title="1">{
        return int64(volumeSizeGiB) * GiB
}</span>

func ParseEndpoint(endpoint string, hostprocess bool) (string, string, error) <span class="cov8" title="1">{
        if runtime.GOOS == "windows" &amp;&amp; hostprocess </span><span class="cov0" title="0">{
                parts := strings.SplitN(endpoint, "://", 2)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("invalid endpoint format: %s", endpoint)
                }</span>
                <span class="cov0" title="0">scheme := strings.ToLower(parts[0])
                addr := parts[1]

                // Remove the socket file if it already exists
                if scheme == "unix" </span><span class="cov0" title="0">{
                        if _, err := os.Stat(addr); err == nil </span><span class="cov0" title="0">{
                                if err := os.Remove(addr); err != nil </span><span class="cov0" title="0">{
                                        return "", "", fmt.Errorf("failed to remove existing socket file: %w", err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return scheme, addr, nil</span>
        }

        <span class="cov8" title="1">u, err := url.Parse(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("could not parse endpoint: %w", err)
        }</span>

        <span class="cov8" title="1">addr := filepath.Join(u.Host, filepath.FromSlash(u.Path))

        scheme := strings.ToLower(u.Scheme)
        switch scheme </span>{
        case "tcp":<span class="cov8" title="1"></span>
        case "unix":<span class="cov8" title="1">
                addr = filepath.Join("/", addr)
                if err := os.Remove(addr); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return "", "", fmt.Errorf("could not remove unix domain socket %q: %w", addr, err)
                }</span>
        default:<span class="cov8" title="1">
                return "", "", fmt.Errorf("unsupported protocol: %s", scheme)</span>
        }

        <span class="cov8" title="1">return scheme, addr, nil</span>
}

func roundUpSize(volumeSizeBytes int64, allocationUnitBytes int64) int64 <span class="cov8" title="1">{
        if allocationUnitBytes == 0 </span><span class="cov0" title="0">{
                return 0 // Avoid division by zero
        }</span>
        <span class="cov8" title="1">return (volumeSizeBytes + allocationUnitBytes - 1) / allocationUnitBytes</span>
}

// GetAccessModes returns a slice containing all of the access modes defined
// in the passed in VolumeCapabilities.
func GetAccessModes(caps []*csi.VolumeCapability) *[]string <span class="cov8" title="1">{
        modes := []string{}
        for _, c := range caps </span><span class="cov8" title="1">{
                modes = append(modes, c.GetAccessMode().GetMode().String())
        }</span>
        <span class="cov8" title="1">return &amp;modes</span>
}

// StringIsAlphanumeric returns true if a given string contains only English letters or numbers.
func StringIsAlphanumeric(s string) bool <span class="cov8" title="1">{
        return isAlphanumericRegex(s)
}</span>

// CountMACAddresses returns the amount of MAC addresses within a string.
func CountMACAddresses(s string) int <span class="cov8" title="1">{
        matches := isMACAddressRegex.FindAllStringIndex(s, -1)
        return len(matches)
}</span>

// NormalizeWindowsPath normalizes a Windows path.
func NormalizeWindowsPath(path string) string <span class="cov0" title="0">{
        normalizedPath := strings.ReplaceAll(path, "/", "\\")
        if strings.HasPrefix(normalizedPath, "\\") </span><span class="cov0" title="0">{
                normalizedPath = "c:" + normalizedPath
        }</span>
        <span class="cov0" title="0">return normalizedPath</span>
}

// SanitizeRequest takes a request object and returns a copy of the request with
// the "Secrets" field cleared.
func SanitizeRequest(req interface{}) interface{} <span class="cov8" title="1">{
        v := reflect.ValueOf(&amp;req).Elem()
        e := reflect.New(v.Elem().Type()).Elem()

        e.Set(v.Elem())

        f := reflect.Indirect(e).FieldByName("Secrets")

        if f.IsValid() &amp;&amp; f.CanSet() &amp;&amp; f.Kind() == reflect.Map </span><span class="cov8" title="1">{
                f.Set(reflect.MakeMap(f.Type()))
                v.Set(e)
        }</span>
        <span class="cov8" title="1">return req</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
